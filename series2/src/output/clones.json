{"duplicatesPercentage":1.065956029,"nodes":{"children":[{"percentageOfProject":0.04996668887,"id":11,"children":[{"attributes":{"LOC":6,"path":"/src/smallsql/database/Utils.java","percentageOfClass":50.0,"percentageOfProject":0.02498334444,"endLine":322,"startLine":317,"file":"Utils.java","clone":"{\r\n        try{\r\n            return Double.parseDouble( val ) != 0;\r\n        }catch(NumberFormatException e){/*ignore it if it not a number*/}\r\n        return \"true\".equalsIgnoreCase( val ) || \"yes\".equalsIgnoreCase( val ) || \"t\".equalsIgnoreCase( val );\r\n    }"},"id":12},{"attributes":{"LOC":6,"path":"/src/smallsql/junit/BasicTestCase.java","percentageOfClass":50.0,"percentageOfProject":0.02498334444,"endLine":196,"startLine":191,"file":"BasicTestCase.java","clone":"{\r\n        try{\r\n            return Double.parseDouble( val ) != 0;\r\n        }catch(NumberFormatException e){/*ignore it if it not a number*/}\r\n        return \"true\".equalsIgnoreCase( val ) || \"yes\".equalsIgnoreCase( val ) || \"t\".equalsIgnoreCase( val );\r\n    }"},"id":13}]},{"percentageOfProject":0.04996668887,"id":14,"children":[{"attributes":{"LOC":4,"path":"/src/smallsql/junit/TestThreads.java","percentageOfClass":33.33333333,"percentageOfProject":0.01665556296,"endLine":110,"startLine":106,"file":"TestThreads.java","clone":"// wait until all threads are finish\r\n            for(int i = 0; i < threadList.size(); i++){\r\n                Thread thread = (Thread)threadList.get(i);\r\n                thread.join(5000);\r\n            }"},"id":15},{"attributes":{"LOC":4,"path":"/src/smallsql/junit/TestThreads.java","percentageOfClass":33.33333333,"percentageOfProject":0.01665556296,"endLine":63,"startLine":59,"file":"TestThreads.java","clone":"// wait until all threads are finish\r\n        for(int i = 0; i < threadList.size(); i++){\r\n            Thread thread = (Thread)threadList.get(i);\r\n            thread.join(5000);\r\n        }"},"id":16},{"attributes":{"LOC":4,"path":"/src/smallsql/junit/TestThreads.java","percentageOfClass":33.33333333,"percentageOfProject":0.01665556296,"endLine":164,"startLine":160,"file":"TestThreads.java","clone":"// wait until all threads are finish\r\n            for(int i = 0; i < threadList.size(); i++){\r\n                Thread thread = (Thread)threadList.get(i);\r\n                thread.join(5000);\r\n            }"},"id":17}]},{"percentageOfProject":0.0416389074,"id":18,"children":[{"attributes":{"LOC":5,"path":"/src/smallsql/database/ExpressionFunctionConvert.java","percentageOfClass":50.0,"percentageOfProject":0.0208194537,"endLine":157,"startLine":153,"file":"ExpressionFunctionConvert.java","clone":"{\r\n\t\t\t\t\tbyte[] buffer = new byte[length];\r\n\t\t\t\t\tSystem.arraycopy(bytes, 0, buffer, 0, Math.min(bytes.length,length) );\r\n\t\t\t\t\treturn buffer;\r\n\t\t\t\t}"},"id":19},{"attributes":{"LOC":5,"path":"/src/smallsql/database/ExpressionFunctionConvert.java","percentageOfClass":50.0,"percentageOfProject":0.0208194537,"endLine":146,"startLine":142,"file":"ExpressionFunctionConvert.java","clone":"{\r\n\t\t\t\t\tbyte[] buffer = new byte[length];\r\n\t\t\t\t\tSystem.arraycopy(bytes, 0, buffer, 0, Math.min(bytes.length,length) );\r\n\t\t\t\t\treturn buffer;\r\n\t\t\t\t}"},"id":110}]},{"percentageOfProject":0.0416389074,"id":111,"children":[{"attributes":{"LOC":5,"path":"/src/smallsql/junit/TestOrderBy.java","percentageOfClass":50.0,"percentageOfProject":0.0208194537,"endLine":435,"startLine":431,"file":"TestOrderBy.java","clone":"while(rs.next()){\r\n\t\t\tassertTrue( oldValue.compareTo( (Integer)rs.getObject(\"i\") ) < 0 );\r\n\t\t\toldValue = (Integer)rs.getObject(\"i\");\r\n\t\t\tcount++;\r\n\t\t}"},"id":112},{"attributes":{"LOC":5,"path":"/src/smallsql/junit/TestOrderBy.java","percentageOfClass":50.0,"percentageOfProject":0.0208194537,"endLine":350,"startLine":346,"file":"TestOrderBy.java","clone":"while(rs.next()){\r\n\t\t\tassertTrue( oldValue.compareTo( (Integer)rs.getObject(\"i\") ) < 0 );\r\n\t\t\toldValue = (Integer)rs.getObject(\"i\");\r\n\t\t\tcount++;\r\n\t\t}"},"id":113}]},{"percentageOfProject":0.09160559627,"id":114,"children":[{"attributes":{"LOC":11,"path":"/src/smallsql/database/IndexScrollStatus.java","percentageOfClass":50.0,"percentageOfProject":0.04580279813,"endLine":131,"startLine":120,"file":"IndexScrollStatus.java","clone":"if(status.nodeValue != null){\r\n\t\t\t\t\t\tif(status.nodeValue instanceof IndexNode){\r\n\t\t\t\t\t\t\tlevel++;\r\n\t\t\t\t\t\t\tnodeStack.push(\r\n\t\t\t\t\t\t\t\tnew IndexNodeScrollStatus( \t(IndexNode)status.nodeValue, \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(expressions.get(level).getAlias() != SQLTokenizer.DESC_STR), \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tscroll, level));\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}else\r\n\t\t\t\t\t\t\treturn getReturnValue(status.nodeValue);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//There is no RowOffset in this node"},"id":115},{"attributes":{"LOC":11,"path":"/src/smallsql/database/IndexScrollStatus.java","percentageOfClass":50.0,"percentageOfProject":0.04580279813,"endLine":99,"startLine":89,"file":"IndexScrollStatus.java","clone":"if(status.nodeValue != null){\r\n\t\t\t\t\t\tif(status.nodeValue instanceof IndexNode){\r\n\t\t\t\t\t\t\tlevel++;\r\n\t\t\t\t\t\t\tnodeStack.push(\r\n\t\t\t\t\t\t\t\tnew IndexNodeScrollStatus( \t(IndexNode)status.nodeValue, \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(expressions.get(level).getAlias() != SQLTokenizer.DESC_STR), \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tscroll, level));\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}else\r\n\t\t\t\t\t\t\treturn getReturnValue(status.nodeValue);\r\n\t\t\t\t\t}"},"id":116}]},{"percentageOfProject":0.09160559627,"id":117,"children":[{"attributes":{"LOC":11,"path":"/src/smallsql/database/ExpressionFunctionTruncate.java","percentageOfClass":50.0,"percentageOfProject":0.04580279813,"endLine":60,"startLine":50,"file":"ExpressionFunctionTruncate.java","clone":"if(places > 0){\r\n\t\t\tfor(int i=0; i<places; i++){\r\n\t\t\t\tfactor *= 10;\r\n\t\t\t}\r\n\t\t\tvalue *= factor;\r\n\t\t}else{\r\n\t\t\tfor(int i=0; i>places; i--){\r\n\t\t\t\tfactor *= 10;\r\n\t\t\t}\r\n\t\t\tvalue /= factor;\r\n\t\t}"},"id":118},{"attributes":{"LOC":11,"path":"/src/smallsql/database/ExpressionFunctionRound.java","percentageOfClass":50.0,"percentageOfProject":0.04580279813,"endLine":60,"startLine":50,"file":"ExpressionFunctionRound.java","clone":"if(places > 0){\r\n\t\t\tfor(int i=0; i<places; i++){\r\n\t\t\t\tfactor *= 10;\r\n\t\t\t}\r\n\t\t\tvalue *= factor;\r\n\t\t}else{\r\n\t\t\tfor(int i=0; i>places; i--){\r\n\t\t\t\tfactor *= 10;\r\n\t\t\t}\r\n\t\t\tvalue /= factor;\r\n\t\t}"},"id":119}]},{"percentageOfProject":0.008327781479,"id":120,"children":[{"attributes":{"LOC":1,"path":"/src/smallsql/database/SSDatabaseMetaData.java","percentageOfClass":50.0,"percentageOfProject":0.00416389074,"endLine":753,"startLine":753,"file":"SSDatabaseMetaData.java","clone":"String[] colNames = {\"TABLE_CAT\", \"TABLE_SCHEM\", \"TABLE_NAME\", \"COLUMN_NAME\", \"DATA_TYPE\", \"TYPE_NAME\", \"COLUMN_SIZE\", \"BUFFER_LENGTH\", \"DECIMAL_DIGITS\", \"NUM_PREC_RADIX\", \"NULLABLE\", \"REMARKS\", \"COLUMN_DEF\", \"SQL_DATA_TYPE\", \"SQL_DATETIME_SUB\", \"CHAR_OCTET_LENGTH\", \"ORDINAL_POSITION\", \"IS_NULLABLE\"};"},"id":121},{"attributes":{"LOC":1,"path":"/src/smallsql/junit/TestDBMetaData.java","percentageOfClass":50.0,"percentageOfProject":0.00416389074,"endLine":182,"startLine":182,"file":"TestDBMetaData.java","clone":"String[] colNames = {\"TABLE_CAT\", \"TABLE_SCHEM\", \"TABLE_NAME\", \"COLUMN_NAME\", \"DATA_TYPE\", \"TYPE_NAME\", \"COLUMN_SIZE\", \"BUFFER_LENGTH\", \"DECIMAL_DIGITS\", \"NUM_PREC_RADIX\", \"NULLABLE\", \"REMARKS\", \"COLUMN_DEF\", \"SQL_DATA_TYPE\", \"SQL_DATETIME_SUB\", \"CHAR_OCTET_LENGTH\", \"ORDINAL_POSITION\", \"IS_NULLABLE\"};"},"id":122}]},{"percentageOfProject":0.02498334444,"id":123,"children":[{"attributes":{"LOC":3,"path":"/src/smallsql/junit/BenchTest.java","percentageOfClass":50.0,"percentageOfProject":0.01249167222,"endLine":123,"startLine":121,"file":"BenchTest.java","clone":"if (count != rowCount)\r\n                System.out.println( \"  Failed: Only \" + count + \" rows were inserted.\");\r\n            else System.out.println( \"  Test time: \" + time + \" ms\");"},"id":124},{"attributes":{"LOC":3,"path":"/src/smallsql/junit/BenchTest.java","percentageOfClass":50.0,"percentageOfProject":0.01249167222,"endLine":182,"startLine":180,"file":"BenchTest.java","clone":"if (count != rowCount)\r\n                 System.out.println( \"  Failed: Only \" + count + \" rows were inserted.\");\r\n            else System.out.println( \"  Test time: \" + time + \" ms\");"},"id":125}]},{"percentageOfProject":0.01665556296,"id":126,"children":[{"attributes":{"LOC":2,"path":"/src/smallsql/database/Index.java","percentageOfClass":50.0,"percentageOfProject":0.008327781479,"endLine":409,"startLine":407,"file":"Index.java","clone":"// the first digit include 0-null; 1-empty; 2 another value\r\n\t\t\tchar digit = (i<0) ? (length == 0 ? (char)1 : 2)\r\n\t\t\t\t\t\t\t  : (key[i]);"},"id":127},{"attributes":{"LOC":2,"path":"/src/smallsql/database/Index.java","percentageOfClass":50.0,"percentageOfProject":0.008327781479,"endLine":384,"startLine":382,"file":"Index.java","clone":"// the first digit include 0-null; 1-empty; 2 another value\r\n\t\t\tchar digit = (i<0) ? (length == 0 ? (char)1 : 2)\r\n\t\t\t\t\t\t\t  : (key[i]);"},"id":128}]},{"percentageOfProject":0.06662225183,"id":129,"children":[{"attributes":{"LOC":8,"path":"/src/smallsql/junit/TestOrderBy.java","percentageOfClass":50.0,"percentageOfProject":0.03331112592,"endLine":218,"startLine":211,"file":"TestOrderBy.java","clone":"while(oldValue != null && rs.next()){\r\n\t\t\tString newValue = rs.getString(\"v\");\r\n\t\t\tif(newValue != null){\r\n\t\t\t\tassertTrue( oldValue.compareTo( newValue ) > 0 );\r\n\t\t\t\tcount++;\r\n\t\t\t}\r\n\t\t\toldValue = newValue;\r\n\t\t}"},"id":130},{"attributes":{"LOC":8,"path":"/src/smallsql/junit/TestOrderBy.java","percentageOfClass":50.0,"percentageOfProject":0.03331112592,"endLine":246,"startLine":239,"file":"TestOrderBy.java","clone":"while(oldValue != null && rs.next()){\r\n\t\t\tString newValue = rs.getString(\"v\");\r\n\t\t\tif(newValue != null){\r\n\t\t\t\tassertTrue( oldValue.compareTo( newValue ) > 0 );\r\n\t\t\t\tcount++;\r\n\t\t\t}\r\n\t\t\toldValue = newValue;\r\n\t\t}"},"id":131}]},{"percentageOfProject":0.07495003331,"id":132,"children":[{"attributes":{"LOC":9,"path":"/src/smallsql/database/TableView.java","percentageOfClass":50.0,"percentageOfProject":0.03747501666,"endLine":113,"startLine":105,"file":"TableView.java","clone":"catch(Throwable e){\r\n\t\t\tif(raFile != null)\r\n\t\t\t\ttry{\r\n\t\t\t\t\traFile.close();\r\n\t\t\t\t}catch(Exception e2){\r\n\t\t\t\t\tDriverManager.println(e2.toString());\r\n\t\t\t\t}\r\n\t\t\tthrow SmallSQLException.createFromException(e);\r\n\t\t}"},"id":133},{"attributes":{"LOC":9,"path":"/src/smallsql/database/IndexDescription.java","percentageOfClass":50.0,"percentageOfProject":0.03747501666,"endLine":194,"startLine":186,"file":"IndexDescription.java","clone":"catch(Throwable e){\r\n            if(raFile != null)\r\n                try{\r\n                    raFile.close();\r\n                }catch(Exception e2){\r\n                    DriverManager.println(e2.toString());\r\n                }\r\n            throw SmallSQLException.createFromException(e);\r\n        }"},"id":134}]},{"percentageOfProject":0.07495003331,"id":135,"children":[{"attributes":{"LOC":9,"path":"/src/smallsql/database/SSCallableStatement.java","percentageOfClass":50.0,"percentageOfProject":0.03747501666,"endLine":125,"startLine":117,"file":"SSCallableStatement.java","clone":"{\r\n        try{\r\n            Expression expr = getValue(i);\r\n            wasNull = expr.isNull();\r\n            return expr.getLong();\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }"},"id":136},{"attributes":{"LOC":9,"path":"/src/smallsql/database/SSCallableStatement.java","percentageOfClass":50.0,"percentageOfProject":0.03747501666,"endLine":143,"startLine":135,"file":"SSCallableStatement.java","clone":"{\r\n        try{\r\n            Expression expr = getValue(i);\r\n            wasNull = expr.isNull();\r\n            return expr.getLong();\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }"},"id":137}]},{"percentageOfProject":0.008327781479,"id":138,"children":[{"attributes":{"LOC":1,"path":"/src/smallsql/database/SSDatabaseMetaData.java","percentageOfClass":50.0,"percentageOfProject":0.00416389074,"endLine":831,"startLine":831,"file":"SSDatabaseMetaData.java","clone":"String[] colNames = {\t\t\"TYPE_NAME\", \t\t\t\t\"DATA_TYPE\", \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"PRECISION\", \t\"LITERAL_PREFIX\", \"LITERAL_SUFFIX\", \t\t\"CREATE_PARAMS\", \"NULLABLE\", \t \"CASE_SENSITIVE\", \"SEARCHABLE\", \"UNSIGNED_ATTRIBUTE\", \"FIXED_PREC_SCALE\", \"AUTO_INCREMENT\", \"LOCAL_TYPE_NAME\", \"MINIMUM_SCALE\", \"MAXIMUM_SCALE\", \"SQL_DATA_TYPE\", \"SQL_DATETIME_SUB\", \"NUM_PREC_RADIX\"};"},"id":139},{"attributes":{"LOC":1,"path":"/src/smallsql/junit/TestDBMetaData.java","percentageOfClass":50.0,"percentageOfProject":0.00416389074,"endLine":210,"startLine":210,"file":"TestDBMetaData.java","clone":"String[] colNames = {\"TYPE_NAME\", \"DATA_TYPE\", \"PRECISION\", \"LITERAL_PREFIX\", \"LITERAL_SUFFIX\", \"CREATE_PARAMS\", \"NULLABLE\", \"CASE_SENSITIVE\", \"SEARCHABLE\", \"UNSIGNED_ATTRIBUTE\", \"FIXED_PREC_SCALE\", \"AUTO_INCREMENT\", \"LOCAL_TYPE_NAME\", \"MINIMUM_SCALE\", \"MAXIMUM_SCALE\", \"SQL_DATA_TYPE\", \"SQL_DATETIME_SUB\", \"NUM_PREC_RADIX\"};"},"id":140}]},{"percentageOfProject":0.06662225183,"id":141,"children":[{"attributes":{"LOC":8,"path":"/src/smallsql/junit/BasicTestCase.java","percentageOfClass":50.0,"percentageOfProject":0.03331112592,"endLine":109,"startLine":102,"file":"BasicTestCase.java","clone":"{\r\n\t\tStringBuffer buf = new StringBuffer(bytes.length << 1);\r\n\t\tfor(int i=0; i<bytes.length; i++){\r\n\t\t\tbuf.append( digits[ (bytes[i] >> 4) & 0x0F ] );\r\n\t\t\tbuf.append( digits[ (bytes[i]     ) & 0x0F ] );\r\n\t\t}\r\n\t\treturn buf.toString();\r\n\t}"},"id":142},{"attributes":{"LOC":8,"path":"/src/smallsql/database/Utils.java","percentageOfClass":50.0,"percentageOfProject":0.03331112592,"endLine":212,"startLine":205,"file":"Utils.java","clone":"{\r\n        StringBuffer buf = new StringBuffer(bytes.length << 1);\r\n        for(int i=0; i<bytes.length; i++){\r\n            buf.append( digits[ (bytes[i] >> 4) & 0x0F ] );\r\n            buf.append( digits[ (bytes[i]     ) & 0x0F ] );\r\n        }\r\n        return buf.toString();\r\n    }"},"id":143}]},{"percentageOfProject":0.04996668887,"id":144,"children":[{"attributes":{"LOC":6,"path":"/src/smallsql/junit/BenchTest.java","percentageOfClass":50.0,"percentageOfProject":0.02498334444,"endLine":328,"startLine":322,"file":"BenchTest.java","clone":"// There are not the correct count of rows.\r\n                if (count == 0){\r\n                    createTestDataWithClassicInsert( con );\r\n                    rs = st1.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n                    rs.next();\r\n                    count = rs.getInt(1);\r\n                }"},"id":145},{"attributes":{"LOC":6,"path":"/src/smallsql/junit/BenchTest.java","percentageOfClass":50.0,"percentageOfProject":0.02498334444,"endLine":214,"startLine":208,"file":"BenchTest.java","clone":"// There are not the correct count of rows.\r\n                if (count == 0){\r\n                    createTestDataWithClassicInsert( con );\r\n                    rs = st1.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n                    rs.next();\r\n                    count = rs.getInt(1);\r\n                }"},"id":146}]},{"percentageOfProject":0.04996668887,"id":147,"children":[{"attributes":{"LOC":6,"path":"/src/smallsql/database/SQLParser.java","percentageOfClass":50.0,"percentageOfProject":0.02498334444,"endLine":1937,"startLine":1932,"file":"SQLParser.java","clone":"try{\r\n            int maxRows = Integer.parseInt(token.getName(sql));\r\n            selCmd.setMaxRows(maxRows);\r\n        }catch(NumberFormatException e){\r\n            throw createSyntaxError(token, Language.STXADD_NOT_NUMBER, token.getName(sql));\r\n        }"},"id":148},{"attributes":{"LOC":6,"path":"/src/smallsql/database/SQLParser.java","percentageOfClass":50.0,"percentageOfProject":0.02498334444,"endLine":357,"startLine":352,"file":"SQLParser.java","clone":"try{\r\n\t\t\t\t\t\tint maxRows = Integer.parseInt(token.getName(sql));\r\n\t\t\t\t\t\tselCmd.setMaxRows(maxRows);\r\n\t\t\t\t\t}catch(NumberFormatException e){\r\n\t\t\t\t\t\tthrow createSyntaxError(token, Language.STXADD_NOT_NUMBER, token.getName(sql));\r\n\t\t\t\t\t}"},"id":149}]},{"percentageOfProject":0.1499000666,"id":150,"children":[{"attributes":{"LOC":9,"path":"/src/smallsql/junit/TestFunctions.java","percentageOfClass":25.0,"percentageOfProject":0.03747501666,"endLine":383,"startLine":374,"file":"TestFunctions.java","clone":"{\r\n        try{\r\n            Connection con = AllTests.getConnection();\r\n            Statement st = con.createStatement();\r\n            st.execute(\"drop table \" + table);\r\n            st.close();\r\n        }catch(Throwable e){\r\n            //e.printStackTrace();\r\n        }\r\n    }"},"id":151},{"attributes":{"LOC":9,"path":"/src/smallsql/junit/TestDataTypes.java","percentageOfClass":25.0,"percentageOfProject":0.03747501666,"endLine":77,"startLine":68,"file":"TestDataTypes.java","clone":"{\r\n        try{\r\n            Connection con = AllTests.getConnection();\r\n            Statement st = con.createStatement();\r\n            st.execute(\"drop table \" + table);\r\n            st.close();\r\n        }catch(Throwable e){\r\n            //e.printStackTrace();\r\n        }\r\n    }"},"id":152},{"attributes":{"LOC":9,"path":"/src/smallsql/junit/TestOperatoren.java","percentageOfClass":25.0,"percentageOfProject":0.03747501666,"endLine":104,"startLine":95,"file":"TestOperatoren.java","clone":"{\r\n        try{\r\n            Connection con = AllTests.getConnection();\r\n            Statement st = con.createStatement();\r\n            st.execute(\"drop table \" + table);\r\n            st.close();\r\n        }catch(Throwable e){\r\n            //e.printStackTrace();\r\n        }\r\n    }"},"id":153},{"attributes":{"LOC":9,"path":"/src/smallsql/junit/TestMoneyRounding.java","percentageOfClass":25.0,"percentageOfProject":0.03747501666,"endLine":62,"startLine":53,"file":"TestMoneyRounding.java","clone":"{\r\n        try{\r\n            Connection con = AllTests.getConnection();\r\n            Statement st = con.createStatement();\r\n            st.execute(\"drop table \" + table);\r\n            st.close();\r\n        }catch(Throwable e){\r\n            //e.printStackTrace();\r\n        }\r\n    }"},"id":154}]},{"percentageOfProject":0.04996668887,"id":155,"children":[{"attributes":{"LOC":6,"path":"/src/smallsql/junit/TestOrderBy.java","percentageOfClass":50.0,"percentageOfProject":0.02498334444,"endLine":192,"startLine":187,"file":"TestOrderBy.java","clone":"while(rs.next()){\r\n\t\t\tString newValue = rs.getString(\"v\");\r\n\t\t\tassertTrue( oldValue.compareTo( newValue ) < 0 );\r\n\t\t\toldValue = newValue;\r\n\t\t\tcount++;\r\n\t\t}"},"id":156},{"attributes":{"LOC":6,"path":"/src/smallsql/junit/TestOrderBy.java","percentageOfClass":50.0,"percentageOfProject":0.02498334444,"endLine":816,"startLine":811,"file":"TestOrderBy.java","clone":"while(rs.next()){\r\n\t\t\tString newValue = rs.getString(\"v\");\r\n\t\t\tassertTrue( oldValue.compareTo( newValue ) < 0 );\r\n\t\t\toldValue = newValue;\r\n\t\t\tcount++;\r\n\t\t}"},"id":157}]},{"percentageOfProject":0.05829447035,"id":158,"children":[{"attributes":{"LOC":7,"path":"/src/smallsql/database/Table.java","percentageOfClass":50.0,"percentageOfProject":0.02914723518,"endLine":376,"startLine":370,"file":"Table.java","clone":"if(serializeConnections.size() > 0){\r\n\t\t\t\t\t\t\tIterator values = locks.values().iterator();\r\n\t\t\t\t\t\t\twhile(values.hasNext()){\r\n\t\t\t\t\t\t\t\tTableStorePage lock = (TableStorePage)values.next();\r\n\t\t\t\t\t\t\t\tif(lock.con != con) return null;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}"},"id":159},{"attributes":{"LOC":7,"path":"/src/smallsql/database/Table.java","percentageOfClass":50.0,"percentageOfProject":0.02914723518,"endLine":394,"startLine":388,"file":"Table.java","clone":"if(serializeConnections.size() > 0){\r\n                        Iterator values = locks.values().iterator();\r\n                        while(values.hasNext()){\r\n                            TableStorePage lock = (TableStorePage)values.next();\r\n                            if(lock.con != con) return null;\r\n                        }\r\n                    }"},"id":160}]}]},"relations":[{"target":160,"source":159},{"target":143,"source":142},{"target":152,"source":151},{"target":153,"source":151},{"target":154,"source":151},{"target":153,"source":152},{"target":154,"source":152},{"target":154,"source":153},{"target":110,"source":19},{"target":157,"source":156},{"target":149,"source":148},{"target":122,"source":121},{"target":119,"source":118},{"target":146,"source":145},{"target":128,"source":127},{"target":113,"source":112},{"target":134,"source":133},{"target":131,"source":130},{"target":116,"source":115},{"target":13,"source":12},{"target":16,"source":15},{"target":17,"source":15},{"target":17,"source":16},{"target":137,"source":136},{"target":125,"source":124},{"target":140,"source":139}],"duplicatesLOC":256,"totalLOC":24016,"cloneClasses":[{"percentageOfProject":0.04996668887,"id":11,"children":[{"attributes":{"LOC":6,"path":"/src/smallsql/database/Utils.java","percentageOfClass":50.0,"percentageOfProject":0.02498334444,"endLine":322,"startLine":317,"file":"Utils.java","clone":"{\r\n        try{\r\n            return Double.parseDouble( val ) != 0;\r\n        }catch(NumberFormatException e){/*ignore it if it not a number*/}\r\n        return \"true\".equalsIgnoreCase( val ) || \"yes\".equalsIgnoreCase( val ) || \"t\".equalsIgnoreCase( val );\r\n    }"},"id":12},{"attributes":{"LOC":6,"path":"/src/smallsql/junit/BasicTestCase.java","percentageOfClass":50.0,"percentageOfProject":0.02498334444,"endLine":196,"startLine":191,"file":"BasicTestCase.java","clone":"{\r\n        try{\r\n            return Double.parseDouble( val ) != 0;\r\n        }catch(NumberFormatException e){/*ignore it if it not a number*/}\r\n        return \"true\".equalsIgnoreCase( val ) || \"yes\".equalsIgnoreCase( val ) || \"t\".equalsIgnoreCase( val );\r\n    }"},"id":13}]},{"percentageOfProject":0.04996668887,"id":14,"children":[{"attributes":{"LOC":4,"path":"/src/smallsql/junit/TestThreads.java","percentageOfClass":33.33333333,"percentageOfProject":0.01665556296,"endLine":110,"startLine":106,"file":"TestThreads.java","clone":"// wait until all threads are finish\r\n            for(int i = 0; i < threadList.size(); i++){\r\n                Thread thread = (Thread)threadList.get(i);\r\n                thread.join(5000);\r\n            }"},"id":15},{"attributes":{"LOC":4,"path":"/src/smallsql/junit/TestThreads.java","percentageOfClass":33.33333333,"percentageOfProject":0.01665556296,"endLine":63,"startLine":59,"file":"TestThreads.java","clone":"// wait until all threads are finish\r\n        for(int i = 0; i < threadList.size(); i++){\r\n            Thread thread = (Thread)threadList.get(i);\r\n            thread.join(5000);\r\n        }"},"id":16},{"attributes":{"LOC":4,"path":"/src/smallsql/junit/TestThreads.java","percentageOfClass":33.33333333,"percentageOfProject":0.01665556296,"endLine":164,"startLine":160,"file":"TestThreads.java","clone":"// wait until all threads are finish\r\n            for(int i = 0; i < threadList.size(); i++){\r\n                Thread thread = (Thread)threadList.get(i);\r\n                thread.join(5000);\r\n            }"},"id":17}]},{"percentageOfProject":0.0416389074,"id":18,"children":[{"attributes":{"LOC":5,"path":"/src/smallsql/database/ExpressionFunctionConvert.java","percentageOfClass":50.0,"percentageOfProject":0.0208194537,"endLine":157,"startLine":153,"file":"ExpressionFunctionConvert.java","clone":"{\r\n\t\t\t\t\tbyte[] buffer = new byte[length];\r\n\t\t\t\t\tSystem.arraycopy(bytes, 0, buffer, 0, Math.min(bytes.length,length) );\r\n\t\t\t\t\treturn buffer;\r\n\t\t\t\t}"},"id":19},{"attributes":{"LOC":5,"path":"/src/smallsql/database/ExpressionFunctionConvert.java","percentageOfClass":50.0,"percentageOfProject":0.0208194537,"endLine":146,"startLine":142,"file":"ExpressionFunctionConvert.java","clone":"{\r\n\t\t\t\t\tbyte[] buffer = new byte[length];\r\n\t\t\t\t\tSystem.arraycopy(bytes, 0, buffer, 0, Math.min(bytes.length,length) );\r\n\t\t\t\t\treturn buffer;\r\n\t\t\t\t}"},"id":110}]},{"percentageOfProject":0.0416389074,"id":111,"children":[{"attributes":{"LOC":5,"path":"/src/smallsql/junit/TestOrderBy.java","percentageOfClass":50.0,"percentageOfProject":0.0208194537,"endLine":435,"startLine":431,"file":"TestOrderBy.java","clone":"while(rs.next()){\r\n\t\t\tassertTrue( oldValue.compareTo( (Integer)rs.getObject(\"i\") ) < 0 );\r\n\t\t\toldValue = (Integer)rs.getObject(\"i\");\r\n\t\t\tcount++;\r\n\t\t}"},"id":112},{"attributes":{"LOC":5,"path":"/src/smallsql/junit/TestOrderBy.java","percentageOfClass":50.0,"percentageOfProject":0.0208194537,"endLine":350,"startLine":346,"file":"TestOrderBy.java","clone":"while(rs.next()){\r\n\t\t\tassertTrue( oldValue.compareTo( (Integer)rs.getObject(\"i\") ) < 0 );\r\n\t\t\toldValue = (Integer)rs.getObject(\"i\");\r\n\t\t\tcount++;\r\n\t\t}"},"id":113}]},{"percentageOfProject":0.09160559627,"id":114,"children":[{"attributes":{"LOC":11,"path":"/src/smallsql/database/IndexScrollStatus.java","percentageOfClass":50.0,"percentageOfProject":0.04580279813,"endLine":131,"startLine":120,"file":"IndexScrollStatus.java","clone":"if(status.nodeValue != null){\r\n\t\t\t\t\t\tif(status.nodeValue instanceof IndexNode){\r\n\t\t\t\t\t\t\tlevel++;\r\n\t\t\t\t\t\t\tnodeStack.push(\r\n\t\t\t\t\t\t\t\tnew IndexNodeScrollStatus( \t(IndexNode)status.nodeValue, \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(expressions.get(level).getAlias() != SQLTokenizer.DESC_STR), \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tscroll, level));\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}else\r\n\t\t\t\t\t\t\treturn getReturnValue(status.nodeValue);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//There is no RowOffset in this node"},"id":115},{"attributes":{"LOC":11,"path":"/src/smallsql/database/IndexScrollStatus.java","percentageOfClass":50.0,"percentageOfProject":0.04580279813,"endLine":99,"startLine":89,"file":"IndexScrollStatus.java","clone":"if(status.nodeValue != null){\r\n\t\t\t\t\t\tif(status.nodeValue instanceof IndexNode){\r\n\t\t\t\t\t\t\tlevel++;\r\n\t\t\t\t\t\t\tnodeStack.push(\r\n\t\t\t\t\t\t\t\tnew IndexNodeScrollStatus( \t(IndexNode)status.nodeValue, \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(expressions.get(level).getAlias() != SQLTokenizer.DESC_STR), \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tscroll, level));\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}else\r\n\t\t\t\t\t\t\treturn getReturnValue(status.nodeValue);\r\n\t\t\t\t\t}"},"id":116}]},{"percentageOfProject":0.09160559627,"id":117,"children":[{"attributes":{"LOC":11,"path":"/src/smallsql/database/ExpressionFunctionTruncate.java","percentageOfClass":50.0,"percentageOfProject":0.04580279813,"endLine":60,"startLine":50,"file":"ExpressionFunctionTruncate.java","clone":"if(places > 0){\r\n\t\t\tfor(int i=0; i<places; i++){\r\n\t\t\t\tfactor *= 10;\r\n\t\t\t}\r\n\t\t\tvalue *= factor;\r\n\t\t}else{\r\n\t\t\tfor(int i=0; i>places; i--){\r\n\t\t\t\tfactor *= 10;\r\n\t\t\t}\r\n\t\t\tvalue /= factor;\r\n\t\t}"},"id":118},{"attributes":{"LOC":11,"path":"/src/smallsql/database/ExpressionFunctionRound.java","percentageOfClass":50.0,"percentageOfProject":0.04580279813,"endLine":60,"startLine":50,"file":"ExpressionFunctionRound.java","clone":"if(places > 0){\r\n\t\t\tfor(int i=0; i<places; i++){\r\n\t\t\t\tfactor *= 10;\r\n\t\t\t}\r\n\t\t\tvalue *= factor;\r\n\t\t}else{\r\n\t\t\tfor(int i=0; i>places; i--){\r\n\t\t\t\tfactor *= 10;\r\n\t\t\t}\r\n\t\t\tvalue /= factor;\r\n\t\t}"},"id":119}]},{"percentageOfProject":0.008327781479,"id":120,"children":[{"attributes":{"LOC":1,"path":"/src/smallsql/database/SSDatabaseMetaData.java","percentageOfClass":50.0,"percentageOfProject":0.00416389074,"endLine":753,"startLine":753,"file":"SSDatabaseMetaData.java","clone":"String[] colNames = {\"TABLE_CAT\", \"TABLE_SCHEM\", \"TABLE_NAME\", \"COLUMN_NAME\", \"DATA_TYPE\", \"TYPE_NAME\", \"COLUMN_SIZE\", \"BUFFER_LENGTH\", \"DECIMAL_DIGITS\", \"NUM_PREC_RADIX\", \"NULLABLE\", \"REMARKS\", \"COLUMN_DEF\", \"SQL_DATA_TYPE\", \"SQL_DATETIME_SUB\", \"CHAR_OCTET_LENGTH\", \"ORDINAL_POSITION\", \"IS_NULLABLE\"};"},"id":121},{"attributes":{"LOC":1,"path":"/src/smallsql/junit/TestDBMetaData.java","percentageOfClass":50.0,"percentageOfProject":0.00416389074,"endLine":182,"startLine":182,"file":"TestDBMetaData.java","clone":"String[] colNames = {\"TABLE_CAT\", \"TABLE_SCHEM\", \"TABLE_NAME\", \"COLUMN_NAME\", \"DATA_TYPE\", \"TYPE_NAME\", \"COLUMN_SIZE\", \"BUFFER_LENGTH\", \"DECIMAL_DIGITS\", \"NUM_PREC_RADIX\", \"NULLABLE\", \"REMARKS\", \"COLUMN_DEF\", \"SQL_DATA_TYPE\", \"SQL_DATETIME_SUB\", \"CHAR_OCTET_LENGTH\", \"ORDINAL_POSITION\", \"IS_NULLABLE\"};"},"id":122}]},{"percentageOfProject":0.02498334444,"id":123,"children":[{"attributes":{"LOC":3,"path":"/src/smallsql/junit/BenchTest.java","percentageOfClass":50.0,"percentageOfProject":0.01249167222,"endLine":123,"startLine":121,"file":"BenchTest.java","clone":"if (count != rowCount)\r\n                System.out.println( \"  Failed: Only \" + count + \" rows were inserted.\");\r\n            else System.out.println( \"  Test time: \" + time + \" ms\");"},"id":124},{"attributes":{"LOC":3,"path":"/src/smallsql/junit/BenchTest.java","percentageOfClass":50.0,"percentageOfProject":0.01249167222,"endLine":182,"startLine":180,"file":"BenchTest.java","clone":"if (count != rowCount)\r\n                 System.out.println( \"  Failed: Only \" + count + \" rows were inserted.\");\r\n            else System.out.println( \"  Test time: \" + time + \" ms\");"},"id":125}]},{"percentageOfProject":0.01665556296,"id":126,"children":[{"attributes":{"LOC":2,"path":"/src/smallsql/database/Index.java","percentageOfClass":50.0,"percentageOfProject":0.008327781479,"endLine":409,"startLine":407,"file":"Index.java","clone":"// the first digit include 0-null; 1-empty; 2 another value\r\n\t\t\tchar digit = (i<0) ? (length == 0 ? (char)1 : 2)\r\n\t\t\t\t\t\t\t  : (key[i]);"},"id":127},{"attributes":{"LOC":2,"path":"/src/smallsql/database/Index.java","percentageOfClass":50.0,"percentageOfProject":0.008327781479,"endLine":384,"startLine":382,"file":"Index.java","clone":"// the first digit include 0-null; 1-empty; 2 another value\r\n\t\t\tchar digit = (i<0) ? (length == 0 ? (char)1 : 2)\r\n\t\t\t\t\t\t\t  : (key[i]);"},"id":128}]},{"percentageOfProject":0.06662225183,"id":129,"children":[{"attributes":{"LOC":8,"path":"/src/smallsql/junit/TestOrderBy.java","percentageOfClass":50.0,"percentageOfProject":0.03331112592,"endLine":218,"startLine":211,"file":"TestOrderBy.java","clone":"while(oldValue != null && rs.next()){\r\n\t\t\tString newValue = rs.getString(\"v\");\r\n\t\t\tif(newValue != null){\r\n\t\t\t\tassertTrue( oldValue.compareTo( newValue ) > 0 );\r\n\t\t\t\tcount++;\r\n\t\t\t}\r\n\t\t\toldValue = newValue;\r\n\t\t}"},"id":130},{"attributes":{"LOC":8,"path":"/src/smallsql/junit/TestOrderBy.java","percentageOfClass":50.0,"percentageOfProject":0.03331112592,"endLine":246,"startLine":239,"file":"TestOrderBy.java","clone":"while(oldValue != null && rs.next()){\r\n\t\t\tString newValue = rs.getString(\"v\");\r\n\t\t\tif(newValue != null){\r\n\t\t\t\tassertTrue( oldValue.compareTo( newValue ) > 0 );\r\n\t\t\t\tcount++;\r\n\t\t\t}\r\n\t\t\toldValue = newValue;\r\n\t\t}"},"id":131}]},{"percentageOfProject":0.07495003331,"id":132,"children":[{"attributes":{"LOC":9,"path":"/src/smallsql/database/TableView.java","percentageOfClass":50.0,"percentageOfProject":0.03747501666,"endLine":113,"startLine":105,"file":"TableView.java","clone":"catch(Throwable e){\r\n\t\t\tif(raFile != null)\r\n\t\t\t\ttry{\r\n\t\t\t\t\traFile.close();\r\n\t\t\t\t}catch(Exception e2){\r\n\t\t\t\t\tDriverManager.println(e2.toString());\r\n\t\t\t\t}\r\n\t\t\tthrow SmallSQLException.createFromException(e);\r\n\t\t}"},"id":133},{"attributes":{"LOC":9,"path":"/src/smallsql/database/IndexDescription.java","percentageOfClass":50.0,"percentageOfProject":0.03747501666,"endLine":194,"startLine":186,"file":"IndexDescription.java","clone":"catch(Throwable e){\r\n            if(raFile != null)\r\n                try{\r\n                    raFile.close();\r\n                }catch(Exception e2){\r\n                    DriverManager.println(e2.toString());\r\n                }\r\n            throw SmallSQLException.createFromException(e);\r\n        }"},"id":134}]},{"percentageOfProject":0.07495003331,"id":135,"children":[{"attributes":{"LOC":9,"path":"/src/smallsql/database/SSCallableStatement.java","percentageOfClass":50.0,"percentageOfProject":0.03747501666,"endLine":125,"startLine":117,"file":"SSCallableStatement.java","clone":"{\r\n        try{\r\n            Expression expr = getValue(i);\r\n            wasNull = expr.isNull();\r\n            return expr.getLong();\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }"},"id":136},{"attributes":{"LOC":9,"path":"/src/smallsql/database/SSCallableStatement.java","percentageOfClass":50.0,"percentageOfProject":0.03747501666,"endLine":143,"startLine":135,"file":"SSCallableStatement.java","clone":"{\r\n        try{\r\n            Expression expr = getValue(i);\r\n            wasNull = expr.isNull();\r\n            return expr.getLong();\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }"},"id":137}]},{"percentageOfProject":0.008327781479,"id":138,"children":[{"attributes":{"LOC":1,"path":"/src/smallsql/database/SSDatabaseMetaData.java","percentageOfClass":50.0,"percentageOfProject":0.00416389074,"endLine":831,"startLine":831,"file":"SSDatabaseMetaData.java","clone":"String[] colNames = {\t\t\"TYPE_NAME\", \t\t\t\t\"DATA_TYPE\", \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"PRECISION\", \t\"LITERAL_PREFIX\", \"LITERAL_SUFFIX\", \t\t\"CREATE_PARAMS\", \"NULLABLE\", \t \"CASE_SENSITIVE\", \"SEARCHABLE\", \"UNSIGNED_ATTRIBUTE\", \"FIXED_PREC_SCALE\", \"AUTO_INCREMENT\", \"LOCAL_TYPE_NAME\", \"MINIMUM_SCALE\", \"MAXIMUM_SCALE\", \"SQL_DATA_TYPE\", \"SQL_DATETIME_SUB\", \"NUM_PREC_RADIX\"};"},"id":139},{"attributes":{"LOC":1,"path":"/src/smallsql/junit/TestDBMetaData.java","percentageOfClass":50.0,"percentageOfProject":0.00416389074,"endLine":210,"startLine":210,"file":"TestDBMetaData.java","clone":"String[] colNames = {\"TYPE_NAME\", \"DATA_TYPE\", \"PRECISION\", \"LITERAL_PREFIX\", \"LITERAL_SUFFIX\", \"CREATE_PARAMS\", \"NULLABLE\", \"CASE_SENSITIVE\", \"SEARCHABLE\", \"UNSIGNED_ATTRIBUTE\", \"FIXED_PREC_SCALE\", \"AUTO_INCREMENT\", \"LOCAL_TYPE_NAME\", \"MINIMUM_SCALE\", \"MAXIMUM_SCALE\", \"SQL_DATA_TYPE\", \"SQL_DATETIME_SUB\", \"NUM_PREC_RADIX\"};"},"id":140}]},{"percentageOfProject":0.06662225183,"id":141,"children":[{"attributes":{"LOC":8,"path":"/src/smallsql/junit/BasicTestCase.java","percentageOfClass":50.0,"percentageOfProject":0.03331112592,"endLine":109,"startLine":102,"file":"BasicTestCase.java","clone":"{\r\n\t\tStringBuffer buf = new StringBuffer(bytes.length << 1);\r\n\t\tfor(int i=0; i<bytes.length; i++){\r\n\t\t\tbuf.append( digits[ (bytes[i] >> 4) & 0x0F ] );\r\n\t\t\tbuf.append( digits[ (bytes[i]     ) & 0x0F ] );\r\n\t\t}\r\n\t\treturn buf.toString();\r\n\t}"},"id":142},{"attributes":{"LOC":8,"path":"/src/smallsql/database/Utils.java","percentageOfClass":50.0,"percentageOfProject":0.03331112592,"endLine":212,"startLine":205,"file":"Utils.java","clone":"{\r\n        StringBuffer buf = new StringBuffer(bytes.length << 1);\r\n        for(int i=0; i<bytes.length; i++){\r\n            buf.append( digits[ (bytes[i] >> 4) & 0x0F ] );\r\n            buf.append( digits[ (bytes[i]     ) & 0x0F ] );\r\n        }\r\n        return buf.toString();\r\n    }"},"id":143}]},{"percentageOfProject":0.04996668887,"id":144,"children":[{"attributes":{"LOC":6,"path":"/src/smallsql/junit/BenchTest.java","percentageOfClass":50.0,"percentageOfProject":0.02498334444,"endLine":328,"startLine":322,"file":"BenchTest.java","clone":"// There are not the correct count of rows.\r\n                if (count == 0){\r\n                    createTestDataWithClassicInsert( con );\r\n                    rs = st1.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n                    rs.next();\r\n                    count = rs.getInt(1);\r\n                }"},"id":145},{"attributes":{"LOC":6,"path":"/src/smallsql/junit/BenchTest.java","percentageOfClass":50.0,"percentageOfProject":0.02498334444,"endLine":214,"startLine":208,"file":"BenchTest.java","clone":"// There are not the correct count of rows.\r\n                if (count == 0){\r\n                    createTestDataWithClassicInsert( con );\r\n                    rs = st1.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n                    rs.next();\r\n                    count = rs.getInt(1);\r\n                }"},"id":146}]},{"percentageOfProject":0.04996668887,"id":147,"children":[{"attributes":{"LOC":6,"path":"/src/smallsql/database/SQLParser.java","percentageOfClass":50.0,"percentageOfProject":0.02498334444,"endLine":1937,"startLine":1932,"file":"SQLParser.java","clone":"try{\r\n            int maxRows = Integer.parseInt(token.getName(sql));\r\n            selCmd.setMaxRows(maxRows);\r\n        }catch(NumberFormatException e){\r\n            throw createSyntaxError(token, Language.STXADD_NOT_NUMBER, token.getName(sql));\r\n        }"},"id":148},{"attributes":{"LOC":6,"path":"/src/smallsql/database/SQLParser.java","percentageOfClass":50.0,"percentageOfProject":0.02498334444,"endLine":357,"startLine":352,"file":"SQLParser.java","clone":"try{\r\n\t\t\t\t\t\tint maxRows = Integer.parseInt(token.getName(sql));\r\n\t\t\t\t\t\tselCmd.setMaxRows(maxRows);\r\n\t\t\t\t\t}catch(NumberFormatException e){\r\n\t\t\t\t\t\tthrow createSyntaxError(token, Language.STXADD_NOT_NUMBER, token.getName(sql));\r\n\t\t\t\t\t}"},"id":149}]},{"percentageOfProject":0.1499000666,"id":150,"children":[{"attributes":{"LOC":9,"path":"/src/smallsql/junit/TestFunctions.java","percentageOfClass":25.0,"percentageOfProject":0.03747501666,"endLine":383,"startLine":374,"file":"TestFunctions.java","clone":"{\r\n        try{\r\n            Connection con = AllTests.getConnection();\r\n            Statement st = con.createStatement();\r\n            st.execute(\"drop table \" + table);\r\n            st.close();\r\n        }catch(Throwable e){\r\n            //e.printStackTrace();\r\n        }\r\n    }"},"id":151},{"attributes":{"LOC":9,"path":"/src/smallsql/junit/TestDataTypes.java","percentageOfClass":25.0,"percentageOfProject":0.03747501666,"endLine":77,"startLine":68,"file":"TestDataTypes.java","clone":"{\r\n        try{\r\n            Connection con = AllTests.getConnection();\r\n            Statement st = con.createStatement();\r\n            st.execute(\"drop table \" + table);\r\n            st.close();\r\n        }catch(Throwable e){\r\n            //e.printStackTrace();\r\n        }\r\n    }"},"id":152},{"attributes":{"LOC":9,"path":"/src/smallsql/junit/TestOperatoren.java","percentageOfClass":25.0,"percentageOfProject":0.03747501666,"endLine":104,"startLine":95,"file":"TestOperatoren.java","clone":"{\r\n        try{\r\n            Connection con = AllTests.getConnection();\r\n            Statement st = con.createStatement();\r\n            st.execute(\"drop table \" + table);\r\n            st.close();\r\n        }catch(Throwable e){\r\n            //e.printStackTrace();\r\n        }\r\n    }"},"id":153},{"attributes":{"LOC":9,"path":"/src/smallsql/junit/TestMoneyRounding.java","percentageOfClass":25.0,"percentageOfProject":0.03747501666,"endLine":62,"startLine":53,"file":"TestMoneyRounding.java","clone":"{\r\n        try{\r\n            Connection con = AllTests.getConnection();\r\n            Statement st = con.createStatement();\r\n            st.execute(\"drop table \" + table);\r\n            st.close();\r\n        }catch(Throwable e){\r\n            //e.printStackTrace();\r\n        }\r\n    }"},"id":154}]},{"percentageOfProject":0.04996668887,"id":155,"children":[{"attributes":{"LOC":6,"path":"/src/smallsql/junit/TestOrderBy.java","percentageOfClass":50.0,"percentageOfProject":0.02498334444,"endLine":192,"startLine":187,"file":"TestOrderBy.java","clone":"while(rs.next()){\r\n\t\t\tString newValue = rs.getString(\"v\");\r\n\t\t\tassertTrue( oldValue.compareTo( newValue ) < 0 );\r\n\t\t\toldValue = newValue;\r\n\t\t\tcount++;\r\n\t\t}"},"id":156},{"attributes":{"LOC":6,"path":"/src/smallsql/junit/TestOrderBy.java","percentageOfClass":50.0,"percentageOfProject":0.02498334444,"endLine":816,"startLine":811,"file":"TestOrderBy.java","clone":"while(rs.next()){\r\n\t\t\tString newValue = rs.getString(\"v\");\r\n\t\t\tassertTrue( oldValue.compareTo( newValue ) < 0 );\r\n\t\t\toldValue = newValue;\r\n\t\t\tcount++;\r\n\t\t}"},"id":157}]},{"percentageOfProject":0.05829447035,"id":158,"children":[{"attributes":{"LOC":7,"path":"/src/smallsql/database/Table.java","percentageOfClass":50.0,"percentageOfProject":0.02914723518,"endLine":376,"startLine":370,"file":"Table.java","clone":"if(serializeConnections.size() > 0){\r\n\t\t\t\t\t\t\tIterator values = locks.values().iterator();\r\n\t\t\t\t\t\t\twhile(values.hasNext()){\r\n\t\t\t\t\t\t\t\tTableStorePage lock = (TableStorePage)values.next();\r\n\t\t\t\t\t\t\t\tif(lock.con != con) return null;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}"},"id":159},{"attributes":{"LOC":7,"path":"/src/smallsql/database/Table.java","percentageOfClass":50.0,"percentageOfProject":0.02914723518,"endLine":394,"startLine":388,"file":"Table.java","clone":"if(serializeConnections.size() > 0){\r\n                        Iterator values = locks.values().iterator();\r\n                        while(values.hasNext()){\r\n                            TableStorePage lock = (TableStorePage)values.next();\r\n                            if(lock.con != con) return null;\r\n                        }\r\n                    }"},"id":160}]}],"fullSources":[{"path":"/src/smallsql/junit/BenchTest.java","source":"/* =============================================================\r\n * SmallSQL : a free Java DBMS library for the Java(tm) platform\r\n * =============================================================\r\n *\r\n * (C) Copyright 2004-2006, by Volker Berlin.\r\n *\r\n * Project Info:  http://www.smallsql.de/\r\n *\r\n * This library is free software; you can redistribute it and/or modify it \r\n * under the terms of the GNU Lesser General Public License as published by \r\n * the Free Software Foundation; either version 2.1 of the License, or \r\n * (at your option) any later version.\r\n *\r\n * This library is distributed in the hope that it will be useful, but \r\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \r\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public \r\n * License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, \r\n * USA.  \r\n *\r\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc. \r\n * in the United States and other countries.]\r\n *\r\n * ---------------\r\n * BenchTest.java\r\n * ---------------\r\n * Author: Volker Berlin\r\n * \r\n */\r\npackage smallsql.junit;\r\n\r\nimport java.sql.*;\r\n\r\npublic class BenchTest\r\n{\r\n    static byte[] byteArray = {23, 34, 67 };\r\n    static byte[] largeByteArray = new byte[4000];\r\n    \r\n    static String driverClassName = \"smallsql.database.SSDriver\";\r\n    static String userName        = \"sa\";\r\n    static String password        = \"\";\r\n    static String jdbcUrl         = \"jdbc:smallsql:AllTests\";\r\n    static int    rowCount        = 10000;\r\n    \r\n    static Connection con;\r\n    static final String tableName = \"BenchTest2\";\r\n        \r\n    \r\n    public static void main(String[] args) throws SQLException{\r\n        for(int i=0; i<args.length;){\r\n            String option = args[i++];\r\n            if      (option.equals(\"-driver\")  ) driverClassName = args[i++];\r\n            else if (option.equals(\"-user\")    ) userName = args[i++];\r\n            else if (option.equals(\"-password\")) password = args[i++];\r\n            else if (option.equals(\"-url\")     ) jdbcUrl  = args[i++];\r\n            else if (option.equals(\"-rowcount\")) rowCount = Integer.parseInt(args[i++]);\r\n            else if (option.equals(\"-?\") | option.equals(\"-help\")){\r\n                System.out.println( \"Valid options are :\\n\\t-driver\\n\\t-url\\n\\t-user\\n\\t-password\\n\\t-rowcount\");\r\n                System.exit(0);\r\n            }\r\n            else {System.out.println(\"Option \" + option + \" is ignored\");i++;}\r\n        }\r\n        System.out.println( \"Driver:  \\t\" + driverClassName);\r\n        System.out.println( \"Username:\\t\" + userName);\r\n        System.out.println( \"Password:\\t\" + password);\r\n        System.out.println( \"JDBC URL:\\t\" + jdbcUrl);\r\n        System.out.println( \"Row Count:\\t\" + rowCount);\r\n        System.out.println();\r\n        try{\r\n            Class.forName(driverClassName).newInstance();\r\n            con = DriverManager.getConnection( jdbcUrl, userName,password);\r\n            System.out.println( con.getMetaData().getDriverName() + \" \" + con.getMetaData().getDriverVersion());\r\n            System.out.println();\r\n            createTestTable( con );\r\n            test_InsertClassic( con );\r\n            test_DeleteAll( con );\r\n            test_InsertEmptyRows( con );\r\n            test_DeleteRows( con );\r\n            test_InsertRows( con );\r\n            test_RowRequestPages( con );\r\n            test_UpdateRows( con );\r\n            test_UpdateRowsPrepare( con );\r\n            test_UpdateRowsPrepareSP( con );\r\n            test_UpdateRowsPrepareBatch( con );\r\n            test_Scroll_getXXX( con );\r\n            test_UpdateLargeBinary( con );\r\n            test_UpdateLargeBinaryWithSP( con );\r\n        }catch(Exception e){\r\n            e.printStackTrace();\r\n        }finally{\r\n            if (con != null){\r\n                //dropTestTable( con );\r\n                con.close();\r\n            }\r\n        }\r\n    }\r\n    \r\n    \r\n    \r\n    /**\r\n      *  1. Test\r\n      *  Insert rows with default values with a classic insert statement.\r\n      */  \r\n    static void test_InsertClassic(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test insert rows with default values with a classic insert statement: \" + rowCount + \" rows\");\r\n        \r\n        try{\r\n            Statement st = con.createStatement( ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE );\r\n            long time = -System.currentTimeMillis();\r\n            for (int i=0; i<rowCount; i++){\r\n                st.execute(\"INSERT INTO \" + tableName + \"(i) VALUES(\" + i +\")\");\r\n            }\r\n            time += System.currentTimeMillis();\r\n            ResultSet rs = st.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n            rs.next();\r\n            int count = rs.getInt(1);\r\n            if (count != rowCount)\r\n                System.out.println( \"  Failed: Only \" + count + \" rows were inserted.\");\r\n            else System.out.println( \"  Test time: \" + time + \" ms\");\r\n            st.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }\r\n    \r\n    \r\n    \r\n    /**\r\n      *  2. Test\r\n      *  Delete all rows with a single statement.\r\n      */  \r\n    static void test_DeleteAll(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test delete all rows: \" + rowCount + \" rows\");\r\n        \r\n        try{\r\n            long time = -System.currentTimeMillis();\r\n            Statement st = con.createStatement();\r\n            st.execute(\"DELETE FROM \" + tableName);\r\n            time += System.currentTimeMillis();\r\n            System.out.println( \"  Test time: \" + time + \" ms\");\r\n            st.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }\r\n    \r\n    \r\n    \r\n    /**\r\n      *  3. Test\r\n      *  Insert only empty rows with the default values of the row with the method insertRow().\r\n      */  \r\n    static void test_InsertEmptyRows(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test insert empty rows with insertRow(): \" + rowCount + \" rows\");\r\n        \r\n        try{\r\n            Statement st = con.createStatement( ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE );\r\n            ResultSet rs = st.executeQuery(\"SELECT * FROM \"+tableName);\r\n            long time = -System.currentTimeMillis();\r\n            for (int i=0; i<rowCount; i++){\r\n                rs.moveToInsertRow();\r\n                rs.insertRow();\r\n            }\r\n            time += System.currentTimeMillis();\r\n            rs = st.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n            rs.next();\r\n            int count = rs.getInt(1);\r\n            if (count != rowCount)\r\n                 System.out.println( \"  Failed: Only \" + count + \" rows were inserted.\");\r\n            else System.out.println( \"  Test time: \" + time + \" ms\");\r\n            st.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }\r\n    \r\n    \r\n    \r\n    /**\r\n      *  4. Test\r\n      *  Delete rows with the method deleteRow().\r\n      */  \r\n    static void test_DeleteRows(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test delete rows with deleteRow(): \" + rowCount + \" rows\");\r\n        \r\n        try{\r\n            Statement st1 = con.createStatement();\r\n            ResultSet rs = st1.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n            rs.next();\r\n            int count = rs.getInt(1);\r\n            if (count != rowCount){\r\n                // There are not the correct count of rows.\r\n                if (count == 0){\r\n                    createTestDataWithClassicInsert( con );\r\n                    rs = st1.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n                    rs.next();\r\n                    count = rs.getInt(1);\r\n                }\r\n                if (count != rowCount){\r\n                    System.out.println( \"  Failed: Only \" + (rowCount-count) + \" rows were deleted.\");\r\n                    return;\r\n                }\r\n            }\r\n            st1.close();\r\n            \r\n            Statement st = con.createStatement( ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE );\r\n            rs = st.executeQuery(\"SELECT * FROM \"+tableName);\r\n            long time = -System.currentTimeMillis();\r\n            for (int i=0; i<rowCount; i++){\r\n                rs.next();\r\n                rs.deleteRow();\r\n            }\r\n            time += System.currentTimeMillis();\r\n            rs = st.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n            rs.next();\r\n            count = rs.getInt(1);\r\n            if (count != 0)\r\n                 System.out.println( \"  Failed: Only \" + (rowCount-count) + \" rows were deleted.\");\r\n            else System.out.println( \"  Test time: \" + time + \" ms\");\r\n            st.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }\r\n    \r\n    \r\n    \r\n    /**\r\n      *  5. Test\r\n      *  Insert rows with the method insertRow().\r\n      */  \r\n    static void test_InsertRows(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test insert rows with insertRow(): \" + rowCount + \" rows\");\r\n        \r\n        try{\r\n            Statement st = con.createStatement( ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE );\r\n            ResultSet rs = st.executeQuery(\"SELECT * FROM \" + tableName);\r\n            long time = -System.currentTimeMillis();\r\n            for (int i=0; i<rowCount; i++){\r\n                rs.moveToInsertRow();\r\n\t            rs.updateBytes (  \"bi\", byteArray );\r\n\t            rs.updateString(  \"c\" , \"Test\" );\r\n\t            rs.updateDate  (  \"d\" , new Date( System.currentTimeMillis() ) );\r\n\t            rs.updateFloat (  \"de\", (float)1234.56789 );\r\n\t            rs.updateFloat (  \"f\" , (float)9876.54321 );\r\n\t            rs.updateBytes (  \"im\", largeByteArray );\r\n\t            rs.updateInt   (  \"i\" , i );\r\n\t            rs.updateDouble(  \"m\" , 23.45 );\r\n\t            rs.updateDouble(  \"n\" , 567.45 );\r\n\t            rs.updateFloat (  \"r\" , (float)78.89 );\r\n\t            rs.updateTime  (  \"sd\", new Time( System.currentTimeMillis() ) );\r\n\t            rs.updateShort (  \"si\", (short)i );\r\n\t            rs.updateFloat (  \"sm\", (float)34.56 );\r\n\t            rs.updateString(  \"sy\", \"sysname (30) NULL\" );\r\n\t            rs.updateString(  \"t\" , \"ntext NULL, sample to save in the field\" );\r\n\t            rs.updateByte  (  \"ti\", (byte)i );\r\n\t            rs.updateBytes (  \"vb\", byteArray );\r\n\t            rs.updateString(  \"vc\", \"nvarchar (255) NULL\" );\r\n                rs.insertRow();\r\n            }\r\n            time += System.currentTimeMillis();\r\n            rs = st.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n            rs.next();\r\n            int count = rs.getInt(1);\r\n            if (count != rowCount){\r\n                  st.execute(\"DELETE FROM \" + tableName);\r\n                  System.out.println( \"  Failed: Only \" + count + \" rows were inserted.\");\r\n            }else System.out.println( \"  Test time: \" + time + \" ms\");\r\n            st.close();\r\n        }catch(Exception e){\r\n        \te.printStackTrace();\r\n            try{\r\n                // reset for the next test\r\n                Statement st = con.createStatement();\r\n                st.execute(\"DELETE FROM \" + tableName);\r\n                st.close();\r\n            }catch(Exception ee){/* ignore it */}\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }\r\n    \r\n    \r\n    \r\n    /**\r\n      *  6. Test\r\n      *  Request one page of rows from a large ResultSet.\r\n      */  \r\n    static void test_RowRequestPages(Connection con){\r\n        int pages = 100; \r\n        int rows  = rowCount / pages;\r\n        System.out.println();\r\n        System.out.println( \"Test request row pages : \" + pages + \" pages, \" +rows + \" rows per page\");\r\n        try{\r\n            Statement st1 = con.createStatement();\r\n            ResultSet rs = st1.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n            rs.next();\r\n            int count = rs.getInt(1);\r\n            if (count != rowCount){\r\n                // There are not the correct count of rows.\r\n                if (count == 0){\r\n                    createTestDataWithClassicInsert( con );\r\n                    rs = st1.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n                    rs.next();\r\n                    count = rs.getInt(1);\r\n                }\r\n                if (count != rowCount){\r\n                    System.out.println( \"  Failed: Only \" + (rowCount-count) + \" rows were found.\");\r\n                    return;\r\n                }\r\n            }\r\n            st1.close();\r\n            \r\n            long time = -System.currentTimeMillis();\r\n            Statement st = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_READ_ONLY);\r\n            st.setFetchSize( rows );\r\n            for (int i=0; i<pages; i++){\r\n                rs = st.executeQuery(\"SELECT * FROM \" + tableName);\r\n                rs.absolute( i*rows+1 );\r\n                for (int r=1; r<rows; r++){\r\n                    // only (rows-1) rows because absolute has already the first row\r\n                    if (!rs.next()){\r\n                        System.out.println( \"  Failed: No rows were found at page \" + i + \" page and row \" + r);\r\n                        return;\r\n                    }\r\n                    int col_i = rs.getInt(\"i\");\r\n                    if (col_i != (i*rows+r)){\r\n                        System.out.println( \"  Failed: Wrong row \" + col_i + \", it should be row \" + (i*rows+r));\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n            time += System.currentTimeMillis();\r\n            System.out.println( \"  Test time: \" + time + \" ms\");\r\n            st.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }\r\n\r\n    \r\n    \r\n    /**\r\n      *  7. Test\r\n      *  Update rows with the method updateRow().\r\n      */  \r\n    static void test_UpdateRows(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test update rows with updateRow(): \" + rowCount + \" rows\");\r\n        \r\n        try{\r\n            Statement st = con.createStatement( ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE );\r\n            ResultSet rs = st.executeQuery(\"SELECT * FROM \" + tableName);\r\n            int colCount = rs.getMetaData().getColumnCount();\r\n            long time = -System.currentTimeMillis();\r\n            int count = 0;\r\n            while(rs.next()){\r\n                for (int i=2; i<=colCount; i++){\r\n                    rs.updateObject( i, rs.getObject(i) );\r\n                }\r\n                rs.updateRow();\r\n                count++;\r\n            }\r\n            time += System.currentTimeMillis();\r\n            if (count != rowCount)\r\n                 System.out.println( \"  Failed: Only \" + count + \" rows were updated.\");\r\n            else System.out.println( \"  Test time: \" + time + \" ms\");\r\n            st.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\" + e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }\r\n    \r\n    \r\n    \r\n    /**\r\n      *  8. Test\r\n      *  Update rows with a PreparedStatement.\r\n      */  \r\n    static void test_UpdateRowsPrepare(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test update rows with a PreparedStatement: \" + rowCount + \" rows\");\r\n        try{\r\n            PreparedStatement pr = con.prepareStatement( \"UPDATE \" + tableName + \" SET bi=?,c=?,d=?,de=?,f=?,im=?,i=?,m=?,n=?,r=?,sd=?,si=?,sm=?,sy=?,t=?,ti=?,vb=?,vc=? WHERE i=?\" );\r\n            long time = -System.currentTimeMillis();\r\n            for (int i=0; i<rowCount; i++){\r\n\t            pr.setBytes (  1, byteArray );\r\n\t            pr.setString(  2 , \"Test\" );\r\n\t            pr.setDate  (  3 , new Date( System.currentTimeMillis() ) );\r\n\t            pr.setFloat (  4, (float)1234.56789 );\r\n\t            pr.setFloat (  5 , (float)9876.54321 );\r\n\t            pr.setBytes (  6, largeByteArray );\r\n\t            pr.setInt   (  7 , i );\r\n\t            pr.setDouble(  8 , 23.45 );\r\n\t            pr.setDouble(  9 , 567.45 );\r\n\t            pr.setFloat (  10 , (float)78.89 );\r\n\t            pr.setTime  (  11, new Time( System.currentTimeMillis() ) );\r\n\t            pr.setShort (  12, (short)23456 );\r\n\t            pr.setFloat (  13, (float)34.56 );\r\n\t            pr.setString(  14, \"sysname (30) NULL\" );\r\n\t            pr.setString(  15 , \"text NULL\" );\r\n\t            pr.setByte  (  16, (byte)28 );\r\n\t            pr.setBytes (  17, byteArray );\r\n\t            pr.setString(  18, \"varchar (255) NULL\" );\r\n\t            pr.setInt   (  19 , i );\r\n                int updateCount = pr.executeUpdate();\r\n                if (updateCount != 1){\r\n                    System.out.println( \"  Failed: Update count should be 1 but it is \" + updateCount + \".\");\r\n                    return;\r\n                }\r\n            }\r\n            time += System.currentTimeMillis();\r\n            System.out.println( \"  Test time: \" + time + \" ms\");\r\n            pr.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }\r\n    \r\n    \r\n    \r\n    /**\r\n      *  9. Test\r\n      *  Update rows with a PreparedStatement and a stored procedure.\r\n      */  \r\n    static void test_UpdateRowsPrepareSP(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test update rows with a PreparedStatement and a stored procedure: \" + rowCount + \" rows\");\r\n        \r\n        try{\r\n            Statement st = con.createStatement();\r\n            try{st.execute(\"drop procedure sp_\"+tableName);}catch(Exception e){/* ignore it */}\r\n            st.execute(\"create procedure sp_\"+tableName+\" (@bi binary,@c nchar(255),@d datetime,@de decimal,@f float,@im image,@i int,@m money,@n numeric(18, 0),@r real,@sd smalldatetime,@si smallint,@sm smallmoney,@sy sysname,@t ntext,@ti tinyint,@vb varbinary(255),@vc nvarchar(255)) as UPDATE \" + tableName + \" SET bi=@bi,c=@c,d=@d,de=@de,f=@f,im=@im,i=@i,m=@m,n=@n,r=@r,sd=@sd,si=@si,sm=@sm,sy=@sy,t=@t,ti=@ti,vb=@vb,vc=@vc WHERE i=@i\");\r\n\r\n            PreparedStatement pr = con.prepareStatement( \"exec sp_\" + tableName + \" ?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?\" );\r\n            long time = -System.currentTimeMillis();\r\n            for (int i=0; i<rowCount; i++){\r\n\t            pr.setBytes (  1, byteArray );\r\n\t            pr.setString(  2 , \"Test\" );\r\n\t            pr.setDate  (  3 , new Date( System.currentTimeMillis() ) );\r\n\t            pr.setFloat (  4, (float)1234.56789 );\r\n\t            pr.setFloat (  5 , (float)9876.54321 );\r\n\t            pr.setBytes (  6, largeByteArray );\r\n\t            pr.setInt   (  7 , i );\r\n\t            pr.setDouble(  8 , 23.45 );\r\n\t            pr.setDouble(  9 , 567.45 );\r\n\t            pr.setFloat (  10 , (float)78.89 );\r\n\t            pr.setTime  (  11, new Time( System.currentTimeMillis() ) );\r\n\t            pr.setShort (  12, (short)23456 );\r\n\t            pr.setFloat (  13, (float)34.56 );\r\n\t            pr.setString(  14, \"sysname (30) NULL\" );\r\n\t            pr.setString(  15 , \"text NULL\" );\r\n\t            pr.setByte  (  16, (byte)28 );\r\n\t            pr.setBytes (  17, byteArray );\r\n\t            pr.setString(  18, \"varchar (255) NULL\" );\r\n                int updateCount = pr.executeUpdate();\r\n                if (updateCount != 1){\r\n                    System.out.println( \"  Failed: Update count should be 1 but it is \" + updateCount + \".\");\r\n                    return;\r\n                }\r\n            }\r\n            time += System.currentTimeMillis();\r\n            System.out.println( \"  Test time: \" + time + \" ms\");\r\n            st.execute(\"drop procedure sp_\"+tableName);\r\n            st.close();\r\n            pr.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }\r\n    \r\n\r\n    \r\n    /**\r\n      *  10. Test\r\n      *  Update rows with a PreparedStatement and Batch.\r\n      */  \r\n    static void test_UpdateRowsPrepareBatch(Connection con){\r\n        int batchSize = 10;\r\n        int batches = rowCount / batchSize;\r\n        System.out.println();\r\n        System.out.println( \"Test update rows with PreparedStatement and Batches: \" + batches + \" batches, \" + batchSize + \" batch size\");\r\n        \r\n        try{\r\n            PreparedStatement pr = con.prepareStatement( \"UPDATE \" + tableName + \" SET bi=?,c=?,d=?,de=?,f=?,im=?,i=?,m=?,n=?,r=?,sd=?,si=?,sm=?,sy=?,t=?,ti=?,vb=?,vc=? WHERE i=?\" );\r\n            long time = -System.currentTimeMillis();\r\n            for (int i=0; i<batches; i++){\r\n                for (int r=0; r<batchSize; r++){\r\n\t                pr.setBytes (  1, byteArray );\r\n\t                pr.setString(  2 , \"Test\" );\r\n\t                pr.setDate  (  3 , new Date( System.currentTimeMillis() ) );\r\n\t                pr.setFloat (  4, (float)1234.56789 );\r\n\t                pr.setFloat (  5 , (float)9876.54321 );\r\n\t                pr.setBytes (  6, largeByteArray );\r\n\t                pr.setInt   (  7 , i*batchSize + r );\r\n\t                pr.setDouble(  8 , 23.45 );\r\n\t                pr.setDouble(  9 , 567.45 );\r\n\t                pr.setFloat (  10 , (float)78.89 );\r\n\t                pr.setTime  (  11, new Time( System.currentTimeMillis() ) );\r\n\t                pr.setShort (  12, (short)23456 );\r\n\t                pr.setFloat (  13, (float)34.56 );\r\n\t                pr.setString(  14, \"sysname (30) NULL\" );\r\n\t                pr.setString(  15 , \"text NULL\" );\r\n\t                pr.setByte  (  16, (byte)28 );\r\n\t                pr.setBytes (  17, byteArray );\r\n\t                pr.setString(  18, \"varchar (255) NULL\" );\r\n\t                pr.setInt   (  19 , i );\r\n\t                pr.addBatch();\r\n\t            }\r\n                int[] updateCount = pr.executeBatch();\r\n                if (updateCount.length != batchSize){\r\n                    System.out.println( \"  Failed: Update count size should be \" + batchSize + \" but it is \" + updateCount.length + \".\");\r\n                    return;\r\n                }\r\n            }\r\n            time += System.currentTimeMillis();\r\n            System.out.println( \"  Test time: \" + time + \" ms\");\r\n            pr.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }\r\n     \r\n    \r\n    \r\n    /**\r\n      *  11. Test\r\n      *  Scroll and call the getXXX methods for every columns.\r\n      */  \r\n    static void test_Scroll_getXXX(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test scroll and call the getXXX methods for every columns: \" + rowCount + \" rows\");\r\n        \r\n        try{\r\n            Statement st = con.createStatement();\r\n            long time = -System.currentTimeMillis();\r\n            ResultSet rs = st.executeQuery(\"SELECT * FROM \" + tableName);\r\n            for (int i=0; i<rowCount; i++){\r\n                    rs.next();\r\n\t                rs.getInt   (  1 );\r\n\t                rs.getBytes (  2 );\r\n\t                rs.getString(  3 );\r\n\t                rs.getDate  (  4 );\r\n\t                rs.getFloat (  5 );\r\n\t                rs.getFloat (  6 );\r\n\t                rs.getBytes (  7 );\r\n\t                rs.getInt   (  8 );\r\n\t                rs.getDouble(  9 );\r\n\t                rs.getDouble(  10 );\r\n\t                rs.getFloat (  11 );\r\n\t                rs.getTime  (  12 );\r\n\t                rs.getShort (  13 );\r\n\t                rs.getFloat (  14 );\r\n\t                rs.getString(  15 );\r\n\t                rs.getString(  16 );\r\n\t                rs.getByte  (  17 );\r\n\t                rs.getBytes (  18 );\r\n\t                rs.getString(  19 );\r\n            }\r\n            time += System.currentTimeMillis();\r\n            System.out.println( \"  Test time: \" + time + \" ms\");\r\n            st.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }\r\n     \r\n    \r\n    /**\r\n      *  12. Test\r\n      *  Update large binary data.\r\n      */  \r\n    static void test_UpdateLargeBinary(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test update large binary data: \" + rowCount + \"KB bytes\");\r\n        \r\n        try{\r\n            java.io.FileOutputStream fos = new java.io.FileOutputStream(tableName+\".bin\");\r\n            byte bytes[] = new byte[1024];\r\n            for(int i=0; i<rowCount; i++){\r\n                fos.write(bytes);\r\n            }\r\n            fos.close();\r\n            java.io.FileInputStream fis = new java.io.FileInputStream(tableName+\".bin\");\r\n            long time = -System.currentTimeMillis();\r\n            PreparedStatement pr = con.prepareStatement(\"Update \" + tableName + \" set im=? WHERE pr=1\");\r\n            pr.setBinaryStream( 1, fis, rowCount*1024 );\r\n            pr.execute();\r\n            pr.close();\r\n            time += System.currentTimeMillis();\r\n            System.out.println( \"  Test time: \" + time + \" ms\");\r\n            fis.close();\r\n            java.io.File file = new java.io.File(tableName+\".bin\");\r\n            file.delete();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }\r\n     \r\n    \r\n\r\n    \r\n    /**\r\n      *  12. Test\r\n      *  Update large binary data with a SP.\r\n      */  \r\n    static void test_UpdateLargeBinaryWithSP(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test update large binary data with a SP: \" + rowCount + \"KB bytes\");\r\n        \r\n        try{\r\n            java.io.FileOutputStream fos = new java.io.FileOutputStream(tableName+\".bin\");\r\n            byte bytes[] = new byte[1024];\r\n            for(int i=0; i<rowCount; i++){\r\n                fos.write(bytes);\r\n            }\r\n            fos.close();\r\n            java.io.FileInputStream fis = new java.io.FileInputStream(tableName+\".bin\");\r\n            long time = -System.currentTimeMillis();\r\n            Statement st = con.createStatement();\r\n            st.execute(\"CREATE PROCEDURE #UpdateLargeBinary(@im image) as Update \" + tableName + \" set im=@im WHERE pr=2\");\r\n            PreparedStatement pr = con.prepareStatement(\"exec #UpdateLargeBinary ?\");\r\n            pr.setBinaryStream( 1, fis, rowCount*1024 );\r\n            pr.execute();\r\n            st.execute(\"DROP PROCEDURE #UpdateLargeBinary\");\r\n            st.close();\r\n            pr.close();\r\n            time += System.currentTimeMillis();\r\n            System.out.println( \"  Test time: \" + time + \" ms\");\r\n            fis.close();\r\n            java.io.File file = new java.io.File(tableName+\".bin\");\r\n            file.delete();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }\r\n     \r\n    \r\n\r\n    \r\n    /**\r\n      *  Create a new Table for testing\r\n      */  \r\n    static void createTestTable(Connection con) throws SQLException{\r\n            Statement st;\r\n            st = con.createStatement();\r\n            //delete old table\r\n            dropTestTable( con );\r\n\r\n            //create table\r\n            st.execute(\r\n                \"CREATE TABLE \" + tableName + \" (\"+\r\n\t            \"    pr  numeric IDENTITY,\"+\r\n\t            \"    bi  binary (255) NULL ,\"+\r\n\t            \"    c   nchar (255) NULL ,\"+\r\n\t            \"    d   datetime NULL ,\"+\r\n\t            \"    de  decimal(18, 0) NULL ,\"+\r\n\t            \"    f   float NULL ,\"+\r\n\t            \"    im  image NULL ,\"+\r\n\t            \"    i   int NULL ,\"+\r\n\t            \"    m   money NULL ,\"+\r\n\t            \"    n   numeric(18, 0) NULL ,\"+\r\n\t            \"    r   real NULL ,\"+\r\n\t            \"    sd  smalldatetime NULL ,\"+\r\n\t            \"    si  smallint NULL ,\"+\r\n\t            \"    sm  smallmoney NULL ,\"+\r\n\t            \"    sy  sysname NULL ,\"+\r\n\t            \"    t   ntext NULL ,\"+\r\n\t            \"    ti  tinyint NULL ,\"+\r\n\t            \"    vb  varbinary (255) NULL ,\"+\r\n\t            \"    vc  nvarchar (255) NULL, \"+\r\n\t            \"CONSTRAINT PK_BenchTest2 PRIMARY KEY CLUSTERED (pr) \"+\r\n\t            \")\");\r\n\t        st.close();  \r\n    }\r\n    \r\n\r\n    \r\n    static void deleteTestTable(Connection con){\r\n        try{\r\n            Statement st = con.createStatement();\r\n            st.execute(\"DELETE FROM \" + tableName);\r\n            st.close();\r\n        }catch(Exception e){/* ignore it */}\r\n    }\r\n\r\n    static void dropTestTable(Connection con){\r\n        try{\r\n            Statement st = con.createStatement();\r\n            st.execute(\"drop table \" + tableName);\r\n            st.close();\r\n        }catch(Exception e){/* ignore it */}\r\n    }\r\n    \r\n    // create test data after the insert test is failed\r\n    static void createTestDataWithClassicInsert(Connection con) throws SQLException{\r\n        String sql = \"INSERT INTO \" + tableName + \"(bi,c,d,de,f,im,i,m,n,r,si,sd,sm,sy,t,ti,vb,vc) VALUES(0x172243,'Test','20010101',1234.56789,9876.54321,0x\";\r\n        for(int i=0; i<largeByteArray.length; i++){\r\n            sql += \"00\";\r\n        }\r\n        Statement st = con.createStatement();\r\n        for (int i=0; i<rowCount; i++){\r\n            st.execute(sql + \",\"+i+\",23.45,567.45,78.89,\"+i+\",'11:11:11',34.56,'sysname (30) NULL','ntext NULL, sample to save in the field',\"+(i & 0xFF)+\",0x172243,'nvarchar (255) NULL')\"  );\r\n        }\r\n        st.close();\r\n    }\r\n}"},{"path":"/src/smallsql/junit/TestOrderBy.java","source":"/* =============================================================\r\n * SmallSQL : a free Java DBMS library for the Java(tm) platform\r\n * =============================================================\r\n *\r\n * (C) Copyright 2004-2006, by Volker Berlin.\r\n *\r\n * Project Info:  http://www.smallsql.de/\r\n *\r\n * This library is free software; you can redistribute it and/or modify it \r\n * under the terms of the GNU Lesser General Public License as published by \r\n * the Free Software Foundation; either version 2.1 of the License, or \r\n * (at your option) any later version.\r\n *\r\n * This library is distributed in the hope that it will be useful, but \r\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \r\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public \r\n * License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, \r\n * USA.  \r\n *\r\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc. \r\n * in the United States and other countries.]\r\n *\r\n * ---------------\r\n * TestOrderBy.java\r\n * ---------------\r\n * Author: Volker Berlin\r\n * \r\n */\r\npackage smallsql.junit;\r\n\r\nimport java.sql.*;\r\nimport java.util.ArrayList;\r\n\r\n/**\r\n * @author Administrator\r\n *\r\n * To change the template for this generated type comment go to\r\n * Window - Preferences - Java - Code Generation - Code and Comments\r\n */\r\npublic class TestOrderBy extends BasicTestCase {\r\n\r\n\tstatic private boolean init;\r\n\tprivate static final String table1 = \"table_OrderBy1\";\r\n\tprivate static final String table2 = \"table_OrderBy2\";\r\n\tprivate static final String table3 = \"table_OrderBy3\";\r\n\tstatic private int valueCount;\r\n\t\r\n\tpublic void init(){\r\n\t\tif(init) return;\r\n\t\ttry{\r\n\t\t\tConnection con = AllTests.getConnection();\r\n\t\t\tdropTable( con, table1 );\r\n\t\t\tdropTable( con, table2 );\r\n\t\t\tdropTable( con, table3 );\r\n\t\t\tStatement st = con.createStatement();\r\n\t\t\tst.execute(\"create table \" + table1 + \"(v varchar(30), c char(30), nv nvarchar(30),i int, d float, r real, bi bigint, b boolean)\");\r\n\t\t\tst.execute(\"create table \" + table2 + \"(c2 char(30))\");\r\n\t\t\tst.execute(\"create table \" + table3 + \"(vc varchar(30), vb varbinary(30))\");\r\n\t\t\tst.close();\r\n\t\t\t\r\n\t\t\tPreparedStatement pr = con.prepareStatement(\"INSERT into \" + table1 + \"(v,c,nv,i,d,r,bi,b) Values(?,?,?,?,?,?,?,?)\");\r\n\t\t\tPreparedStatement pr2= con.prepareStatement(\"INSERT into \" + table2 + \"(c2) Values(?)\");\r\n\t\t\tfor(int i=150; i>-10; i--){\r\n\t\t\t\tpr.setString( 1, String.valueOf(i));\r\n\t\t\t\tpr.setString( 2, String.valueOf(i));\r\n\t\t\t\tpr.setString( 3, String.valueOf( (char)i ));\r\n\t\t\t\tpr.setInt   ( 4, i );\r\n\t\t\t\tpr.setDouble( 5, i );\r\n\t\t\t\tpr.setFloat ( 6, i );\r\n\t\t\t\tpr.setInt   ( 7, i );\r\n\t\t\t\tpr.setBoolean( 8, i == 0 );\r\n\t\t\t\tpr.execute();\r\n\t\t\t\tpr2.setString( 1, String.valueOf(i));\r\n\t\t\t\tpr2.execute();\r\n\t\t\t\tvalueCount++;\r\n\t\t\t}\r\n\t\t\tpr.setObject( 1, null, Types.VARCHAR);\r\n\t\t\tpr.setObject( 2, null, Types.VARCHAR);\r\n\t\t\tpr.setObject( 3, null, Types.VARCHAR);\r\n\t\t\tpr.setObject( 4, null, Types.VARCHAR);\r\n\t\t\tpr.setObject( 5, null, Types.VARCHAR);\r\n\t\t\tpr.setObject( 6, null, Types.VARCHAR);\r\n\t\t\tpr.setObject( 7, null, Types.VARCHAR);\r\n\t\t\tpr.setObject( 8, null, Types.VARCHAR);\r\n\t\t\tpr.execute();\r\n\t\t\tpr2.setObject( 1, null, Types.VARCHAR);\r\n\t\t\tpr2.execute();\r\n\t\t\tpr2.setString( 1, \"\");\r\n\t\t\tpr2.execute();\r\n\r\n\t\t\tpr.close();\r\n\r\n\t\t\tpr = con.prepareStatement(\"INSERT into \" + table3 + \"(vc, vb) Values(?,?)\");\r\n\t\t\tpr.setString( 1, table3);\r\n\t\t\tpr.setBytes( 2, table3.getBytes());\r\n\t\t\tpr.execute();\r\n\t\t\tpr.setString( 1, \"\");\r\n\t\t\tpr.setBytes( 2, new byte[0]);\r\n\t\t\tpr.execute();\r\n\t\t\tpr.setString( 1, null);\r\n\t\t\tpr.setBytes( 2, null);\r\n\t\t\tpr.execute();\r\n\t\t\t\r\n\t\t\tinit = true;\r\n\t\t}catch(Throwable e){\r\n\t\t\te.printStackTrace();\r\n\t\t}\r\n\t}\r\n\t\r\n\t\r\n\tpublic void testOrderBy_char() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tString oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by c\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = rs.getString(\"c\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"c\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tString newValue = rs.getString(\"c\");\r\n\t\t\tassertTrue( oldValue + \"<\" + newValue, oldValue.compareTo( newValue ) < 0 );\r\n\t\t\toldValue = newValue;\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\trs.close();\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void testOrderBy_varchar() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tString oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by v\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tString newValue = rs.getString(\"v\");\r\n\t\t\tassertTrue( oldValue + \"<\" + newValue, oldValue.compareTo( newValue ) < 0 );\r\n\t\t\toldValue = newValue;\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void testOrderBy_varchar_asc() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tString oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by v ASC\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tString newValue = rs.getString(\"v\");\r\n\t\t\tassertTrue( oldValue.compareTo( newValue ) < 0 );\r\n\t\t\toldValue = newValue;\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\trs.close();\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void testOrderBy_varchar_desc() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tString oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by v desc\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(oldValue != null && rs.next()){\r\n\t\t\tString newValue = rs.getString(\"v\");\r\n\t\t\tif(newValue != null){\r\n\t\t\t\tassertTrue( oldValue.compareTo( newValue ) > 0 );\r\n\t\t\t\tcount++;\r\n\t\t\t}\r\n\t\t\toldValue = newValue;\r\n\t\t}\r\n\t\tassertNull(oldValue);\r\n\t\tassertFalse( rs.next() );\r\n\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\t\r\n\tpublic void testOrderBy_varchar_DescAsc() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tString oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by v desc, i asc\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(oldValue != null && rs.next()){\r\n\t\t\tString newValue = rs.getString(\"v\");\r\n\t\t\tif(newValue != null){\r\n\t\t\t\tassertTrue( oldValue.compareTo( newValue ) > 0 );\r\n\t\t\t\tcount++;\r\n\t\t\t}\r\n\t\t\toldValue = newValue;\r\n\t\t}\r\n\t\tassertNull(oldValue);\r\n\t\tassertFalse( rs.next() );\r\n\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\t\r\n\tpublic void testOrderBy_varchar_GroupBy() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tString oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT first(v) cc FROM \" + table1 + \" Group By i ORDER  by first(V)\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = rs.getString(\"cc\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"cc\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tassertTrue( oldValue.compareTo( rs.getString(\"cc\") ) < 0 );\r\n\t\t\toldValue = rs.getString(\"cc\");\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void testOrderBy_varchar_Join() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tString oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" t1 Inner join \"+table2+\" t2 on t1.c=t2.c2  ORDER  by v\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tassertTrue( oldValue.compareTo( rs.getString(\"v\") ) < 0 );\r\n\t\t\toldValue = rs.getString(\"v\");\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void testOrderBy_nvarchar() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tString oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by nv\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = rs.getString(\"nv\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"nv\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tassertTrue( String.CASE_INSENSITIVE_ORDER.compare( oldValue, rs.getString(\"nv\") ) <= 0 );\r\n\t\t\toldValue = rs.getString(\"nv\");\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void testOrderBy_int() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tInteger oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by i\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = (Integer)rs.getObject(\"i\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = (Integer)rs.getObject(\"i\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tassertTrue( oldValue.compareTo( (Integer)rs.getObject(\"i\") ) < 0 );\r\n\t\t\toldValue = (Integer)rs.getObject(\"i\");\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void test_function() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tint oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by abs(i)\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\tassertNull(rs.getObject(\"i\"));\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = Math.abs( rs.getInt(\"i\") );\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tint newValue = Math.abs( rs.getInt(\"i\") );\r\n\t\t\tassertTrue( oldValue <= newValue );\r\n\t\t\toldValue = newValue;\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void test_functionAscDesc() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tint oldValue;\r\n\t\tint oldValue2;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by abs(i) Asc, i desc\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\tassertNull(rs.getObject(\"i\"));\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = Math.abs( rs.getInt(\"i\") );\r\n\t\toldValue2 = rs.getInt(\"i\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tint newValue2 = rs.getInt(\"i\");\r\n\t\t\tint newValue = Math.abs( newValue2 );\r\n\t\t\tassertTrue( oldValue <= newValue );\r\n\t\t\tif(oldValue == newValue){\r\n\t\t\t\tassertTrue( oldValue2 > newValue2 );\r\n\t\t\t}\r\n\t\t\toldValue = newValue;\r\n\t\t\toldValue2 = newValue2;\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void testOrderBy_int_asc() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tInteger oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by i Asc\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = (Integer)rs.getObject(\"i\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = (Integer)rs.getObject(\"i\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tassertTrue( oldValue.compareTo( (Integer)rs.getObject(\"i\") ) < 0 );\r\n\t\t\toldValue = (Integer)rs.getObject(\"i\");\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void testOrderBy_int_desc() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tInteger oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by i Desc\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = (Integer)rs.getObject(\"i\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(oldValue != null && rs.next()){\r\n\t\t\tInteger newValue = (Integer)rs.getObject(\"i\");\r\n\t\t\tif(newValue != null){\r\n\t\t\t\tassertTrue( oldValue.compareTo( newValue ) > 0 );\r\n\t\t\t\tcount++;\r\n\t\t\t}\r\n\t\t\toldValue = newValue;\r\n\t\t}\r\n\t\tassertNull(oldValue);\r\n\t\tassertFalse( rs.next() );\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void testOrderBy_double() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tDouble oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by d\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = (Double)rs.getObject(\"d\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = (Double)rs.getObject(\"d\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tassertTrue( oldValue.compareTo( (Double)rs.getObject(\"d\") ) < 0 );\r\n\t\t\toldValue = (Double)rs.getObject(\"d\");\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void testOrderBy_real() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tFloat oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by r\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = (Float)rs.getObject(\"r\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = (Float)rs.getObject(\"r\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tassertTrue( oldValue.compareTo( (Float)rs.getObject(\"r\") ) < 0 );\r\n\t\t\toldValue = (Float)rs.getObject(\"r\");\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void test_bigint() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tLong oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by bi\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = (Long)rs.getObject(\"bi\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = (Long)rs.getObject(\"bi\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tassertTrue( oldValue.compareTo( (Long)rs.getObject(\"bi\") ) < 0 );\r\n\t\t\toldValue = (Long)rs.getObject(\"bi\");\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void test_bigint_withDoublicateValues() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tLong oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT bi/2 bi_2 FROM \" + table1 + \" ORDER  by (bi/2)\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = (Long)rs.getObject(\"bi_2\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = (Long)rs.getObject(\"bi_2\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tLong newValue = (Long)rs.getObject(\"bi_2\");\r\n\t\t\tassertTrue( oldValue + \"<=\"+newValue, oldValue.compareTo( newValue ) <= 0 );\r\n\t\t\toldValue = newValue;\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void test_boolean() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tboolean oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by b\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = rs.getBoolean(\"b\");\r\n\t\tassertFalse(oldValue);\r\n\t\tassertTrue(rs.wasNull());\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getBoolean(\"b\");\r\n\t\tassertFalse(oldValue);\t\t\r\n\t\tassertFalse(rs.wasNull());\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(!oldValue && rs.next()){\r\n\t\t\toldValue = rs.getBoolean(\"b\");\r\n\t\t\tassertFalse(rs.wasNull());\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\twhile(oldValue && rs.next()){\r\n\t\t\toldValue = rs.getBoolean(\"b\");\r\n\t\t\tassertFalse(rs.wasNull());\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertFalse(rs.next());\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void testVarcharEmpty() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table3 + \" ORDER  by vc\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\t\t\r\n\t\tassertNull( rs.getObject(\"vc\") );\r\n\r\n\t\tassertTrue( rs.next() );\r\n\t\tassertEquals( \"\", rs.getObject(\"vc\") );\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\tassertEquals( table3, rs.getObject(\"vc\") );\r\n\t\t\r\n\t\tassertFalse( rs.next() );\r\n\t}\r\n\t\r\n\r\n\tpublic void testVarbinaryEmpty() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table3 + \" ORDER  by vb\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\t\t\r\n\t\tassertNull( rs.getObject(\"vb\") );\r\n\r\n\t\tassertTrue( rs.next() );\r\n\t\tassertEqualsObject( \"\", new byte[0], rs.getObject(\"vb\"), false );\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\tassertEqualsObject( \"\", table3.getBytes(), rs.getObject(\"vb\"), false );\r\n\t\t\r\n\t\tassertFalse( rs.next() );\r\n\t}\r\n\r\n\r\n\tpublic void test2Columns() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs = null;\r\n\t\tString oldValue;\r\n\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1+\",\"+table2+\" ORDER  by v, c2\");\r\n\r\n\t\tassertTrue( rs.next() );\r\n\t\tassertNull( rs.getObject(\"v\") );\r\n\t\tassertNull( rs.getObject(\"c2\") );\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"c2\");\r\n\r\n\t\tint count = 1;\r\n\t\twhile(rs.next() && rs.getString(\"v\") == null){\r\n\t\t\tString newValue = rs.getString(\"c2\");\r\n\t\t\tassertTrue( oldValue.compareTo( newValue ) < 0 );\r\n\t\t\toldValue = newValue;\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount+1, count );\r\n\t\t\r\n\t\tboolean isNext = true;\r\n\t\twhile(isNext){\r\n\t\t\tString vValue = rs.getString(\"v\");\r\n\t\t\tassertNull( rs.getObject(\"c2\") );\r\n\t\t\r\n\t\t\tassertTrue( rs.next() );\r\n\t\t\toldValue = rs.getString(\"c2\");\r\n\t\t\tassertEquals( vValue, rs.getString(\"v\") );\r\n\r\n\t\t\tisNext = rs.next();\r\n\t\t\tcount = 1;\r\n\t\t\twhile(isNext && vValue.equals(rs.getString(\"v\"))){\r\n\t\t\t\tString newValue = rs.getString(\"c2\");\r\n\t\t\t\tassertTrue( oldValue.compareTo( newValue ) < 0 );\r\n\t\t\t\toldValue = newValue;\r\n\t\t\t\tcount++;\r\n\t\t\t\tisNext = rs.next();\r\n\t\t\t}\r\n\t\t\tassertEquals( valueCount+1, count );\r\n\t\t}\r\n\t}\r\n\r\n\t\r\n\r\n\tpublic void testOrderBy_Scollable() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);\r\n\t\tResultSet rs;\r\n\t\tint count;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by v\");\r\n\t\t\r\n\t\t//jetzt irgendwo in die Mitte scrollen\r\n\t\trs.next();\r\n\t\trs.next();\r\n\t\trs.previous(); //dann soll der Zeiger nicht am Ende des bereits gefetchten stehen\r\n\t\t\r\n\t\trs.last();\r\n\t\tcount = 0;\r\n\t\twhile(rs.previous()) count++;\t\t\r\n\t\tassertEquals( valueCount, count );\r\n\r\n\t\trs.beforeFirst();\r\n\t\tcount = -1;\r\n\t\twhile(rs.next()) count++;\t\t\r\n\t\tassertEquals( valueCount, count );\r\n\r\n\t\trs.beforeFirst();\r\n\t\tcount = -1;\r\n\t\twhile(rs.next()) count++;\t\t\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\r\n\t\r\n\tpublic void testOrderBy_ScollableDesc() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);\r\n\t\tResultSet rs;\r\n\t\tint count;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by i desc, d\");\r\n\t\t\r\n\t\t//jetzt irgendwo in die Mitte scrollen\r\n\t\trs.next();\r\n\t\trs.next();\r\n\t\trs.previous(); //dann soll der Zeiger nicht am Ende des bereits gefetchten stehen\r\n\t\t\r\n\t\trs.last();\r\n\t\tcount = 0;\r\n\t\twhile(rs.previous()) count++;\t\t\r\n\t\tassertEquals( valueCount, count );\r\n\r\n\t\trs.beforeFirst();\r\n\t\tcount = -1;\r\n\t\twhile(rs.next()) count++;\t\t\r\n\t\tassertEquals( valueCount, count );\r\n\r\n\t\trs.beforeFirst();\r\n\t\tcount = -1;\r\n\t\twhile(rs.next()) count++;\t\t\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\r\n\t\r\n\tpublic void testOrderBy_Scollable2() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);\r\n\t\tResultSet rs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by v\");\r\n\r\n\t\t\r\n\t\tint colCount = rs.getMetaData().getColumnCount();\r\n\t\tArrayList result = new ArrayList();\r\n\t\twhile(rs.next()){\r\n\t\t\tObject[] row = new Object[colCount];\r\n\t\t\tfor(int i=0; i<colCount; i++){\r\n\t\t\t\trow[i] = rs.getObject(i+1);\r\n\t\t\t}\r\n\t\t\tresult.add(row);\r\n\t\t}\r\n\t\t\r\n\t\tint rowCount = result.size();\r\n\t\twhile(rs.previous()){\r\n\t\t\tObject[] row = (Object[])result.get(--rowCount);\r\n\t\t\tfor(int i=0; i<colCount; i++){\r\n\t\t\t\tassertEquals( \"Difference in row:\"+rowCount, row[i], rs.getObject(i+1));\r\n\t\t\t}\r\n\t\t}\r\n\t\tassertEquals( \"RowCount different between next and previous:\"+rowCount, 0, rowCount);\r\n\t}\r\n\r\n\t\r\n\tpublic void testUnion() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tString oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT v, 5 as Const FROM \" + table1 + \" Union All Select vc, 6 From \" + table3 + \" ORDER by v\");\r\n\t\t\r\n\t\tassertRSMetaData(rs, new String[]{\"v\", \"Const\"}, new int[]{Types.VARCHAR, Types.INTEGER});\r\n\t\t\r\n\t\tassertTrue( rs.next() );\t\t\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\tassertNull(oldValue);\r\n\t\t\r\n\t\tassertTrue( rs.next() );\t\t\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\tassertNull(oldValue);\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\t\r\n\t\tint count = 3;\r\n\t\twhile(rs.next()){\r\n\t\t\tString newValue = rs.getString(\"v\");\r\n\t\t\tassertTrue( oldValue.compareTo( newValue ) < 0 );\r\n\t\t\toldValue = newValue;\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount+4, count );\r\n\t}\r\n\r\n\r\n}\r\n"},{"path":"/src/smallsql/junit/TestOrderBy.java","source":"/* =============================================================\r\n * SmallSQL : a free Java DBMS library for the Java(tm) platform\r\n * =============================================================\r\n *\r\n * (C) Copyright 2004-2006, by Volker Berlin.\r\n *\r\n * Project Info:  http://www.smallsql.de/\r\n *\r\n * This library is free software; you can redistribute it and/or modify it \r\n * under the terms of the GNU Lesser General Public License as published by \r\n * the Free Software Foundation; either version 2.1 of the License, or \r\n * (at your option) any later version.\r\n *\r\n * This library is distributed in the hope that it will be useful, but \r\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \r\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public \r\n * License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, \r\n * USA.  \r\n *\r\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc. \r\n * in the United States and other countries.]\r\n *\r\n * ---------------\r\n * TestOrderBy.java\r\n * ---------------\r\n * Author: Volker Berlin\r\n * \r\n */\r\npackage smallsql.junit;\r\n\r\nimport java.sql.*;\r\nimport java.util.ArrayList;\r\n\r\n/**\r\n * @author Administrator\r\n *\r\n * To change the template for this generated type comment go to\r\n * Window - Preferences - Java - Code Generation - Code and Comments\r\n */\r\npublic class TestOrderBy extends BasicTestCase {\r\n\r\n\tstatic private boolean init;\r\n\tprivate static final String table1 = \"table_OrderBy1\";\r\n\tprivate static final String table2 = \"table_OrderBy2\";\r\n\tprivate static final String table3 = \"table_OrderBy3\";\r\n\tstatic private int valueCount;\r\n\t\r\n\tpublic void init(){\r\n\t\tif(init) return;\r\n\t\ttry{\r\n\t\t\tConnection con = AllTests.getConnection();\r\n\t\t\tdropTable( con, table1 );\r\n\t\t\tdropTable( con, table2 );\r\n\t\t\tdropTable( con, table3 );\r\n\t\t\tStatement st = con.createStatement();\r\n\t\t\tst.execute(\"create table \" + table1 + \"(v varchar(30), c char(30), nv nvarchar(30),i int, d float, r real, bi bigint, b boolean)\");\r\n\t\t\tst.execute(\"create table \" + table2 + \"(c2 char(30))\");\r\n\t\t\tst.execute(\"create table \" + table3 + \"(vc varchar(30), vb varbinary(30))\");\r\n\t\t\tst.close();\r\n\t\t\t\r\n\t\t\tPreparedStatement pr = con.prepareStatement(\"INSERT into \" + table1 + \"(v,c,nv,i,d,r,bi,b) Values(?,?,?,?,?,?,?,?)\");\r\n\t\t\tPreparedStatement pr2= con.prepareStatement(\"INSERT into \" + table2 + \"(c2) Values(?)\");\r\n\t\t\tfor(int i=150; i>-10; i--){\r\n\t\t\t\tpr.setString( 1, String.valueOf(i));\r\n\t\t\t\tpr.setString( 2, String.valueOf(i));\r\n\t\t\t\tpr.setString( 3, String.valueOf( (char)i ));\r\n\t\t\t\tpr.setInt   ( 4, i );\r\n\t\t\t\tpr.setDouble( 5, i );\r\n\t\t\t\tpr.setFloat ( 6, i );\r\n\t\t\t\tpr.setInt   ( 7, i );\r\n\t\t\t\tpr.setBoolean( 8, i == 0 );\r\n\t\t\t\tpr.execute();\r\n\t\t\t\tpr2.setString( 1, String.valueOf(i));\r\n\t\t\t\tpr2.execute();\r\n\t\t\t\tvalueCount++;\r\n\t\t\t}\r\n\t\t\tpr.setObject( 1, null, Types.VARCHAR);\r\n\t\t\tpr.setObject( 2, null, Types.VARCHAR);\r\n\t\t\tpr.setObject( 3, null, Types.VARCHAR);\r\n\t\t\tpr.setObject( 4, null, Types.VARCHAR);\r\n\t\t\tpr.setObject( 5, null, Types.VARCHAR);\r\n\t\t\tpr.setObject( 6, null, Types.VARCHAR);\r\n\t\t\tpr.setObject( 7, null, Types.VARCHAR);\r\n\t\t\tpr.setObject( 8, null, Types.VARCHAR);\r\n\t\t\tpr.execute();\r\n\t\t\tpr2.setObject( 1, null, Types.VARCHAR);\r\n\t\t\tpr2.execute();\r\n\t\t\tpr2.setString( 1, \"\");\r\n\t\t\tpr2.execute();\r\n\r\n\t\t\tpr.close();\r\n\r\n\t\t\tpr = con.prepareStatement(\"INSERT into \" + table3 + \"(vc, vb) Values(?,?)\");\r\n\t\t\tpr.setString( 1, table3);\r\n\t\t\tpr.setBytes( 2, table3.getBytes());\r\n\t\t\tpr.execute();\r\n\t\t\tpr.setString( 1, \"\");\r\n\t\t\tpr.setBytes( 2, new byte[0]);\r\n\t\t\tpr.execute();\r\n\t\t\tpr.setString( 1, null);\r\n\t\t\tpr.setBytes( 2, null);\r\n\t\t\tpr.execute();\r\n\t\t\t\r\n\t\t\tinit = true;\r\n\t\t}catch(Throwable e){\r\n\t\t\te.printStackTrace();\r\n\t\t}\r\n\t}\r\n\t\r\n\t\r\n\tpublic void testOrderBy_char() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tString oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by c\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = rs.getString(\"c\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"c\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tString newValue = rs.getString(\"c\");\r\n\t\t\tassertTrue( oldValue + \"<\" + newValue, oldValue.compareTo( newValue ) < 0 );\r\n\t\t\toldValue = newValue;\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\trs.close();\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void testOrderBy_varchar() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tString oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by v\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tString newValue = rs.getString(\"v\");\r\n\t\t\tassertTrue( oldValue + \"<\" + newValue, oldValue.compareTo( newValue ) < 0 );\r\n\t\t\toldValue = newValue;\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void testOrderBy_varchar_asc() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tString oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by v ASC\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tString newValue = rs.getString(\"v\");\r\n\t\t\tassertTrue( oldValue.compareTo( newValue ) < 0 );\r\n\t\t\toldValue = newValue;\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\trs.close();\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void testOrderBy_varchar_desc() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tString oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by v desc\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(oldValue != null && rs.next()){\r\n\t\t\tString newValue = rs.getString(\"v\");\r\n\t\t\tif(newValue != null){\r\n\t\t\t\tassertTrue( oldValue.compareTo( newValue ) > 0 );\r\n\t\t\t\tcount++;\r\n\t\t\t}\r\n\t\t\toldValue = newValue;\r\n\t\t}\r\n\t\tassertNull(oldValue);\r\n\t\tassertFalse( rs.next() );\r\n\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\t\r\n\tpublic void testOrderBy_varchar_DescAsc() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tString oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by v desc, i asc\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(oldValue != null && rs.next()){\r\n\t\t\tString newValue = rs.getString(\"v\");\r\n\t\t\tif(newValue != null){\r\n\t\t\t\tassertTrue( oldValue.compareTo( newValue ) > 0 );\r\n\t\t\t\tcount++;\r\n\t\t\t}\r\n\t\t\toldValue = newValue;\r\n\t\t}\r\n\t\tassertNull(oldValue);\r\n\t\tassertFalse( rs.next() );\r\n\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\t\r\n\tpublic void testOrderBy_varchar_GroupBy() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tString oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT first(v) cc FROM \" + table1 + \" Group By i ORDER  by first(V)\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = rs.getString(\"cc\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"cc\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tassertTrue( oldValue.compareTo( rs.getString(\"cc\") ) < 0 );\r\n\t\t\toldValue = rs.getString(\"cc\");\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void testOrderBy_varchar_Join() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tString oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" t1 Inner join \"+table2+\" t2 on t1.c=t2.c2  ORDER  by v\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tassertTrue( oldValue.compareTo( rs.getString(\"v\") ) < 0 );\r\n\t\t\toldValue = rs.getString(\"v\");\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void testOrderBy_nvarchar() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tString oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by nv\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = rs.getString(\"nv\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"nv\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tassertTrue( String.CASE_INSENSITIVE_ORDER.compare( oldValue, rs.getString(\"nv\") ) <= 0 );\r\n\t\t\toldValue = rs.getString(\"nv\");\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void testOrderBy_int() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tInteger oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by i\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = (Integer)rs.getObject(\"i\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = (Integer)rs.getObject(\"i\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tassertTrue( oldValue.compareTo( (Integer)rs.getObject(\"i\") ) < 0 );\r\n\t\t\toldValue = (Integer)rs.getObject(\"i\");\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void test_function() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tint oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by abs(i)\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\tassertNull(rs.getObject(\"i\"));\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = Math.abs( rs.getInt(\"i\") );\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tint newValue = Math.abs( rs.getInt(\"i\") );\r\n\t\t\tassertTrue( oldValue <= newValue );\r\n\t\t\toldValue = newValue;\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void test_functionAscDesc() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tint oldValue;\r\n\t\tint oldValue2;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by abs(i) Asc, i desc\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\tassertNull(rs.getObject(\"i\"));\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = Math.abs( rs.getInt(\"i\") );\r\n\t\toldValue2 = rs.getInt(\"i\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tint newValue2 = rs.getInt(\"i\");\r\n\t\t\tint newValue = Math.abs( newValue2 );\r\n\t\t\tassertTrue( oldValue <= newValue );\r\n\t\t\tif(oldValue == newValue){\r\n\t\t\t\tassertTrue( oldValue2 > newValue2 );\r\n\t\t\t}\r\n\t\t\toldValue = newValue;\r\n\t\t\toldValue2 = newValue2;\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void testOrderBy_int_asc() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tInteger oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by i Asc\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = (Integer)rs.getObject(\"i\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = (Integer)rs.getObject(\"i\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tassertTrue( oldValue.compareTo( (Integer)rs.getObject(\"i\") ) < 0 );\r\n\t\t\toldValue = (Integer)rs.getObject(\"i\");\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void testOrderBy_int_desc() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tInteger oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by i Desc\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = (Integer)rs.getObject(\"i\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(oldValue != null && rs.next()){\r\n\t\t\tInteger newValue = (Integer)rs.getObject(\"i\");\r\n\t\t\tif(newValue != null){\r\n\t\t\t\tassertTrue( oldValue.compareTo( newValue ) > 0 );\r\n\t\t\t\tcount++;\r\n\t\t\t}\r\n\t\t\toldValue = newValue;\r\n\t\t}\r\n\t\tassertNull(oldValue);\r\n\t\tassertFalse( rs.next() );\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void testOrderBy_double() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tDouble oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by d\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = (Double)rs.getObject(\"d\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = (Double)rs.getObject(\"d\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tassertTrue( oldValue.compareTo( (Double)rs.getObject(\"d\") ) < 0 );\r\n\t\t\toldValue = (Double)rs.getObject(\"d\");\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void testOrderBy_real() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tFloat oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by r\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = (Float)rs.getObject(\"r\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = (Float)rs.getObject(\"r\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tassertTrue( oldValue.compareTo( (Float)rs.getObject(\"r\") ) < 0 );\r\n\t\t\toldValue = (Float)rs.getObject(\"r\");\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void test_bigint() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tLong oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by bi\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = (Long)rs.getObject(\"bi\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = (Long)rs.getObject(\"bi\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tassertTrue( oldValue.compareTo( (Long)rs.getObject(\"bi\") ) < 0 );\r\n\t\t\toldValue = (Long)rs.getObject(\"bi\");\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void test_bigint_withDoublicateValues() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tLong oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT bi/2 bi_2 FROM \" + table1 + \" ORDER  by (bi/2)\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = (Long)rs.getObject(\"bi_2\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = (Long)rs.getObject(\"bi_2\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tLong newValue = (Long)rs.getObject(\"bi_2\");\r\n\t\t\tassertTrue( oldValue + \"<=\"+newValue, oldValue.compareTo( newValue ) <= 0 );\r\n\t\t\toldValue = newValue;\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void test_boolean() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tboolean oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by b\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = rs.getBoolean(\"b\");\r\n\t\tassertFalse(oldValue);\r\n\t\tassertTrue(rs.wasNull());\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getBoolean(\"b\");\r\n\t\tassertFalse(oldValue);\t\t\r\n\t\tassertFalse(rs.wasNull());\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(!oldValue && rs.next()){\r\n\t\t\toldValue = rs.getBoolean(\"b\");\r\n\t\t\tassertFalse(rs.wasNull());\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\twhile(oldValue && rs.next()){\r\n\t\t\toldValue = rs.getBoolean(\"b\");\r\n\t\t\tassertFalse(rs.wasNull());\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertFalse(rs.next());\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void testVarcharEmpty() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table3 + \" ORDER  by vc\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\t\t\r\n\t\tassertNull( rs.getObject(\"vc\") );\r\n\r\n\t\tassertTrue( rs.next() );\r\n\t\tassertEquals( \"\", rs.getObject(\"vc\") );\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\tassertEquals( table3, rs.getObject(\"vc\") );\r\n\t\t\r\n\t\tassertFalse( rs.next() );\r\n\t}\r\n\t\r\n\r\n\tpublic void testVarbinaryEmpty() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table3 + \" ORDER  by vb\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\t\t\r\n\t\tassertNull( rs.getObject(\"vb\") );\r\n\r\n\t\tassertTrue( rs.next() );\r\n\t\tassertEqualsObject( \"\", new byte[0], rs.getObject(\"vb\"), false );\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\tassertEqualsObject( \"\", table3.getBytes(), rs.getObject(\"vb\"), false );\r\n\t\t\r\n\t\tassertFalse( rs.next() );\r\n\t}\r\n\r\n\r\n\tpublic void test2Columns() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs = null;\r\n\t\tString oldValue;\r\n\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1+\",\"+table2+\" ORDER  by v, c2\");\r\n\r\n\t\tassertTrue( rs.next() );\r\n\t\tassertNull( rs.getObject(\"v\") );\r\n\t\tassertNull( rs.getObject(\"c2\") );\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"c2\");\r\n\r\n\t\tint count = 1;\r\n\t\twhile(rs.next() && rs.getString(\"v\") == null){\r\n\t\t\tString newValue = rs.getString(\"c2\");\r\n\t\t\tassertTrue( oldValue.compareTo( newValue ) < 0 );\r\n\t\t\toldValue = newValue;\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount+1, count );\r\n\t\t\r\n\t\tboolean isNext = true;\r\n\t\twhile(isNext){\r\n\t\t\tString vValue = rs.getString(\"v\");\r\n\t\t\tassertNull( rs.getObject(\"c2\") );\r\n\t\t\r\n\t\t\tassertTrue( rs.next() );\r\n\t\t\toldValue = rs.getString(\"c2\");\r\n\t\t\tassertEquals( vValue, rs.getString(\"v\") );\r\n\r\n\t\t\tisNext = rs.next();\r\n\t\t\tcount = 1;\r\n\t\t\twhile(isNext && vValue.equals(rs.getString(\"v\"))){\r\n\t\t\t\tString newValue = rs.getString(\"c2\");\r\n\t\t\t\tassertTrue( oldValue.compareTo( newValue ) < 0 );\r\n\t\t\t\toldValue = newValue;\r\n\t\t\t\tcount++;\r\n\t\t\t\tisNext = rs.next();\r\n\t\t\t}\r\n\t\t\tassertEquals( valueCount+1, count );\r\n\t\t}\r\n\t}\r\n\r\n\t\r\n\r\n\tpublic void testOrderBy_Scollable() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);\r\n\t\tResultSet rs;\r\n\t\tint count;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by v\");\r\n\t\t\r\n\t\t//jetzt irgendwo in die Mitte scrollen\r\n\t\trs.next();\r\n\t\trs.next();\r\n\t\trs.previous(); //dann soll der Zeiger nicht am Ende des bereits gefetchten stehen\r\n\t\t\r\n\t\trs.last();\r\n\t\tcount = 0;\r\n\t\twhile(rs.previous()) count++;\t\t\r\n\t\tassertEquals( valueCount, count );\r\n\r\n\t\trs.beforeFirst();\r\n\t\tcount = -1;\r\n\t\twhile(rs.next()) count++;\t\t\r\n\t\tassertEquals( valueCount, count );\r\n\r\n\t\trs.beforeFirst();\r\n\t\tcount = -1;\r\n\t\twhile(rs.next()) count++;\t\t\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\r\n\t\r\n\tpublic void testOrderBy_ScollableDesc() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);\r\n\t\tResultSet rs;\r\n\t\tint count;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by i desc, d\");\r\n\t\t\r\n\t\t//jetzt irgendwo in die Mitte scrollen\r\n\t\trs.next();\r\n\t\trs.next();\r\n\t\trs.previous(); //dann soll der Zeiger nicht am Ende des bereits gefetchten stehen\r\n\t\t\r\n\t\trs.last();\r\n\t\tcount = 0;\r\n\t\twhile(rs.previous()) count++;\t\t\r\n\t\tassertEquals( valueCount, count );\r\n\r\n\t\trs.beforeFirst();\r\n\t\tcount = -1;\r\n\t\twhile(rs.next()) count++;\t\t\r\n\t\tassertEquals( valueCount, count );\r\n\r\n\t\trs.beforeFirst();\r\n\t\tcount = -1;\r\n\t\twhile(rs.next()) count++;\t\t\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\r\n\t\r\n\tpublic void testOrderBy_Scollable2() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);\r\n\t\tResultSet rs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by v\");\r\n\r\n\t\t\r\n\t\tint colCount = rs.getMetaData().getColumnCount();\r\n\t\tArrayList result = new ArrayList();\r\n\t\twhile(rs.next()){\r\n\t\t\tObject[] row = new Object[colCount];\r\n\t\t\tfor(int i=0; i<colCount; i++){\r\n\t\t\t\trow[i] = rs.getObject(i+1);\r\n\t\t\t}\r\n\t\t\tresult.add(row);\r\n\t\t}\r\n\t\t\r\n\t\tint rowCount = result.size();\r\n\t\twhile(rs.previous()){\r\n\t\t\tObject[] row = (Object[])result.get(--rowCount);\r\n\t\t\tfor(int i=0; i<colCount; i++){\r\n\t\t\t\tassertEquals( \"Difference in row:\"+rowCount, row[i], rs.getObject(i+1));\r\n\t\t\t}\r\n\t\t}\r\n\t\tassertEquals( \"RowCount different between next and previous:\"+rowCount, 0, rowCount);\r\n\t}\r\n\r\n\t\r\n\tpublic void testUnion() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tString oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT v, 5 as Const FROM \" + table1 + \" Union All Select vc, 6 From \" + table3 + \" ORDER by v\");\r\n\t\t\r\n\t\tassertRSMetaData(rs, new String[]{\"v\", \"Const\"}, new int[]{Types.VARCHAR, Types.INTEGER});\r\n\t\t\r\n\t\tassertTrue( rs.next() );\t\t\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\tassertNull(oldValue);\r\n\t\t\r\n\t\tassertTrue( rs.next() );\t\t\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\tassertNull(oldValue);\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\t\r\n\t\tint count = 3;\r\n\t\twhile(rs.next()){\r\n\t\t\tString newValue = rs.getString(\"v\");\r\n\t\t\tassertTrue( oldValue.compareTo( newValue ) < 0 );\r\n\t\t\toldValue = newValue;\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount+4, count );\r\n\t}\r\n\r\n\r\n}\r\n"},{"path":"/src/smallsql/database/SSDatabaseMetaData.java","source":"/* =============================================================\r\n * SmallSQL : a free Java DBMS library for the Java(tm) platform\r\n * =============================================================\r\n *\r\n * (C) Copyright 2004-2007, by Volker Berlin.\r\n *\r\n * Project Info:  http://www.smallsql.de/\r\n *\r\n * This library is free software; you can redistribute it and/or modify it \r\n * under the terms of the GNU Lesser General Public License as published by \r\n * the Free Software Foundation; either version 2.1 of the License, or \r\n * (at your option) any later version.\r\n *\r\n * This library is distributed in the hope that it will be useful, but \r\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \r\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public \r\n * License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, \r\n * USA.  \r\n *\r\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc. \r\n * in the United States and other countries.]\r\n *\r\n * ---------------\r\n * SSDatabaseMetaData.java\r\n * ---------------\r\n * Author: Volker Berlin\r\n * \r\n */\r\npackage smallsql.database;\r\n\r\nimport java.sql.*;\r\nimport java.util.ArrayList;\r\n\r\n\r\nfinal class SSDatabaseMetaData implements DatabaseMetaData {\r\n\tfinal private SSConnection con;\r\n\tfinal private SSStatement st;\r\n\t\r\n\t\r\n    /**\r\n     * @throws SQLException Exception can be throw if the Connection already closed.\r\n     */\r\n    SSDatabaseMetaData(SSConnection con) throws SQLException{\r\n\t\tthis.con = con;\r\n\t\tst = new SSStatement(con);\r\n\t}\r\n\t\r\n    public boolean allProceduresAreCallable() {\r\n    \treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean allTablesAreSelectable() {\r\n    \treturn true;\r\n    }\r\n\t\r\n\t\r\n    public String getURL() throws SQLException {\r\n    \tDatabase database = con.getDatabase(true);\r\n    \tif(database == null)\r\n\t\t\treturn SSDriver.URL_PREFIX;\r\n    \treturn SSDriver.URL_PREFIX + ':' + database.getName();\r\n    }\r\n\t\r\n\t\r\n    public String getUserName() {\r\n    \treturn \"\";\r\n    }\r\n\t\r\n\t\r\n    public boolean isReadOnly() {\r\n    \treturn false;\r\n    }\r\n\t\r\n\t\r\n    public boolean nullsAreSortedHigh() {\r\n\t\treturn false;\r\n    }\r\n\t\r\n\t\r\n    public boolean nullsAreSortedLow() {\r\n\t\treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean nullsAreSortedAtStart() {\r\n\t\treturn false;\r\n    }\r\n\t\r\n\t\r\n    public boolean nullsAreSortedAtEnd() {\r\n\t\treturn false;\r\n    }\r\n\t\r\n\t\r\n    public String getDatabaseProductName() {\r\n    \treturn \"SmallSQL Database\";\r\n    }\r\n\t\r\n\t\r\n    public String getDatabaseProductVersion() {\r\n    \treturn getDriverVersion();\r\n    }\r\n\t\r\n\t\r\n    public String getDriverName(){\r\n    \treturn \"SmallSQL Driver\";\r\n    }\r\n\t\r\n\t\r\n    public String getDriverVersion() {\r\n    \treturn getDriverMajorVersion() + \".\" + SSDriver.drv.getMinorVersion();\r\n    }\r\n\t\r\n\t\r\n    public int getDriverMajorVersion() {\r\n    \treturn SSDriver.drv.getMajorVersion();\r\n    }\r\n\t\r\n\t\r\n    public int getDriverMinorVersion() {\r\n\t\treturn SSDriver.drv.getMinorVersion();\r\n    }\r\n\t\r\n\t\r\n    public boolean usesLocalFiles() {\r\n    \treturn false;\r\n    }\r\n\t\r\n\t\r\n    public boolean usesLocalFilePerTable() {\r\n    \treturn false;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsMixedCaseIdentifiers() {\r\n    \treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean storesUpperCaseIdentifiers() {\r\n    \treturn false;\r\n    }\r\n\t\r\n\t\r\n    public boolean storesLowerCaseIdentifiers() {\r\n    \treturn false;\r\n    }\r\n\t\r\n\t\r\n    public boolean storesMixedCaseIdentifiers() {\r\n    \treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsMixedCaseQuotedIdentifiers() {\r\n    \treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean storesUpperCaseQuotedIdentifiers() {\r\n    \treturn false;\r\n    }\r\n\t\r\n\t\r\n    public boolean storesLowerCaseQuotedIdentifiers() {\r\n    \treturn false;\r\n    }\r\n\t\r\n\t\r\n    public boolean storesMixedCaseQuotedIdentifiers() {\r\n    \treturn true;\r\n    }\r\n\t\r\n\t\r\n    public String getIdentifierQuoteString() {\r\n    \treturn \"\\\"\";\r\n    }\r\n\t\r\n\t\r\n    public String getSQLKeywords() {\r\n    \treturn \"database,use\";\r\n    }\r\n    \r\n    \r\n    private String getFunctions(int from, int to){\r\n\t\tStringBuffer buf = new StringBuffer();\r\n\t\tfor(int i=from; i<=to; i++){\r\n\t\t\tif(i != from) buf.append(',');\r\n\t\t\tbuf.append( SQLTokenizer.getKeyWord(i) );\r\n\t\t}\r\n\t\treturn buf.toString();\r\n    }\r\n    \r\n    \r\n    public String getNumericFunctions() {\r\n    \treturn getFunctions(SQLTokenizer.ABS, SQLTokenizer.TRUNCATE);\r\n    }\r\n    \r\n    \r\n    public String getStringFunctions() {\r\n\t\treturn getFunctions(SQLTokenizer.ASCII, SQLTokenizer.UCASE);\r\n    }\r\n    \r\n    \r\n    public String getSystemFunctions() {\r\n\t\treturn getFunctions(SQLTokenizer.IFNULL, SQLTokenizer.IIF);\r\n    }\r\n    \r\n    \r\n    public String getTimeDateFunctions() {\r\n\t\treturn getFunctions(SQLTokenizer.CURDATE, SQLTokenizer.YEAR);\r\n    }\r\n    \r\n    \r\n    public String getSearchStringEscape() {\r\n    \treturn \"\\\\\";\r\n    }\r\n    \r\n    \r\n    public String getExtraNameCharacters() {\r\n    \treturn \"#$Ã€Ã�Ã‚ÃƒÃ„Ã…Ã†Ã‡ÃˆÃ‰ÃŠÃ‹ÃŒÃ�ÃŽÃ�Ã�Ã‘Ã’Ã“Ã”Ã•Ã–Ã˜Ã™ÃšÃ›ÃœÃ�ÃžÃŸÃ Ã¡Ã¢Ã£Ã¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯Ã°Ã±Ã²Ã³Ã´ÃµÃ¶Ã¸Ã¹ÃºÃ»Ã¼Ã½Ã¾Ã¿\";\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsAlterTableWithAddColumn() {\r\n        /**@todo: Implement this java.sql.DatabaseMetaData method*/\r\n        throw new java.lang.UnsupportedOperationException(\"Method supportsAlterTableWithAddColumn() not yet implemented.\");\r\n    }\r\n    public boolean supportsAlterTableWithDropColumn() {\r\n        /**@todo: Implement this java.sql.DatabaseMetaData method*/\r\n        throw new java.lang.UnsupportedOperationException(\"Method supportsAlterTableWithDropColumn() not yet implemented.\");\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsColumnAliasing() {\r\n    \treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean nullPlusNonNullIsNull() {\r\n    \treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsConvert() {\r\n    \treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsConvert(int fromType, int toType) {\r\n    \treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsTableCorrelationNames() {\r\n    \treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsDifferentTableCorrelationNames() {\r\n    \treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsExpressionsInOrderBy() {\r\n    \treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsOrderByUnrelated() {\r\n    \treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsGroupBy() {\r\n    \treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsGroupByUnrelated() {\r\n    \treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsGroupByBeyondSelect() {\r\n    \treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsLikeEscapeClause() {\r\n    \treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsMultipleResultSets() {\r\n    \treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsMultipleTransactions() {\r\n    \treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsNonNullableColumns() {\r\n    \treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsMinimumSQLGrammar() {\r\n    \treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsCoreSQLGrammar() {\r\n\t\treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsExtendedSQLGrammar() {\r\n    \treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsANSI92EntryLevelSQL() {\r\n    \treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsANSI92IntermediateSQL() {\r\n    \treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsANSI92FullSQL() {\r\n    \treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsIntegrityEnhancementFacility() {\r\n    \treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsOuterJoins() {\r\n    \treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsFullOuterJoins() {\r\n    \treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsLimitedOuterJoins() {\r\n    \treturn true;\r\n    }\r\n\t\r\n\t\r\n    public String getSchemaTerm() {\r\n    \treturn \"owner\";\r\n    }\r\n\t\r\n\t\r\n    public String getProcedureTerm() {\r\n    \treturn \"procedure\";\r\n    }\r\n\t\r\n\t\r\n    public String getCatalogTerm() {\r\n    \treturn \"database\";\r\n    }\r\n\t\r\n\t\r\n    public boolean isCatalogAtStart() {\r\n    \treturn true;\r\n    }\r\n\t\r\n\t\r\n    public String getCatalogSeparator() {\r\n    \treturn \".\";\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsSchemasInDataManipulation() {\r\n    \treturn false;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsSchemasInProcedureCalls() {\r\n    \treturn false;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsSchemasInTableDefinitions() {\r\n    \treturn false;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsSchemasInIndexDefinitions() {\r\n    \treturn false;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsSchemasInPrivilegeDefinitions() {\r\n    \treturn false;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsCatalogsInDataManipulation() {\r\n\t\treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsCatalogsInProcedureCalls() {\r\n    \treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsCatalogsInTableDefinitions() {\r\n    \treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsCatalogsInIndexDefinitions() {\r\n\t\treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsCatalogsInPrivilegeDefinitions() {\r\n\t\treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsPositionedDelete() {\r\n    \treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsPositionedUpdate() {\r\n\t\treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsSelectForUpdate() {\r\n\t\treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsStoredProcedures() {\r\n    \treturn false;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsSubqueriesInComparisons() {\r\n\t\treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsSubqueriesInExists() {\r\n\t\treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsSubqueriesInIns() {\r\n\t\treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsSubqueriesInQuantifieds() {\r\n\t\treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsCorrelatedSubqueries() {\r\n\t\treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsUnion() {\r\n\t\treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsUnionAll() {\r\n\t\treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsOpenCursorsAcrossCommit() {\r\n    \treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsOpenCursorsAcrossRollback() {\r\n    \treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsOpenStatementsAcrossCommit() {\r\n    \treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsOpenStatementsAcrossRollback() {\r\n    \treturn true;\r\n    }\r\n\t\r\n\t\r\n    public int getMaxBinaryLiteralLength() {\r\n    \treturn 0;\r\n    }\r\n\t\r\n\t\r\n    public int getMaxCharLiteralLength() {\r\n    \treturn 0;\r\n    }\r\n\t\r\n\t\r\n    public int getMaxColumnNameLength() {\r\n    \treturn 255;\r\n    }\r\n\t\r\n\t\r\n    public int getMaxColumnsInGroupBy() {\r\n    \treturn 0;\r\n    }\r\n\t\r\n\t\r\n    public int getMaxColumnsInIndex() {\r\n    \treturn 0;\r\n    }\r\n\t\r\n\t\r\n    public int getMaxColumnsInOrderBy() {\r\n    \treturn 0;\r\n    }\r\n\t\r\n\t\r\n    public int getMaxColumnsInSelect() {\r\n    \treturn 0;\r\n    }\r\n\t\r\n\t\r\n    public int getMaxColumnsInTable() {\r\n    \treturn 0;\r\n    }\r\n\t\r\n\t\r\n    public int getMaxConnections() {\r\n    \treturn 0;\r\n    }\r\n\t\r\n\t\r\n    public int getMaxCursorNameLength() {\r\n    \treturn 0;\r\n    }\r\n\t\r\n\t\r\n    public int getMaxIndexLength() {\r\n    \treturn 0;\r\n    }\r\n\t\r\n\t\r\n    public int getMaxSchemaNameLength() {\r\n    \treturn 255;\r\n    }\r\n\t\r\n\t\r\n    public int getMaxProcedureNameLength() {\r\n    \treturn 255;\r\n    }\r\n\t\r\n\t\r\n    public int getMaxCatalogNameLength() {\r\n    \treturn 255;\r\n    }\r\n\t\r\n\t\r\n    public int getMaxRowSize() {\r\n    \treturn 0;\r\n    }\r\n\t\r\n\t\r\n    public boolean doesMaxRowSizeIncludeBlobs() {\r\n    \treturn false;\r\n    }\r\n\t\r\n\t\r\n    public int getMaxStatementLength() {\r\n    \treturn 0;\r\n    }\r\n\t\r\n\t\r\n    public int getMaxStatements() {\r\n    \treturn 0;\r\n    }\r\n\t\r\n\t\r\n    public int getMaxTableNameLength() {\r\n    \treturn 255;\r\n    }\r\n\t\r\n\t\r\n    public int getMaxTablesInSelect() {\r\n    \treturn 0;\r\n    }\r\n\t\r\n\t\r\n    public int getMaxUserNameLength() {\r\n    \treturn 0;\r\n    }\r\n\t\r\n\t\r\n    public int getDefaultTransactionIsolation() {\r\n    \treturn Connection.TRANSACTION_READ_COMMITTED;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsTransactions() {\r\n    \treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsTransactionIsolationLevel(int level) {\r\n    \tswitch(level){\r\n\t\t\tcase Connection.TRANSACTION_NONE:\r\n\t\t\tcase Connection.TRANSACTION_READ_UNCOMMITTED:\r\n    \t\tcase Connection.TRANSACTION_READ_COMMITTED:\r\n\t\t\tcase Connection.TRANSACTION_REPEATABLE_READ:\r\n\t\t\tcase Connection.TRANSACTION_SERIALIZABLE:\r\n\t\t\t\treturn true;\r\n    \t}\r\n    \treturn false;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsDataDefinitionAndDataManipulationTransactions() {\r\n    \treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsDataManipulationTransactionsOnly() {\r\n    \treturn false;\r\n    }\r\n\t\r\n\t\r\n    public boolean dataDefinitionCausesTransactionCommit() {\r\n    \treturn false;\r\n    }\r\n\t\r\n\t\r\n    public boolean dataDefinitionIgnoredInTransactions() {\r\n    \treturn false;\r\n    }\r\n\t\r\n\t\r\n    public ResultSet getProcedures(String catalog, String schemaPattern, String procedureNamePattern) throws SQLException {\r\n\t\tString[] colNames = {\"PROCEDURE_CAT\", \"PROCEDURE_SCHEM\", \"PROCEDURE_NAME\", \"\", \"\", \"\", \"REMARKS\", \"PROCEDURE_TYPE\"};  \r\n\t\tObject[][] data   = new Object[0][];\r\n\t\treturn new SSResultSet( st, Utils.createMemoryCommandSelect( con, colNames, data));\r\n    }\r\n\t\r\n\t\r\n    public ResultSet getProcedureColumns(String catalog, String schemaPattern, String procedureNamePattern, String columnNamePattern) throws SQLException {\r\n\t\tString[] colNames = {\"PROCEDURE_CAT\", \"PROCEDURE_SCHEM\", \"PROCEDURE_NAME\", \"COLUMN_NAME\", \"COLUMN_TYPE\", \"DATA_TYPE\", \"TYPE_NAME\", \"PRECISION\", \"LENGTH\", \"SCALE\", \"RADIX\", \"NULLABLE\", \"REMARKS\" };\r\n\t\tObject[][] data   = new Object[0][];\r\n\t\treturn new SSResultSet( st, Utils.createMemoryCommandSelect( con, colNames, data));\r\n    }\r\n\t\r\n\t\r\n    public ResultSet getTables(String catalog, String schemaPattern, String tableNamePattern, String[] types) throws SQLException {\r\n\t\tString[] colNames = {\"TABLE_CAT\",\"TABLE_SCHEM\",\"TABLE_NAME\",\"TABLE_TYPE\",\"REMARKS\",\"TYPE_CAT\",\"TYPE_SCHEM\",\"TYPE_NAME\",\"SELF_REFERENCING_COL_NAME\",\"REF_GENERATION\"};\r\n\t\tDatabase database;\r\n\t\tif(catalog == null){ \r\n\t\t\tdatabase = con.getDatabase(true);\r\n\t\t\tif(database != null)\r\n\t\t\t\tcatalog = database.getName();\r\n    \t}else{\r\n\t\t\tdatabase = Database.getDatabase(catalog, con, false);\r\n    \t}\r\n\t\tArrayList rows = new ArrayList();\r\n\t\tboolean isTypeTable = types == null;\r\n\t\tboolean isTypeView = types == null;\r\n\t\tfor(int i=0; types != null && i<types.length; i++){\r\n\t\t\tif(\"TABLE\".equalsIgnoreCase(types[i])) isTypeTable = true;\r\n\t\t\tif(\"VIEW\" .equalsIgnoreCase(types[i])) isTypeView  = true;\r\n\t\t}\r\n\t\t\r\n\t\tif(database != null){\r\n\t\t\tStrings tables = database.getTables(tableNamePattern);\r\n\t\t\tfor(int i=0; i<tables.size(); i++){\r\n\t\t\t\tString table = tables.get(i);\r\n\t\t\t\tObject[] row = new Object[10];\r\n\t\t\t\trow[0] = catalog;\r\n\t\t\t\trow[2] = table;\r\n\t\t\t\ttry{\r\n\t\t\t\t\tif(database.getTableView( con, table) instanceof View){\r\n\t\t\t\t\t\tif(isTypeView){\r\n\t\t\t\t\t\t\trow[3] = \"VIEW\";\r\n\t\t\t\t\t\t\trows.add(row);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tif(isTypeTable){\r\n\t\t\t\t\t\t\trow[3] = \"TABLE\";\t\t\t\t\t\r\n\t\t\t\t\t\t\trows.add(row);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}catch(Exception e){\r\n\t\t\t\t\t//TODO invalid VIEWS does not show because it can't load.\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tObject[][] data = new Object[rows.size()][];\r\n\t\trows.toArray(data);\r\n\t\tCommandSelect cmdSelect = Utils.createMemoryCommandSelect( con, colNames, data);\r\n\t\tExpressions order = new Expressions();\r\n\t\torder.add( new ExpressionName(\"TABLE_TYPE\") );\r\n\t\torder.add( new ExpressionName(\"TABLE_NAME\") );\r\n\t\tcmdSelect.setOrder( order );\r\n\t\treturn new SSResultSet( st, cmdSelect);\r\n    }\r\n\t\r\n\t\r\n    public ResultSet getSchemas() throws SQLException {\r\n\t\tString[] colNames = {\"TABLE_SCHEM\"};\r\n\t\tObject[][] data   = new Object[0][];\r\n\t\treturn new SSResultSet( st, Utils.createMemoryCommandSelect( con, colNames, data));\r\n    }\r\n\t\r\n    \r\n    public ResultSet getCatalogs() throws SQLException {\r\n    \tString[] colNames = {\"TABLE_CAT\"};\r\n    \tObject[][] data   = Database.getCatalogs(con.getDatabase(true));\r\n    \treturn new SSResultSet( st, Utils.createMemoryCommandSelect( con, colNames, data));\r\n    }\r\n\t\r\n    \r\n    public ResultSet getTableTypes() throws SQLException {\r\n\t\tString[] colNames = {\"TABLE_TYPE\"};\r\n\t\tObject[][] data   = {{\"SYSTEM TABLE\"}, {\"TABLE\"}, {\"VIEW\"}};\r\n\t\treturn new SSResultSet( st, Utils.createMemoryCommandSelect( con, colNames, data));\r\n    }\r\n\t\r\n    \r\n    public ResultSet getColumns(String catalog, String schemaPattern, String tableNamePattern, String columnNamePattern) throws SQLException {\r\n\t\ttry {\r\n\t\t\tString[] colNames = {\"TABLE_CAT\", \"TABLE_SCHEM\", \"TABLE_NAME\", \"COLUMN_NAME\", \"DATA_TYPE\", \"TYPE_NAME\", \"COLUMN_SIZE\", \"BUFFER_LENGTH\", \"DECIMAL_DIGITS\", \"NUM_PREC_RADIX\", \"NULLABLE\", \"REMARKS\", \"COLUMN_DEF\", \"SQL_DATA_TYPE\", \"SQL_DATETIME_SUB\", \"CHAR_OCTET_LENGTH\", \"ORDINAL_POSITION\", \"IS_NULLABLE\"};\r\n\t\t\tObject[][] data   = con.getDatabase(false).getColumns(con, tableNamePattern, columnNamePattern);\r\n\t\t\treturn new SSResultSet( st, Utils.createMemoryCommandSelect( con, colNames, data));\r\n\t\t} catch (Exception e) {\r\n\t\t\tthrow SmallSQLException.createFromException(e);\r\n\t\t}\r\n    }\r\n\t\r\n\t\r\n    public ResultSet getColumnPrivileges(String catalog, String schema, String table, String columnNamePattern) throws SQLException {\r\n        String[] colNames = {\"TABLE_CAT\", \"TABLE_SCHEM\", \"TABLE_NAME\", \"COLUMN_NAME\", \"GRANTOR\", \"GRANTEE\", \"PRIVILEGE\", \"IS_GRANTABLE\"};\r\n        /**@todo: Implement this java.sql.DatabaseMetaData method*/\r\n        throw new java.lang.UnsupportedOperationException(\"Method getColumnPrivileges() not yet implemented.\");\r\n    }\r\n    \r\n    \r\n    public ResultSet getTablePrivileges(String catalog, String schemaPattern, String tableNamePattern) throws SQLException {\r\n        String[] colNames = {\"TABLE_CAT\", \"TABLE_SCHEM\", \"TABLE_NAME\", \"GRANTOR\", \"GRANTEE\", \"PRIVILEGE\", \"IS_GRANTABLE\"};\r\n        /**@todo: Implement this java.sql.DatabaseMetaData method*/\r\n        throw new java.lang.UnsupportedOperationException(\"Method getTablePrivileges() not yet implemented.\");\r\n    }\r\n\t\r\n\t\r\n    public ResultSet getBestRowIdentifier(String catalog, String schema, String table, int scope, boolean nullable) throws SQLException {\r\n\t\ttry {\r\n\t\t\tString[] colNames = {\"SCOPE\", \"COLUMN_NAME\", \"DATA_TYPE\", \"TYPE_NAME\", \"COLUMN_SIZE\", \"BUFFER_LENGTH\", \"DECIMAL_DIGITS\", \"PSEUDO_COLUMN\"};\r\n\t\t\tObject[][] data   = con.getDatabase(false).getBestRowIdentifier(con, table);\r\n\t\t\treturn new SSResultSet( st, Utils.createMemoryCommandSelect( con, colNames, data));\r\n\t\t} catch (Exception e) {\r\n\t\t\tthrow SmallSQLException.createFromException(e);\r\n\t\t}\r\n    }\r\n\t\r\n\t\r\n    public ResultSet getVersionColumns(String catalog, String schema, String table) throws SQLException {\r\n\t\ttry {\r\n\t\t\tString[] colNames = {\"SCOPE\", \"COLUMN_NAME\", \"DATA_TYPE\", \"TYPE_NAME\", \"COLUMN_SIZE\", \"BUFFER_LENGTH\", \"DECIMAL_DIGITS\", \"PSEUDO_COLUMN\"};\r\n\t\t\tObject[][] data   = new Object[0][0];\r\n\t\t\treturn new SSResultSet( st, Utils.createMemoryCommandSelect( con, colNames, data));\r\n\t\t} catch (Exception e) {\r\n\t\t\tthrow SmallSQLException.createFromException(e);\r\n\t\t}\r\n    }\r\n\t\r\n\t\r\n    public ResultSet getPrimaryKeys(String catalog, String schema, String table) throws SQLException {\r\n\t\ttry {\r\n\t\t\tString[] colNames = {\"TABLE_CAT\", \"TABLE_SCHEM\", \"TABLE_NAME\", \"COLUMN_NAME\", \"KEY_SEQ\", \"PK_NAME\"};\r\n\t\t\tObject[][] data   = con.getDatabase(false).getPrimaryKeys(con, table);\r\n\t\t\treturn new SSResultSet( st, Utils.createMemoryCommandSelect( con, colNames, data));\r\n\t\t} catch (Exception e) {\r\n\t\t\tthrow SmallSQLException.createFromException(e);\r\n\t\t}\r\n    }\r\n\t\r\n\t\r\n    public ResultSet getImportedKeys(String catalog, String schema, String table) throws SQLException {\r\n\t\treturn getCrossReference( null, null, null, null, null, table );\r\n    }\r\n\t\r\n\t\r\n    public ResultSet getExportedKeys(String catalog, String schema, String table) throws SQLException {\r\n\t\treturn getCrossReference( null, null, table, null, null, null );\r\n    }\r\n\t\r\n\t\r\n    public ResultSet getCrossReference(String primaryCatalog, String primarySchema, String primaryTable, String foreignCatalog, String foreignSchema, String foreignTable) throws SQLException {\r\n\t\ttry {\r\n\t\t\tString[] colNames = {\"PKTABLE_CAT\", \"PKTABLE_SCHEM\", \"PKTABLE_NAME\", \"PKCOLUMN_NAME\", \"FKTABLE_CAT\", \"FKTABLE_SCHEM\", \"FKTABLE_NAME\", \"FKCOLUMN_NAME\", \"KEY_SEQ\", \"UPDATE_RULE\", \"DELETE_RULE\", \"FK_NAME\", \"PK_NAME\", \"DEFERRABILITY\"};\r\n\t\t\tObject[][] data   = con.getDatabase(false).getReferenceKeys(con, primaryTable, foreignTable);\r\n\t\t\treturn new SSResultSet( st, Utils.createMemoryCommandSelect( con, colNames, data));\r\n\t\t} catch (Exception e) {\r\n\t\t\tthrow SmallSQLException.createFromException(e);\r\n\t\t}\r\n    }\r\n\t\r\n\t\r\n    public ResultSet getTypeInfo() throws SQLException {\r\n\t\tString[] colNames = {\t\t\"TYPE_NAME\", \t\t\t\t\"DATA_TYPE\", \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"PRECISION\", \t\"LITERAL_PREFIX\", \"LITERAL_SUFFIX\", \t\t\"CREATE_PARAMS\", \"NULLABLE\", \t \"CASE_SENSITIVE\", \"SEARCHABLE\", \"UNSIGNED_ATTRIBUTE\", \"FIXED_PREC_SCALE\", \"AUTO_INCREMENT\", \"LOCAL_TYPE_NAME\", \"MINIMUM_SCALE\", \"MAXIMUM_SCALE\", \"SQL_DATA_TYPE\", \"SQL_DATETIME_SUB\", \"NUM_PREC_RADIX\"};\r\n\t\tObject[][] data   = {\r\n\t\t {SQLTokenizer.getKeyWord(SQLTokenizer.UNIQUEIDENTIFIER),Utils.getShort(SQLTokenizer.getSQLDataType( SQLTokenizer.UNIQUEIDENTIFIER)), Utils.getInteger(36),      \t\"'\",  \"'\",  null, \t\t\t\tUtils.getShort(typeNullable), Boolean.FALSE, Utils.getShort(typeSearchable), null,          Boolean.FALSE, Boolean.FALSE, null, null,                null,                null, null, null},\r\n\t\t {SQLTokenizer.getKeyWord(SQLTokenizer.BIT),             Utils.getShort(SQLTokenizer.getSQLDataType( SQLTokenizer.BIT) ),             Utils.getInteger(1),      \tnull, null, null, \t\t\t\tUtils.getShort(typeNullable), Boolean.FALSE, Utils.getShort(typeSearchable), null,          Boolean.FALSE, Boolean.FALSE, null, Utils.getInteger(0), Utils.getInteger(0), null, null, null},\r\n\t\t {SQLTokenizer.getKeyWord(SQLTokenizer.TINYINT),         Utils.getShort(SQLTokenizer.getSQLDataType( SQLTokenizer.TINYINT) ),         Utils.getInteger(3),      \tnull, null, null, \t\t\t\tUtils.getShort(typeNullable), Boolean.FALSE, Utils.getShort(typeSearchable), Boolean.TRUE,  Boolean.FALSE, Boolean.FALSE, null, Utils.getInteger(0), Utils.getInteger(0), null, null, null},\r\n\t\t {SQLTokenizer.getKeyWord(SQLTokenizer.BIGINT),          Utils.getShort(SQLTokenizer.getSQLDataType( SQLTokenizer.BIGINT) ),          Utils.getInteger(19),     \tnull, null, null, \t\t\t\tUtils.getShort(typeNullable), Boolean.FALSE, Utils.getShort(typeSearchable), Boolean.FALSE, Boolean.FALSE, Boolean.FALSE, null, Utils.getInteger(0), Utils.getInteger(0), null, null, null},\r\n\t\t {SQLTokenizer.getKeyWord(SQLTokenizer.LONGVARBINARY),   Utils.getShort(SQLTokenizer.getSQLDataType( SQLTokenizer.LONGVARBINARY) ),   Utils.getInteger(2147483647),\t\"0x\", null, null, \t\t \t\tUtils.getShort(typeNullable), Boolean.FALSE, Utils.getShort(typeSearchable), null, \t\t\tBoolean.FALSE, Boolean.FALSE, null, null, \t\t\t\t null, \t\t\t\t  null, null, null},\r\n\t\t {SQLTokenizer.getKeyWord(SQLTokenizer.VARBINARY),   \t Utils.getShort(SQLTokenizer.getSQLDataType( SQLTokenizer.VARBINARY) ),   \t  Utils.getInteger(65535),\t    \"0x\", null, \"max length\", \t\tUtils.getShort(typeNullable), Boolean.FALSE, Utils.getShort(typeSearchable), null, \t\t\tBoolean.FALSE, Boolean.FALSE, null, null, \t\t\t\t null, \t\t\t\t  null, null, null},\r\n\t\t {SQLTokenizer.getKeyWord(SQLTokenizer.BINARY),   \t \t Utils.getShort(SQLTokenizer.getSQLDataType( SQLTokenizer.BINARY) ),   \t  \t  Utils.getInteger(65535),\t    \"0x\", null, \"length\", \t\t\tUtils.getShort(typeNullable), Boolean.FALSE, Utils.getShort(typeSearchable), null, \t\t\tBoolean.FALSE, Boolean.FALSE, null, null, \t\t\t\t null, \t\t\t\t  null, null, null},\r\n\t\t {SQLTokenizer.getKeyWord(SQLTokenizer.LONGVARCHAR),     Utils.getShort(SQLTokenizer.getSQLDataType( SQLTokenizer.LONGVARCHAR) ),     Utils.getInteger(2147483647),\t\"'\",  \"'\",  null, \t\t \t\tUtils.getShort(typeNullable), Boolean.FALSE, Utils.getShort(typeSearchable), null, \t\t\tBoolean.FALSE, Boolean.FALSE, null, null, \t\t\t\t null, \t\t\t\t  null, null, null},\r\n\t\t {SQLTokenizer.getKeyWord(SQLTokenizer.LONGNVARCHAR),    Utils.getShort(SQLTokenizer.getSQLDataType( SQLTokenizer.LONGNVARCHAR) ),    Utils.getInteger(2147483647),\t\"'\",  \"'\",  null, \t\t \t\tUtils.getShort(typeNullable), Boolean.FALSE, Utils.getShort(typeSearchable), null, \t\t\tBoolean.FALSE, Boolean.FALSE, null, null, \t\t\t\t null, \t\t\t\t  null, null, null},\r\n\t\t {SQLTokenizer.getKeyWord(SQLTokenizer.CHAR),         \t Utils.getShort(SQLTokenizer.getSQLDataType( SQLTokenizer.CHAR) ),         \t  Utils.getInteger(65535),   \t\"'\",  \"'\",  \"length\", \t\t\tUtils.getShort(typeNullable), Boolean.FALSE, Utils.getShort(typeSearchable), null, \t\t\tBoolean.FALSE, Boolean.FALSE, null, null, \t\t\t\t null, \t\t\t\t  null, null, null},\r\n\t\t {SQLTokenizer.getKeyWord(SQLTokenizer.NCHAR),         \t Utils.getShort(SQLTokenizer.getSQLDataType( SQLTokenizer.NCHAR) ),           Utils.getInteger(65535),   \t\"'\",  \"'\",  \"length\", \t\t\tUtils.getShort(typeNullable), Boolean.FALSE, Utils.getShort(typeSearchable), null, \t\t\tBoolean.FALSE, Boolean.FALSE, null, null, \t\t\t\t null, \t\t\t\t  null, null, null},\r\n\t\t {SQLTokenizer.getKeyWord(SQLTokenizer.NUMERIC),         Utils.getShort(SQLTokenizer.getSQLDataType( SQLTokenizer.NUMERIC) ),         Utils.getInteger(38),     \tnull, null, \"precision,scale\", \tUtils.getShort(typeNullable), Boolean.FALSE, Utils.getShort(typeSearchable), Boolean.FALSE, Boolean.FALSE, Boolean.FALSE, null, Utils.getInteger(0), Utils.getInteger(38),null, null, null},\r\n\t\t {SQLTokenizer.getKeyWord(SQLTokenizer.DECIMAL),         Utils.getShort(SQLTokenizer.getSQLDataType( SQLTokenizer.DECIMAL) ),         Utils.getInteger(38),     \tnull, null, \"precision,scale\", \tUtils.getShort(typeNullable), Boolean.FALSE, Utils.getShort(typeSearchable), Boolean.FALSE, Boolean.FALSE, Boolean.FALSE, null, Utils.getInteger(0), Utils.getInteger(38),null, null, null},\r\n\t\t {SQLTokenizer.getKeyWord(SQLTokenizer.MONEY),           Utils.getShort(SQLTokenizer.getSQLDataType( SQLTokenizer.MONEY) ),           Utils.getInteger(19),     \tnull, null, null, \t\t\t\tUtils.getShort(typeNullable), Boolean.FALSE, Utils.getShort(typeSearchable), Boolean.FALSE, Boolean.FALSE, Boolean.FALSE, null, Utils.getInteger(4), Utils.getInteger(4), null, null, null},\r\n\t\t {SQLTokenizer.getKeyWord(SQLTokenizer.SMALLMONEY),      Utils.getShort(SQLTokenizer.getSQLDataType( SQLTokenizer.SMALLMONEY) ),      Utils.getInteger(10),     \tnull, null, null, \t\t\t\tUtils.getShort(typeNullable), Boolean.FALSE, Utils.getShort(typeSearchable), Boolean.FALSE, Boolean.FALSE, Boolean.FALSE, null, Utils.getInteger(4), Utils.getInteger(4), null, null, null},\r\n\t\t {SQLTokenizer.getKeyWord(SQLTokenizer.INT),             Utils.getShort(SQLTokenizer.getSQLDataType( SQLTokenizer.INT) ),             Utils.getInteger(10),     \tnull, null, null, \t\t\t\tUtils.getShort(typeNullable), Boolean.FALSE, Utils.getShort(typeSearchable), Boolean.FALSE, Boolean.FALSE, Boolean.FALSE, null, Utils.getInteger(0), Utils.getInteger(0), null, null, null},\r\n\t\t {SQLTokenizer.getKeyWord(SQLTokenizer.SMALLINT),        Utils.getShort(SQLTokenizer.getSQLDataType( SQLTokenizer.SMALLINT) ),        Utils.getInteger(5),      \tnull, null, null, \t\t\t\tUtils.getShort(typeNullable), Boolean.FALSE, Utils.getShort(typeSearchable), Boolean.FALSE, Boolean.FALSE, Boolean.FALSE, null, Utils.getInteger(0), Utils.getInteger(0), null, null, null},\r\n\t\t {SQLTokenizer.getKeyWord(SQLTokenizer.FLOAT),        \t Utils.getShort(SQLTokenizer.getSQLDataType( SQLTokenizer.FLOAT) ),           Utils.getInteger(15),      \tnull, null, null, \t\t\t\tUtils.getShort(typeNullable), Boolean.FALSE, Utils.getShort(typeSearchable), Boolean.FALSE, Boolean.FALSE, Boolean.FALSE, null, Utils.getInteger(0), Utils.getInteger(0), null, null, null},\r\n\t\t {SQLTokenizer.getKeyWord(SQLTokenizer.REAL),        \t Utils.getShort(SQLTokenizer.getSQLDataType( SQLTokenizer.REAL) ),        \t  Utils.getInteger(7),      \tnull, null, null, \t\t\t\tUtils.getShort(typeNullable), Boolean.FALSE, Utils.getShort(typeSearchable), Boolean.FALSE, Boolean.FALSE, Boolean.FALSE, null, Utils.getInteger(0), Utils.getInteger(0), null, null, null},\r\n\t\t {SQLTokenizer.getKeyWord(SQLTokenizer.DOUBLE),          Utils.getShort(SQLTokenizer.getSQLDataType( SQLTokenizer.DOUBLE) ),          Utils.getInteger(15),      \tnull, null, null, \t\t\t\tUtils.getShort(typeNullable), Boolean.FALSE, Utils.getShort(typeSearchable), Boolean.FALSE, Boolean.FALSE, Boolean.FALSE, null, Utils.getInteger(0), Utils.getInteger(0), null, null, null},\r\n\t\t {SQLTokenizer.getKeyWord(SQLTokenizer.VARCHAR),         Utils.getShort(SQLTokenizer.getSQLDataType( SQLTokenizer.VARCHAR) ),         Utils.getInteger(65535),   \t\"'\",  \"'\",  \"max length\", \t\tUtils.getShort(typeNullable), Boolean.FALSE, Utils.getShort(typeSearchable), null, \t\t\tBoolean.FALSE, Boolean.FALSE, null, null, \t\t\t\t null, \t\t\t\t  null, null, null},\r\n\t\t {SQLTokenizer.getKeyWord(SQLTokenizer.NVARCHAR),        Utils.getShort(SQLTokenizer.getSQLDataType( SQLTokenizer.NVARCHAR) ),        Utils.getInteger(65535),   \t\"'\",  \"'\",  \"max length\", \t\tUtils.getShort(typeNullable), Boolean.FALSE, Utils.getShort(typeSearchable), null, \t\t\tBoolean.FALSE, Boolean.FALSE, null, null, \t\t\t\t null, \t\t\t\t  null, null, null},\r\n\t\t {SQLTokenizer.getKeyWord(SQLTokenizer.BOOLEAN),         Utils.getShort(SQLTokenizer.getSQLDataType( SQLTokenizer.BOOLEAN) ),         Utils.getInteger(1),      \tnull, null, null, \t\t\t\tUtils.getShort(typeNullable), Boolean.FALSE, Utils.getShort(typeSearchable), null,          Boolean.FALSE, Boolean.FALSE, null, Utils.getInteger(0), Utils.getInteger(0), null, null, null},\r\n\t\t {SQLTokenizer.getKeyWord(SQLTokenizer.DATE),   \t \t Utils.getShort(SQLTokenizer.getSQLDataType( SQLTokenizer.DATE) ), \t  \t\t  Utils.getInteger(10),\t    \t\"'\",  \"'\",  null, \t\t\t\tUtils.getShort(typeNullable), Boolean.FALSE, Utils.getShort(typeSearchable), null, \t\t\tBoolean.FALSE, Boolean.FALSE, null, null, \t\t\t\t null, \t\t\t\t  null, null, null},\r\n\t\t {SQLTokenizer.getKeyWord(SQLTokenizer.TIME),   \t \t Utils.getShort(SQLTokenizer.getSQLDataType( SQLTokenizer.TIME) ), \t  \t\t  Utils.getInteger(8),\t    \t\"'\",  \"'\",  null, \t\t\t\tUtils.getShort(typeNullable), Boolean.FALSE, Utils.getShort(typeSearchable), null, \t\t\tBoolean.FALSE, Boolean.FALSE, null, null, \t\t\t\t null, \t\t\t\t  null, null, null},\r\n\t\t {SQLTokenizer.getKeyWord(SQLTokenizer.TIMESTAMP),   \t Utils.getShort(SQLTokenizer.getSQLDataType( SQLTokenizer.TIMESTAMP) ), \t  Utils.getInteger(23),\t    \t\"'\",  \"'\",  null, \t\t\t\tUtils.getShort(typeNullable), Boolean.FALSE, Utils.getShort(typeSearchable), null, \t\t\tBoolean.FALSE, Boolean.FALSE, null, Utils.getInteger(3), Utils.getInteger(3), null, null, null},\r\n\t\t {SQLTokenizer.getKeyWord(SQLTokenizer.SMALLDATETIME),   Utils.getShort(SQLTokenizer.getSQLDataType( SQLTokenizer.SMALLDATETIME) ),   Utils.getInteger(16),\t    \t\"'\",  \"'\",  null, \t\t\t\tUtils.getShort(typeNullable), Boolean.FALSE, Utils.getShort(typeSearchable), null, \t\t\tBoolean.FALSE, Boolean.FALSE, null, null, \t\t\t\t null, \t\t\t\t  null, null, null},\r\n\t\t {SQLTokenizer.getKeyWord(SQLTokenizer.JAVA_OBJECT),   \t Utils.getShort(SQLTokenizer.getSQLDataType( SQLTokenizer.JAVA_OBJECT) ),     Utils.getInteger(65535),\t    null, null, null, \t\t\t\tUtils.getShort(typeNullable), Boolean.FALSE, Utils.getShort(typeSearchable), null, \t\t\tBoolean.FALSE, Boolean.FALSE, null, null, \t\t\t\t null, \t\t\t\t  null, null, null},\r\n\t\t {SQLTokenizer.getKeyWord(SQLTokenizer.BLOB),   \t\t Utils.getShort(SQLTokenizer.getSQLDataType( SQLTokenizer.BLOB) ),   \t\t  Utils.getInteger(2147483647),\t\"0x\", null, null, \t\t \t\tUtils.getShort(typeNullable), Boolean.FALSE, Utils.getShort(typeSearchable), null, \t\t\tBoolean.FALSE, Boolean.FALSE, null, null, \t\t\t\t null, \t\t\t\t  null, null, null},\r\n\t\t {SQLTokenizer.getKeyWord(SQLTokenizer.CLOB),     \t\t Utils.getShort(SQLTokenizer.getSQLDataType( SQLTokenizer.CLOB) ),     \t\t  Utils.getInteger(2147483647),\t\"'\",  \"'\",  null, \t\t \t\tUtils.getShort(typeNullable), Boolean.FALSE, Utils.getShort(typeSearchable), null, \t\t\tBoolean.FALSE, Boolean.FALSE, null, null, \t\t\t\t null, \t\t\t\t  null, null, null},\r\n\t\t {SQLTokenizer.getKeyWord(SQLTokenizer.NCLOB),     \t\t Utils.getShort(SQLTokenizer.getSQLDataType( SQLTokenizer.NCLOB) ),     \t  Utils.getInteger(2147483647),\t\"'\",  \"'\",  null, \t\t \t\tUtils.getShort(typeNullable), Boolean.FALSE, Utils.getShort(typeSearchable), null, \t\t\tBoolean.FALSE, Boolean.FALSE, null, null, \t\t\t\t null, \t\t\t\t  null, null, null},\r\n\t\t};\r\n\t\t//TODO add more data types to the list\r\n\t\treturn new SSResultSet( st, Utils.createMemoryCommandSelect( con, colNames, data));\r\n    }\r\n\t\r\n\t\r\n    public ResultSet getIndexInfo(String catalog, String schema, String table, boolean unique, boolean approximate) throws SQLException {\r\n\t\ttry {\r\n\t\t\tString[] colNames = {\"TABLE_CAT\", \"TABLE_SCHEM\", \"TABLE_NAME\", \"NON_UNIQUE\", \"INDEX_QUALIFIER\", \"INDEX_NAME\", \"TYPE\", \"ORDINAL_POSITION\", \"COLUMN_NAME\", \"ASC_OR_DESC\", \"CARDINALITY\", \"PAGES\", \"FILTER_CONDITION\"};\r\n\t\t\tObject[][] data   = con.getDatabase(false).getIndexInfo(con, table, unique);\r\n\t\t\treturn new SSResultSet( st, Utils.createMemoryCommandSelect( con, colNames, data));\r\n\t\t} catch (Exception e) {\r\n\t\t\tthrow SmallSQLException.createFromException(e);\r\n\t\t}\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsResultSetType(int type) {\r\n\t\tswitch(type){\r\n\t\t\tcase ResultSet.TYPE_FORWARD_ONLY:\r\n\t\t\tcase ResultSet.TYPE_SCROLL_INSENSITIVE:\r\n\t\t\tcase ResultSet.TYPE_SCROLL_SENSITIVE:\r\n\t\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsResultSetConcurrency(int type, int concurrency) {\r\n\t\tif(type >= ResultSet.TYPE_FORWARD_ONLY && type <= ResultSet.TYPE_SCROLL_SENSITIVE &&\r\n\t\t\tconcurrency >= ResultSet.CONCUR_READ_ONLY && concurrency <= ResultSet.CONCUR_UPDATABLE)\r\n\t\t\treturn true;\r\n\t\treturn false;\r\n    }\r\n\t\r\n\t\r\n    public boolean ownUpdatesAreVisible(int type) {\r\n\t\treturn supportsResultSetType(type);\r\n    }\r\n\t\r\n\t\r\n    public boolean ownDeletesAreVisible(int type) {\r\n\t\treturn supportsResultSetType(type);\r\n    }\r\n\r\n\t\r\n\tpublic boolean ownInsertsAreVisible(int type) {\r\n\t\treturn supportsResultSetType(type);\r\n    }\r\n\t\r\n\t\r\n    public boolean othersUpdatesAreVisible(int type) {\r\n\t\treturn supportsResultSetType(type);\r\n    }\r\n\t\r\n\t\r\n    public boolean othersDeletesAreVisible(int type) {\r\n\t\treturn supportsResultSetType(type);\r\n    }\r\n\t\r\n\t\r\n    public boolean othersInsertsAreVisible(int type) {\r\n\t\treturn supportsResultSetType(type);\r\n    }\r\n\t\r\n\t\r\n    public boolean updatesAreDetected(int type) {\r\n\t\treturn false;\r\n    }\r\n\t\r\n\t\r\n    public boolean deletesAreDetected(int type) {\r\n\t\treturn supportsResultSetType(type);\r\n    }\r\n\t\r\n\t\r\n    public boolean insertsAreDetected(int type) {\r\n\t\treturn supportsResultSetType(type);\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsBatchUpdates() {\r\n\t\treturn true;\r\n    }\r\n\t\r\n\t\r\n    public ResultSet getUDTs(String catalog, String schemaPattern, String typeNamePattern, int[] types) throws SQLException {\r\n\t\tString[] colNames = {\"TYPE_CAT\", \"TYPE_SCHEM\", \"TYPE_NAME\", \"CLASS_NAME\", \"DATA_TYPE\", \"REMARKS\"};        \r\n\t\tObject[][] data   = new Object[0][];\r\n\t\treturn new SSResultSet( st, Utils.createMemoryCommandSelect( con, colNames, data));\r\n    }\r\n\t\r\n\t\r\n    public Connection getConnection() {\r\n    \treturn con;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsSavepoints() {\r\n    \treturn false;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsNamedParameters() {\r\n\t\treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsMultipleOpenResults() {\r\n\t\treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsGetGeneratedKeys() {\r\n\t\treturn true;\r\n    }\r\n\t\r\n\t\r\n    public ResultSet getSuperTypes(String catalog, String schemaPattern, String typeNamePattern) throws SQLException {\r\n        /**@todo: Implement this java.sql.DatabaseMetaData method*/\r\n        throw new java.lang.UnsupportedOperationException(\"Method getSuperTypes() not yet implemented.\");\r\n    }\r\n    public ResultSet getSuperTables(String catalog, String schemaPattern, String tableNamePattern) throws SQLException {\r\n        /**@todo: Implement this java.sql.DatabaseMetaData method*/\r\n        throw new java.lang.UnsupportedOperationException(\"Method getSuperTables() not yet implemented.\");\r\n    }\r\n    public ResultSet getAttributes(String catalog, String schemaPattern, String typeNamePattern, String attributeNamePattern) throws SQLException {\r\n        /**@todo: Implement this java.sql.DatabaseMetaData method*/\r\n        throw new java.lang.UnsupportedOperationException(\"Method getAttributes() not yet implemented.\");\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsResultSetHoldability(int holdability) {\r\n\t\treturn true;\r\n    }\r\n\t\r\n\t\r\n    public int getResultSetHoldability() {\r\n\t\treturn ResultSet.HOLD_CURSORS_OVER_COMMIT;\r\n    }\r\n\t\r\n\t\r\n    public int getDatabaseMajorVersion() {\r\n    \treturn getDriverMajorVersion();\r\n    }\r\n\t\r\n\t\r\n    public int getDatabaseMinorVersion() {\r\n\t\treturn getDriverMinorVersion();\r\n    }\r\n\t\r\n\t\r\n    public int getJDBCMajorVersion() {\r\n    \treturn 3;\r\n    }\r\n\t\r\n\t\r\n    public int getJDBCMinorVersion() {\r\n    \treturn 0;\r\n    }\r\n\t\r\n\t\r\n    public int getSQLStateType() {\r\n\t\treturn sqlStateSQL99;\r\n    }\r\n\t\r\n\t\r\n    public boolean locatorsUpdateCopy() {\r\n\t\treturn false;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsStatementPooling() {\r\n\t\treturn false;\r\n    }\r\n}"},{"path":"/src/smallsql/junit/BenchTest.java","source":"/* =============================================================\r\n * SmallSQL : a free Java DBMS library for the Java(tm) platform\r\n * =============================================================\r\n *\r\n * (C) Copyright 2004-2006, by Volker Berlin.\r\n *\r\n * Project Info:  http://www.smallsql.de/\r\n *\r\n * This library is free software; you can redistribute it and/or modify it \r\n * under the terms of the GNU Lesser General Public License as published by \r\n * the Free Software Foundation; either version 2.1 of the License, or \r\n * (at your option) any later version.\r\n *\r\n * This library is distributed in the hope that it will be useful, but \r\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \r\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public \r\n * License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, \r\n * USA.  \r\n *\r\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc. \r\n * in the United States and other countries.]\r\n *\r\n * ---------------\r\n * BenchTest.java\r\n * ---------------\r\n * Author: Volker Berlin\r\n * \r\n */\r\npackage smallsql.junit;\r\n\r\nimport java.sql.*;\r\n\r\npublic class BenchTest\r\n{\r\n    static byte[] byteArray = {23, 34, 67 };\r\n    static byte[] largeByteArray = new byte[4000];\r\n    \r\n    static String driverClassName = \"smallsql.database.SSDriver\";\r\n    static String userName        = \"sa\";\r\n    static String password        = \"\";\r\n    static String jdbcUrl         = \"jdbc:smallsql:AllTests\";\r\n    static int    rowCount        = 10000;\r\n    \r\n    static Connection con;\r\n    static final String tableName = \"BenchTest2\";\r\n        \r\n    \r\n    public static void main(String[] args) throws SQLException{\r\n        for(int i=0; i<args.length;){\r\n            String option = args[i++];\r\n            if      (option.equals(\"-driver\")  ) driverClassName = args[i++];\r\n            else if (option.equals(\"-user\")    ) userName = args[i++];\r\n            else if (option.equals(\"-password\")) password = args[i++];\r\n            else if (option.equals(\"-url\")     ) jdbcUrl  = args[i++];\r\n            else if (option.equals(\"-rowcount\")) rowCount = Integer.parseInt(args[i++]);\r\n            else if (option.equals(\"-?\") | option.equals(\"-help\")){\r\n                System.out.println( \"Valid options are :\\n\\t-driver\\n\\t-url\\n\\t-user\\n\\t-password\\n\\t-rowcount\");\r\n                System.exit(0);\r\n            }\r\n            else {System.out.println(\"Option \" + option + \" is ignored\");i++;}\r\n        }\r\n        System.out.println( \"Driver:  \\t\" + driverClassName);\r\n        System.out.println( \"Username:\\t\" + userName);\r\n        System.out.println( \"Password:\\t\" + password);\r\n        System.out.println( \"JDBC URL:\\t\" + jdbcUrl);\r\n        System.out.println( \"Row Count:\\t\" + rowCount);\r\n        System.out.println();\r\n        try{\r\n            Class.forName(driverClassName).newInstance();\r\n            con = DriverManager.getConnection( jdbcUrl, userName,password);\r\n            System.out.println( con.getMetaData().getDriverName() + \" \" + con.getMetaData().getDriverVersion());\r\n            System.out.println();\r\n            createTestTable( con );\r\n            test_InsertClassic( con );\r\n            test_DeleteAll( con );\r\n            test_InsertEmptyRows( con );\r\n            test_DeleteRows( con );\r\n            test_InsertRows( con );\r\n            test_RowRequestPages( con );\r\n            test_UpdateRows( con );\r\n            test_UpdateRowsPrepare( con );\r\n            test_UpdateRowsPrepareSP( con );\r\n            test_UpdateRowsPrepareBatch( con );\r\n            test_Scroll_getXXX( con );\r\n            test_UpdateLargeBinary( con );\r\n            test_UpdateLargeBinaryWithSP( con );\r\n        }catch(Exception e){\r\n            e.printStackTrace();\r\n        }finally{\r\n            if (con != null){\r\n                //dropTestTable( con );\r\n                con.close();\r\n            }\r\n        }\r\n    }\r\n    \r\n    \r\n    \r\n    /**\r\n      *  1. Test\r\n      *  Insert rows with default values with a classic insert statement.\r\n      */  \r\n    static void test_InsertClassic(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test insert rows with default values with a classic insert statement: \" + rowCount + \" rows\");\r\n        \r\n        try{\r\n            Statement st = con.createStatement( ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE );\r\n            long time = -System.currentTimeMillis();\r\n            for (int i=0; i<rowCount; i++){\r\n                st.execute(\"INSERT INTO \" + tableName + \"(i) VALUES(\" + i +\")\");\r\n            }\r\n            time += System.currentTimeMillis();\r\n            ResultSet rs = st.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n            rs.next();\r\n            int count = rs.getInt(1);\r\n            if (count != rowCount)\r\n                System.out.println( \"  Failed: Only \" + count + \" rows were inserted.\");\r\n            else System.out.println( \"  Test time: \" + time + \" ms\");\r\n            st.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }\r\n    \r\n    \r\n    \r\n    /**\r\n      *  2. Test\r\n      *  Delete all rows with a single statement.\r\n      */  \r\n    static void test_DeleteAll(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test delete all rows: \" + rowCount + \" rows\");\r\n        \r\n        try{\r\n            long time = -System.currentTimeMillis();\r\n            Statement st = con.createStatement();\r\n            st.execute(\"DELETE FROM \" + tableName);\r\n            time += System.currentTimeMillis();\r\n            System.out.println( \"  Test time: \" + time + \" ms\");\r\n            st.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }\r\n    \r\n    \r\n    \r\n    /**\r\n      *  3. Test\r\n      *  Insert only empty rows with the default values of the row with the method insertRow().\r\n      */  \r\n    static void test_InsertEmptyRows(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test insert empty rows with insertRow(): \" + rowCount + \" rows\");\r\n        \r\n        try{\r\n            Statement st = con.createStatement( ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE );\r\n            ResultSet rs = st.executeQuery(\"SELECT * FROM \"+tableName);\r\n            long time = -System.currentTimeMillis();\r\n            for (int i=0; i<rowCount; i++){\r\n                rs.moveToInsertRow();\r\n                rs.insertRow();\r\n            }\r\n            time += System.currentTimeMillis();\r\n            rs = st.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n            rs.next();\r\n            int count = rs.getInt(1);\r\n            if (count != rowCount)\r\n                 System.out.println( \"  Failed: Only \" + count + \" rows were inserted.\");\r\n            else System.out.println( \"  Test time: \" + time + \" ms\");\r\n            st.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }\r\n    \r\n    \r\n    \r\n    /**\r\n      *  4. Test\r\n      *  Delete rows with the method deleteRow().\r\n      */  \r\n    static void test_DeleteRows(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test delete rows with deleteRow(): \" + rowCount + \" rows\");\r\n        \r\n        try{\r\n            Statement st1 = con.createStatement();\r\n            ResultSet rs = st1.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n            rs.next();\r\n            int count = rs.getInt(1);\r\n            if (count != rowCount){\r\n                // There are not the correct count of rows.\r\n                if (count == 0){\r\n                    createTestDataWithClassicInsert( con );\r\n                    rs = st1.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n                    rs.next();\r\n                    count = rs.getInt(1);\r\n                }\r\n                if (count != rowCount){\r\n                    System.out.println( \"  Failed: Only \" + (rowCount-count) + \" rows were deleted.\");\r\n                    return;\r\n                }\r\n            }\r\n            st1.close();\r\n            \r\n            Statement st = con.createStatement( ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE );\r\n            rs = st.executeQuery(\"SELECT * FROM \"+tableName);\r\n            long time = -System.currentTimeMillis();\r\n            for (int i=0; i<rowCount; i++){\r\n                rs.next();\r\n                rs.deleteRow();\r\n            }\r\n            time += System.currentTimeMillis();\r\n            rs = st.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n            rs.next();\r\n            count = rs.getInt(1);\r\n            if (count != 0)\r\n                 System.out.println( \"  Failed: Only \" + (rowCount-count) + \" rows were deleted.\");\r\n            else System.out.println( \"  Test time: \" + time + \" ms\");\r\n            st.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }\r\n    \r\n    \r\n    \r\n    /**\r\n      *  5. Test\r\n      *  Insert rows with the method insertRow().\r\n      */  \r\n    static void test_InsertRows(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test insert rows with insertRow(): \" + rowCount + \" rows\");\r\n        \r\n        try{\r\n            Statement st = con.createStatement( ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE );\r\n            ResultSet rs = st.executeQuery(\"SELECT * FROM \" + tableName);\r\n            long time = -System.currentTimeMillis();\r\n            for (int i=0; i<rowCount; i++){\r\n                rs.moveToInsertRow();\r\n\t            rs.updateBytes (  \"bi\", byteArray );\r\n\t            rs.updateString(  \"c\" , \"Test\" );\r\n\t            rs.updateDate  (  \"d\" , new Date( System.currentTimeMillis() ) );\r\n\t            rs.updateFloat (  \"de\", (float)1234.56789 );\r\n\t            rs.updateFloat (  \"f\" , (float)9876.54321 );\r\n\t            rs.updateBytes (  \"im\", largeByteArray );\r\n\t            rs.updateInt   (  \"i\" , i );\r\n\t            rs.updateDouble(  \"m\" , 23.45 );\r\n\t            rs.updateDouble(  \"n\" , 567.45 );\r\n\t            rs.updateFloat (  \"r\" , (float)78.89 );\r\n\t            rs.updateTime  (  \"sd\", new Time( System.currentTimeMillis() ) );\r\n\t            rs.updateShort (  \"si\", (short)i );\r\n\t            rs.updateFloat (  \"sm\", (float)34.56 );\r\n\t            rs.updateString(  \"sy\", \"sysname (30) NULL\" );\r\n\t            rs.updateString(  \"t\" , \"ntext NULL, sample to save in the field\" );\r\n\t            rs.updateByte  (  \"ti\", (byte)i );\r\n\t            rs.updateBytes (  \"vb\", byteArray );\r\n\t            rs.updateString(  \"vc\", \"nvarchar (255) NULL\" );\r\n                rs.insertRow();\r\n            }\r\n            time += System.currentTimeMillis();\r\n            rs = st.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n            rs.next();\r\n            int count = rs.getInt(1);\r\n            if (count != rowCount){\r\n                  st.execute(\"DELETE FROM \" + tableName);\r\n                  System.out.println( \"  Failed: Only \" + count + \" rows were inserted.\");\r\n            }else System.out.println( \"  Test time: \" + time + \" ms\");\r\n            st.close();\r\n        }catch(Exception e){\r\n        \te.printStackTrace();\r\n            try{\r\n                // reset for the next test\r\n                Statement st = con.createStatement();\r\n                st.execute(\"DELETE FROM \" + tableName);\r\n                st.close();\r\n            }catch(Exception ee){/* ignore it */}\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }\r\n    \r\n    \r\n    \r\n    /**\r\n      *  6. Test\r\n      *  Request one page of rows from a large ResultSet.\r\n      */  \r\n    static void test_RowRequestPages(Connection con){\r\n        int pages = 100; \r\n        int rows  = rowCount / pages;\r\n        System.out.println();\r\n        System.out.println( \"Test request row pages : \" + pages + \" pages, \" +rows + \" rows per page\");\r\n        try{\r\n            Statement st1 = con.createStatement();\r\n            ResultSet rs = st1.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n            rs.next();\r\n            int count = rs.getInt(1);\r\n            if (count != rowCount){\r\n                // There are not the correct count of rows.\r\n                if (count == 0){\r\n                    createTestDataWithClassicInsert( con );\r\n                    rs = st1.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n                    rs.next();\r\n                    count = rs.getInt(1);\r\n                }\r\n                if (count != rowCount){\r\n                    System.out.println( \"  Failed: Only \" + (rowCount-count) + \" rows were found.\");\r\n                    return;\r\n                }\r\n            }\r\n            st1.close();\r\n            \r\n            long time = -System.currentTimeMillis();\r\n            Statement st = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_READ_ONLY);\r\n            st.setFetchSize( rows );\r\n            for (int i=0; i<pages; i++){\r\n                rs = st.executeQuery(\"SELECT * FROM \" + tableName);\r\n                rs.absolute( i*rows+1 );\r\n                for (int r=1; r<rows; r++){\r\n                    // only (rows-1) rows because absolute has already the first row\r\n                    if (!rs.next()){\r\n                        System.out.println( \"  Failed: No rows were found at page \" + i + \" page and row \" + r);\r\n                        return;\r\n                    }\r\n                    int col_i = rs.getInt(\"i\");\r\n                    if (col_i != (i*rows+r)){\r\n                        System.out.println( \"  Failed: Wrong row \" + col_i + \", it should be row \" + (i*rows+r));\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n            time += System.currentTimeMillis();\r\n            System.out.println( \"  Test time: \" + time + \" ms\");\r\n            st.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }\r\n\r\n    \r\n    \r\n    /**\r\n      *  7. Test\r\n      *  Update rows with the method updateRow().\r\n      */  \r\n    static void test_UpdateRows(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test update rows with updateRow(): \" + rowCount + \" rows\");\r\n        \r\n        try{\r\n            Statement st = con.createStatement( ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE );\r\n            ResultSet rs = st.executeQuery(\"SELECT * FROM \" + tableName);\r\n            int colCount = rs.getMetaData().getColumnCount();\r\n            long time = -System.currentTimeMillis();\r\n            int count = 0;\r\n            while(rs.next()){\r\n                for (int i=2; i<=colCount; i++){\r\n                    rs.updateObject( i, rs.getObject(i) );\r\n                }\r\n                rs.updateRow();\r\n                count++;\r\n            }\r\n            time += System.currentTimeMillis();\r\n            if (count != rowCount)\r\n                 System.out.println( \"  Failed: Only \" + count + \" rows were updated.\");\r\n            else System.out.println( \"  Test time: \" + time + \" ms\");\r\n            st.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\" + e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }\r\n    \r\n    \r\n    \r\n    /**\r\n      *  8. Test\r\n      *  Update rows with a PreparedStatement.\r\n      */  \r\n    static void test_UpdateRowsPrepare(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test update rows with a PreparedStatement: \" + rowCount + \" rows\");\r\n        try{\r\n            PreparedStatement pr = con.prepareStatement( \"UPDATE \" + tableName + \" SET bi=?,c=?,d=?,de=?,f=?,im=?,i=?,m=?,n=?,r=?,sd=?,si=?,sm=?,sy=?,t=?,ti=?,vb=?,vc=? WHERE i=?\" );\r\n            long time = -System.currentTimeMillis();\r\n            for (int i=0; i<rowCount; i++){\r\n\t            pr.setBytes (  1, byteArray );\r\n\t            pr.setString(  2 , \"Test\" );\r\n\t            pr.setDate  (  3 , new Date( System.currentTimeMillis() ) );\r\n\t            pr.setFloat (  4, (float)1234.56789 );\r\n\t            pr.setFloat (  5 , (float)9876.54321 );\r\n\t            pr.setBytes (  6, largeByteArray );\r\n\t            pr.setInt   (  7 , i );\r\n\t            pr.setDouble(  8 , 23.45 );\r\n\t            pr.setDouble(  9 , 567.45 );\r\n\t            pr.setFloat (  10 , (float)78.89 );\r\n\t            pr.setTime  (  11, new Time( System.currentTimeMillis() ) );\r\n\t            pr.setShort (  12, (short)23456 );\r\n\t            pr.setFloat (  13, (float)34.56 );\r\n\t            pr.setString(  14, \"sysname (30) NULL\" );\r\n\t            pr.setString(  15 , \"text NULL\" );\r\n\t            pr.setByte  (  16, (byte)28 );\r\n\t            pr.setBytes (  17, byteArray );\r\n\t            pr.setString(  18, \"varchar (255) NULL\" );\r\n\t            pr.setInt   (  19 , i );\r\n                int updateCount = pr.executeUpdate();\r\n                if (updateCount != 1){\r\n                    System.out.println( \"  Failed: Update count should be 1 but it is \" + updateCount + \".\");\r\n                    return;\r\n                }\r\n            }\r\n            time += System.currentTimeMillis();\r\n            System.out.println( \"  Test time: \" + time + \" ms\");\r\n            pr.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }\r\n    \r\n    \r\n    \r\n    /**\r\n      *  9. Test\r\n      *  Update rows with a PreparedStatement and a stored procedure.\r\n      */  \r\n    static void test_UpdateRowsPrepareSP(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test update rows with a PreparedStatement and a stored procedure: \" + rowCount + \" rows\");\r\n        \r\n        try{\r\n            Statement st = con.createStatement();\r\n            try{st.execute(\"drop procedure sp_\"+tableName);}catch(Exception e){/* ignore it */}\r\n            st.execute(\"create procedure sp_\"+tableName+\" (@bi binary,@c nchar(255),@d datetime,@de decimal,@f float,@im image,@i int,@m money,@n numeric(18, 0),@r real,@sd smalldatetime,@si smallint,@sm smallmoney,@sy sysname,@t ntext,@ti tinyint,@vb varbinary(255),@vc nvarchar(255)) as UPDATE \" + tableName + \" SET bi=@bi,c=@c,d=@d,de=@de,f=@f,im=@im,i=@i,m=@m,n=@n,r=@r,sd=@sd,si=@si,sm=@sm,sy=@sy,t=@t,ti=@ti,vb=@vb,vc=@vc WHERE i=@i\");\r\n\r\n            PreparedStatement pr = con.prepareStatement( \"exec sp_\" + tableName + \" ?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?\" );\r\n            long time = -System.currentTimeMillis();\r\n            for (int i=0; i<rowCount; i++){\r\n\t            pr.setBytes (  1, byteArray );\r\n\t            pr.setString(  2 , \"Test\" );\r\n\t            pr.setDate  (  3 , new Date( System.currentTimeMillis() ) );\r\n\t            pr.setFloat (  4, (float)1234.56789 );\r\n\t            pr.setFloat (  5 , (float)9876.54321 );\r\n\t            pr.setBytes (  6, largeByteArray );\r\n\t            pr.setInt   (  7 , i );\r\n\t            pr.setDouble(  8 , 23.45 );\r\n\t            pr.setDouble(  9 , 567.45 );\r\n\t            pr.setFloat (  10 , (float)78.89 );\r\n\t            pr.setTime  (  11, new Time( System.currentTimeMillis() ) );\r\n\t            pr.setShort (  12, (short)23456 );\r\n\t            pr.setFloat (  13, (float)34.56 );\r\n\t            pr.setString(  14, \"sysname (30) NULL\" );\r\n\t            pr.setString(  15 , \"text NULL\" );\r\n\t            pr.setByte  (  16, (byte)28 );\r\n\t            pr.setBytes (  17, byteArray );\r\n\t            pr.setString(  18, \"varchar (255) NULL\" );\r\n                int updateCount = pr.executeUpdate();\r\n                if (updateCount != 1){\r\n                    System.out.println( \"  Failed: Update count should be 1 but it is \" + updateCount + \".\");\r\n                    return;\r\n                }\r\n            }\r\n            time += System.currentTimeMillis();\r\n            System.out.println( \"  Test time: \" + time + \" ms\");\r\n            st.execute(\"drop procedure sp_\"+tableName);\r\n            st.close();\r\n            pr.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }\r\n    \r\n\r\n    \r\n    /**\r\n      *  10. Test\r\n      *  Update rows with a PreparedStatement and Batch.\r\n      */  \r\n    static void test_UpdateRowsPrepareBatch(Connection con){\r\n        int batchSize = 10;\r\n        int batches = rowCount / batchSize;\r\n        System.out.println();\r\n        System.out.println( \"Test update rows with PreparedStatement and Batches: \" + batches + \" batches, \" + batchSize + \" batch size\");\r\n        \r\n        try{\r\n            PreparedStatement pr = con.prepareStatement( \"UPDATE \" + tableName + \" SET bi=?,c=?,d=?,de=?,f=?,im=?,i=?,m=?,n=?,r=?,sd=?,si=?,sm=?,sy=?,t=?,ti=?,vb=?,vc=? WHERE i=?\" );\r\n            long time = -System.currentTimeMillis();\r\n            for (int i=0; i<batches; i++){\r\n                for (int r=0; r<batchSize; r++){\r\n\t                pr.setBytes (  1, byteArray );\r\n\t                pr.setString(  2 , \"Test\" );\r\n\t                pr.setDate  (  3 , new Date( System.currentTimeMillis() ) );\r\n\t                pr.setFloat (  4, (float)1234.56789 );\r\n\t                pr.setFloat (  5 , (float)9876.54321 );\r\n\t                pr.setBytes (  6, largeByteArray );\r\n\t                pr.setInt   (  7 , i*batchSize + r );\r\n\t                pr.setDouble(  8 , 23.45 );\r\n\t                pr.setDouble(  9 , 567.45 );\r\n\t                pr.setFloat (  10 , (float)78.89 );\r\n\t                pr.setTime  (  11, new Time( System.currentTimeMillis() ) );\r\n\t                pr.setShort (  12, (short)23456 );\r\n\t                pr.setFloat (  13, (float)34.56 );\r\n\t                pr.setString(  14, \"sysname (30) NULL\" );\r\n\t                pr.setString(  15 , \"text NULL\" );\r\n\t                pr.setByte  (  16, (byte)28 );\r\n\t                pr.setBytes (  17, byteArray );\r\n\t                pr.setString(  18, \"varchar (255) NULL\" );\r\n\t                pr.setInt   (  19 , i );\r\n\t                pr.addBatch();\r\n\t            }\r\n                int[] updateCount = pr.executeBatch();\r\n                if (updateCount.length != batchSize){\r\n                    System.out.println( \"  Failed: Update count size should be \" + batchSize + \" but it is \" + updateCount.length + \".\");\r\n                    return;\r\n                }\r\n            }\r\n            time += System.currentTimeMillis();\r\n            System.out.println( \"  Test time: \" + time + \" ms\");\r\n            pr.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }\r\n     \r\n    \r\n    \r\n    /**\r\n      *  11. Test\r\n      *  Scroll and call the getXXX methods for every columns.\r\n      */  \r\n    static void test_Scroll_getXXX(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test scroll and call the getXXX methods for every columns: \" + rowCount + \" rows\");\r\n        \r\n        try{\r\n            Statement st = con.createStatement();\r\n            long time = -System.currentTimeMillis();\r\n            ResultSet rs = st.executeQuery(\"SELECT * FROM \" + tableName);\r\n            for (int i=0; i<rowCount; i++){\r\n                    rs.next();\r\n\t                rs.getInt   (  1 );\r\n\t                rs.getBytes (  2 );\r\n\t                rs.getString(  3 );\r\n\t                rs.getDate  (  4 );\r\n\t                rs.getFloat (  5 );\r\n\t                rs.getFloat (  6 );\r\n\t                rs.getBytes (  7 );\r\n\t                rs.getInt   (  8 );\r\n\t                rs.getDouble(  9 );\r\n\t                rs.getDouble(  10 );\r\n\t                rs.getFloat (  11 );\r\n\t                rs.getTime  (  12 );\r\n\t                rs.getShort (  13 );\r\n\t                rs.getFloat (  14 );\r\n\t                rs.getString(  15 );\r\n\t                rs.getString(  16 );\r\n\t                rs.getByte  (  17 );\r\n\t                rs.getBytes (  18 );\r\n\t                rs.getString(  19 );\r\n            }\r\n            time += System.currentTimeMillis();\r\n            System.out.println( \"  Test time: \" + time + \" ms\");\r\n            st.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }\r\n     \r\n    \r\n    /**\r\n      *  12. Test\r\n      *  Update large binary data.\r\n      */  \r\n    static void test_UpdateLargeBinary(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test update large binary data: \" + rowCount + \"KB bytes\");\r\n        \r\n        try{\r\n            java.io.FileOutputStream fos = new java.io.FileOutputStream(tableName+\".bin\");\r\n            byte bytes[] = new byte[1024];\r\n            for(int i=0; i<rowCount; i++){\r\n                fos.write(bytes);\r\n            }\r\n            fos.close();\r\n            java.io.FileInputStream fis = new java.io.FileInputStream(tableName+\".bin\");\r\n            long time = -System.currentTimeMillis();\r\n            PreparedStatement pr = con.prepareStatement(\"Update \" + tableName + \" set im=? WHERE pr=1\");\r\n            pr.setBinaryStream( 1, fis, rowCount*1024 );\r\n            pr.execute();\r\n            pr.close();\r\n            time += System.currentTimeMillis();\r\n            System.out.println( \"  Test time: \" + time + \" ms\");\r\n            fis.close();\r\n            java.io.File file = new java.io.File(tableName+\".bin\");\r\n            file.delete();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }\r\n     \r\n    \r\n\r\n    \r\n    /**\r\n      *  12. Test\r\n      *  Update large binary data with a SP.\r\n      */  \r\n    static void test_UpdateLargeBinaryWithSP(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test update large binary data with a SP: \" + rowCount + \"KB bytes\");\r\n        \r\n        try{\r\n            java.io.FileOutputStream fos = new java.io.FileOutputStream(tableName+\".bin\");\r\n            byte bytes[] = new byte[1024];\r\n            for(int i=0; i<rowCount; i++){\r\n                fos.write(bytes);\r\n            }\r\n            fos.close();\r\n            java.io.FileInputStream fis = new java.io.FileInputStream(tableName+\".bin\");\r\n            long time = -System.currentTimeMillis();\r\n            Statement st = con.createStatement();\r\n            st.execute(\"CREATE PROCEDURE #UpdateLargeBinary(@im image) as Update \" + tableName + \" set im=@im WHERE pr=2\");\r\n            PreparedStatement pr = con.prepareStatement(\"exec #UpdateLargeBinary ?\");\r\n            pr.setBinaryStream( 1, fis, rowCount*1024 );\r\n            pr.execute();\r\n            st.execute(\"DROP PROCEDURE #UpdateLargeBinary\");\r\n            st.close();\r\n            pr.close();\r\n            time += System.currentTimeMillis();\r\n            System.out.println( \"  Test time: \" + time + \" ms\");\r\n            fis.close();\r\n            java.io.File file = new java.io.File(tableName+\".bin\");\r\n            file.delete();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }\r\n     \r\n    \r\n\r\n    \r\n    /**\r\n      *  Create a new Table for testing\r\n      */  \r\n    static void createTestTable(Connection con) throws SQLException{\r\n            Statement st;\r\n            st = con.createStatement();\r\n            //delete old table\r\n            dropTestTable( con );\r\n\r\n            //create table\r\n            st.execute(\r\n                \"CREATE TABLE \" + tableName + \" (\"+\r\n\t            \"    pr  numeric IDENTITY,\"+\r\n\t            \"    bi  binary (255) NULL ,\"+\r\n\t            \"    c   nchar (255) NULL ,\"+\r\n\t            \"    d   datetime NULL ,\"+\r\n\t            \"    de  decimal(18, 0) NULL ,\"+\r\n\t            \"    f   float NULL ,\"+\r\n\t            \"    im  image NULL ,\"+\r\n\t            \"    i   int NULL ,\"+\r\n\t            \"    m   money NULL ,\"+\r\n\t            \"    n   numeric(18, 0) NULL ,\"+\r\n\t            \"    r   real NULL ,\"+\r\n\t            \"    sd  smalldatetime NULL ,\"+\r\n\t            \"    si  smallint NULL ,\"+\r\n\t            \"    sm  smallmoney NULL ,\"+\r\n\t            \"    sy  sysname NULL ,\"+\r\n\t            \"    t   ntext NULL ,\"+\r\n\t            \"    ti  tinyint NULL ,\"+\r\n\t            \"    vb  varbinary (255) NULL ,\"+\r\n\t            \"    vc  nvarchar (255) NULL, \"+\r\n\t            \"CONSTRAINT PK_BenchTest2 PRIMARY KEY CLUSTERED (pr) \"+\r\n\t            \")\");\r\n\t        st.close();  \r\n    }\r\n    \r\n\r\n    \r\n    static void deleteTestTable(Connection con){\r\n        try{\r\n            Statement st = con.createStatement();\r\n            st.execute(\"DELETE FROM \" + tableName);\r\n            st.close();\r\n        }catch(Exception e){/* ignore it */}\r\n    }\r\n\r\n    static void dropTestTable(Connection con){\r\n        try{\r\n            Statement st = con.createStatement();\r\n            st.execute(\"drop table \" + tableName);\r\n            st.close();\r\n        }catch(Exception e){/* ignore it */}\r\n    }\r\n    \r\n    // create test data after the insert test is failed\r\n    static void createTestDataWithClassicInsert(Connection con) throws SQLException{\r\n        String sql = \"INSERT INTO \" + tableName + \"(bi,c,d,de,f,im,i,m,n,r,si,sd,sm,sy,t,ti,vb,vc) VALUES(0x172243,'Test','20010101',1234.56789,9876.54321,0x\";\r\n        for(int i=0; i<largeByteArray.length; i++){\r\n            sql += \"00\";\r\n        }\r\n        Statement st = con.createStatement();\r\n        for (int i=0; i<rowCount; i++){\r\n            st.execute(sql + \",\"+i+\",23.45,567.45,78.89,\"+i+\",'11:11:11',34.56,'sysname (30) NULL','ntext NULL, sample to save in the field',\"+(i & 0xFF)+\",0x172243,'nvarchar (255) NULL')\"  );\r\n        }\r\n        st.close();\r\n    }\r\n}"},{"path":"/src/smallsql/junit/TestOperatoren.java","source":"/* =============================================================\r\n * SmallSQL : a free Java DBMS library for the Java(tm) platform\r\n * =============================================================\r\n *\r\n * (C) Copyright 2004-2006, by Volker Berlin.\r\n *\r\n * Project Info:  http://www.smallsql.de/\r\n *\r\n * This library is free software; you can redistribute it and/or modify it \r\n * under the terms of the GNU Lesser General Public License as published by \r\n * the Free Software Foundation; either version 2.1 of the License, or \r\n * (at your option) any later version.\r\n *\r\n * This library is distributed in the hope that it will be useful, but \r\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \r\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public \r\n * License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, \r\n * USA.  \r\n *\r\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc. \r\n * in the United States and other countries.]\r\n *\r\n * ---------------\r\n * TestOperatoren.java\r\n * ---------------\r\n * Author: Volker Berlin\r\n * \r\n */\r\npackage smallsql.junit;\r\n\r\nimport junit.framework.*;\r\nimport java.sql.*;\r\nimport java.math.*;\r\n\r\npublic class TestOperatoren extends BasicTestCase {\r\n\r\n    private TestValue testValue;\r\n\r\n    private static final String table = \"table_functions\";\r\n\r\n    private static final TestValue[] TESTS = new TestValue[]{\r\n        a(\"tinyint\"           , new Byte( (byte)3),     new Byte( (byte)4)),\r\n        a(\"byte\"              , new Byte( (byte)3),     new Byte( (byte)4)),\r\n        a(\"smallint\"          , new Short( (short)3),   new Short( (short)4)),\r\n        a(\"int\"               , new Integer(3),         new Integer(4)),\r\n        a(\"bigint\"            , new Long(3),            new Long(4)),\r\n        a(\"real\"              , new Float(3.45),        new Float(4.56)),\r\n        a(\"float\"             , new Float(3.45),        new Float(4.56)),\r\n        a(\"double\"            , new Double(3.45),       new Double(4.56)),\r\n        a(\"smallmoney\"        , new Float(3.45),        new Float(4.56)),\r\n        a(\"money\"             , new Float(3.45),        new Float(4.56)),\r\n        a(\"money\"             , new Double(3.45),       new Double(4.56)),\r\n        a(\"numeric(19,2)\"     , new BigDecimal(\"3.45\"), new BigDecimal(\"4.56\")),\r\n        a(\"decimal(19,2)\"     , new BigDecimal(\"3.45\"), new BigDecimal(\"4.56\")),\r\n        a(\"varnum(28,2)\"      , new BigDecimal(\"2.34\"), new BigDecimal(\"3.45\")),\r\n        a(\"number(28,2)\"      , new BigDecimal(\"2.34\"), new BigDecimal(\"3.45\")),\r\n        a(\"varchar(100)\"      , new String(\"abc\"),      new String(\"qwert\")),\r\n        a(\"varchar(60000)\"    , new String(new char[43210]),      new String(\"qwert\")),\r\n        a(\"nvarchar(100)\"     , new String(\"abc\"),      new String(\"qwert\")),\r\n        a(\"varchar2(100)\"     , new String(\"abc\"),      new String(\"qwert\")),\r\n        a(\"nvarchar2(100)\"    , new String(\"abc\"),      new String(\"qwert\")),\r\n        a(\"character(100)\"    , new String(\"abc\"),      new String(\"qwert\")),\r\n        a(\"char(100)\"         , new String(\"abc\"),      new String(\"qwert\")),\r\n        a(\"nchar(100)\"        , new String(\"abc\"),      new String(\"qwert\")),\r\n        a(\"text\"              , new String(\"abc\"),      new String(\"qwert\")),\r\n        a(\"ntext\"             , new String(\"abc\"),      new String(\"qwert\")),\r\n        a(\"date\"              , new Date(99, 1,1),      new Date(99, 2,2)),\r\n        a(\"time\"              , new Time(9, 1,1),       new Time(9, 2,2)),\r\n        a(\"timestamp\"         , new Timestamp(99, 1,1,0,0,0,0),      new Timestamp(99, 2,2,0,0,0,0)),\r\n        a(\"datetime\"          , new Timestamp(99, 1,1,0,0,0,0),      new Timestamp(99, 2,2,0,0,0,0)),\r\n        a(\"smalldatetime\"     , new Timestamp(99, 1,1,0,0,0,0),      new Timestamp(99, 2,2,0,0,0,0)),\r\n        a(\"binary(100)\"       , new byte[]{12, 45, 1},  new byte[]{12, 45, 2, 56, 89}),\r\n        a(\"varbinary(100)\"    , new byte[]{12, 45, 1},  new byte[]{12, 45, 2, 56, 89}),\r\n        a(\"varbinary(60000)\"  , new byte[54321],        new byte[]{12, 45, 2, 56, 89}),\r\n        a(\"raw(100)\"          , new byte[]{12, 45, 1},  new byte[]{12, 45, 2, 56, 89}),\r\n        a(\"long raw\"          , new byte[]{12, 45, 1},  new byte[]{12, 45, 2, 56, 89}),\r\n        a(\"longvarbinary\"     , new byte[]{12, 45, 1},  new byte[]{12, 45, 2, 56, 89}),\r\n        a(\"blob\"              , new byte[]{12, 45, 1},  new byte[]{12, 45, 2, 56, 89}),\r\n        a(\"image\"             , new byte[]{12, 45, 1},  new byte[]{12, 45, 2, 56, 89}),\r\n        a(\"boolean\"           , Boolean.FALSE,          Boolean.TRUE),\r\n        a(\"bit\"               , Boolean.FALSE,          Boolean.TRUE),\r\n        a(\"uniqueidentifier\"  , \"12345678-3445-3445-3445-1234567890ab\",      \"12345679-3445-3445-3445-1234567890ac\"),\r\n    };\r\n\r\n\r\n    TestOperatoren(TestValue testValue){\r\n        super(testValue.dataType);\r\n        this.testValue = testValue;\r\n    }\r\n\r\n    public void tearDown(){\r\n        try{\r\n            Connection con = AllTests.getConnection();\r\n            Statement st = con.createStatement();\r\n            st.execute(\"drop table \" + table);\r\n            st.close();\r\n        }catch(Throwable e){\r\n            //e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    public void setUp(){\r\n        tearDown();\r\n        try{\r\n            Connection con = AllTests.getConnection();\r\n            Statement st = con.createStatement();\r\n            st.execute(\"create table \" + table + \"(a \" + testValue.dataType +\", b \" + testValue.dataType + \")\");\r\n            st.close();\r\n            PreparedStatement pr = con.prepareStatement(\"INSERT into \" + table + \"(a,b) Values(?,?)\");\r\n\r\n            pr.setObject( 1, testValue.small);\r\n            pr.setObject( 2, testValue.large);\r\n            pr.execute();\r\n\r\n            pr.setObject( 1, testValue.small);\r\n            pr.setObject( 2, testValue.small);\r\n            pr.execute();\r\n\r\n            pr.setObject( 1, testValue.large);\r\n            pr.setObject( 2, testValue.large);\r\n            pr.execute();\r\n\r\n            pr.setObject( 1, testValue.large);\r\n            pr.setObject( 2, testValue.small);\r\n            pr.execute();\r\n\r\n            pr.setObject( 1, null);\r\n            pr.setObject( 2, testValue.small);\r\n            pr.execute();\r\n\r\n            pr.setObject( 1, testValue.small);\r\n            pr.setObject( 2, null);\r\n            pr.execute();\r\n\r\n            pr.setObject( 1, null);\r\n            pr.setObject( 2, null);\r\n            pr.execute();\r\n            pr.close();\r\n        }catch(Throwable e){\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n\r\n    public void runTest() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        Statement st = con.createStatement();\r\n        ResultSet rs;\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where 1 = 0\");\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a = b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertEqualsObject( \"Values not equals\", rs.getObject(1), rs.getObject(2), false);\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertEqualsObject( \"Values not equals\", rs.getObject(1), rs.getObject(2), false);\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a <= b and b <= a\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertEqualsObject( \"Values not equals\", rs.getObject(1), rs.getObject(2), false);\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertEqualsObject( \"Values not equals\", rs.getObject(1), rs.getObject(2), false);\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where (a > (b))\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a >= b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where not (a >= b)\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a < b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a < b or a>b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a <= b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        rs = st.executeQuery(\"Select * from \" + table + \" where a <> b\");\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\r\n        PreparedStatement pr = con.prepareStatement(\"Select * from \" + table + \" where a between ? and ?\");\r\n        pr.setObject( 1, testValue.small);\r\n        pr.setObject( 2, testValue.large);\r\n        rs = pr.executeQuery();\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n        assertFalse( \"To many rows\", rs.next() );\r\n\t\tpr.close();\r\n\r\n\t\tpr = con.prepareStatement(\"Select * from \" + table + \" where a not between ? and ?\");\r\n\t\tpr.setObject( 1, testValue.small);\r\n\t\tpr.setObject( 2, testValue.large);\r\n\t\trs = pr.executeQuery();\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertFalse( \"To many rows\", rs.next() );\r\n\t\tpr.close();\r\n\r\n\t\tpr = con.prepareStatement(\"Select * from \" + table + \" where a in(?,?)\");\r\n\t\tpr.setObject( 1, testValue.small);\r\n\t\tpr.setObject( 2, testValue.large);\r\n\t\trs = pr.executeQuery();\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n        assertTrue( \"To few rows\", rs.next() );\r\n\t\tassertTrue( \"To few rows\", rs.next() );\r\n\t\tassertFalse( \"To many rows\", rs.next() );\r\n\t\tpr.close();\r\n\r\n\t\tpr = con.prepareStatement(\"Select * from \" + table + \" where a not in(?,?)\");\r\n\t\tpr.setObject( 1, testValue.small);\r\n\t\tpr.setObject( 2, testValue.large);\r\n\t\trs = pr.executeQuery();\r\n\t\tassertTrue( \"To few rows\", rs.next());\r\n\t\tassertTrue( \"To few rows\", rs.next());\r\n\t\tassertFalse( \"To many rows\", rs.next() );\r\n\t\tpr.close();\r\n\r\n        st.close();\r\n    }\r\n\r\n    public static Test suite() throws Exception{\r\n        TestSuite theSuite = new TestSuite(\"Operatoren\");\r\n        for(int i=0; i<TESTS.length; i++){\r\n            theSuite.addTest(new TestOperatoren( TESTS[i] ) );\r\n        }\r\n        return theSuite;\r\n    }\r\n\r\n    public static void main(String[] argv) {\r\n        junit.swingui.TestRunner.main(new String[]{TestOperatoren.class.getName()});\r\n    }\r\n\r\n\r\n\r\n    private static TestValue a(String dataType, Object small, Object large){\r\n        TestValue value = new TestValue();\r\n        value.dataType  = dataType;\r\n        value.small     = small;\r\n        value.large     = large;\r\n        return value;\r\n    }\r\n\r\n    private static class TestValue{\r\n        String dataType;\r\n        Object small;\r\n        Object large;\r\n    }\r\n\r\n}"},{"path":"/src/smallsql/database/Utils.java","source":"/* =============================================================\r\n * SmallSQL : a free Java DBMS library for the Java(tm) platform\r\n * =============================================================\r\n *\r\n * (C) Copyright 2004-2011, by Volker Berlin.\r\n *\r\n * Project Info:  http://www.smallsql.de/\r\n *\r\n * This library is free software; you can redistribute it and/or modify it \r\n * under the terms of the GNU Lesser General Public License as published by \r\n * the Free Software Foundation; either version 2.1 of the License, or \r\n * (at your option) any later version.\r\n *\r\n * This library is distributed in the hope that it will be useful, but \r\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \r\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public \r\n * License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, \r\n * USA.  \r\n *\r\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc. \r\n * in the United States and other countries.]\r\n *\r\n * ---------------\r\n * Utils.java\r\n * ---------------\r\n * Author: Volker Berlin\r\n * \r\n */\r\npackage smallsql.database;\r\n\r\nimport java.io.File;\r\nimport java.io.FileNotFoundException;\r\nimport java.io.RandomAccessFile;\r\nimport java.nio.channels.FileChannel;\r\nimport java.nio.channels.FileLock;\r\nimport java.sql.SQLException;\r\nimport smallsql.database.language.Language;\r\n\r\nclass Utils {\r\n\r\n\tstatic final String MASTER_FILENAME = \"smallsql.master\";\r\n\tstatic final String TABLE_VIEW_EXTENTION = \".sdb\";\r\n\tprivate static final String LOB_EXTENTION = \".lob\";\r\n\tstatic final String IDX_EXTENTION = \".idx\";\r\n\tprivate static final Integer[] integerCache = new Integer[260];\r\n\tprivate static final Short[]   shortCache   = new Short[260];\r\n\t\r\n\tstatic{\r\n\t\tfor(int i=-4; i<256; i++){\r\n\t\t\tintegerCache[ i+4 ] = new Integer(i);\r\n\t\t\tshortCache  [ i+4 ] = new Short((short)i);\r\n\t\t}\r\n\t}\r\n    \r\n    static String createTableViewFileName(Database database, String name){\r\n        return database.getName() + '/' + name + TABLE_VIEW_EXTENTION;\r\n    }\r\n\r\n\tstatic String createLobFileName(Database database, String name){\r\n\t\treturn database.getName() + '/' + name + LOB_EXTENTION;\r\n\t}\r\n\r\n\tstatic String createIdxFileName(Database database, String name){\r\n\t\treturn database.getName() + '/' + name + IDX_EXTENTION;\r\n\t}\r\n\r\n\tstatic boolean like(String value, String pattern){\r\n\t\tif(value == null || pattern == null) return false;\r\n\t\tif(pattern.length() == 0) return true;\r\n\r\n\t\tint mIdx = 0;//index in mask Array\r\n\t\tint sIdx = 0;//index in search Array\r\n\t\tboolean range = false;\r\n\t\tweiter:\r\n\t\twhile(pattern.length() > mIdx && value.length() > sIdx) {\r\n\t\t\tchar m = Character.toUpperCase(pattern.charAt(mIdx++));\r\n\t\t\tswitch(m) {\r\n\t\t\t\tcase '%':\r\n\t\t\t\t\trange = true;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase '_':\r\n\t\t\t\t\tsIdx++;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tif(range) {//% wildcard is active\r\n\t\t\t\t\t\tfor(; sIdx < value.length(); sIdx++) {\r\n\t\t\t\t\t\t\tif(Character.toUpperCase(value.charAt(sIdx)) == m) break;//Counter mustn't increment before break\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif(sIdx >= value.length()) return false;\r\n\t\t\t\t\t\tint lastmIdx = mIdx - 1;\r\n\t\t\t\t\t\tsIdx++;\r\n\t\t\t\t\t\twhile(pattern.length() > mIdx && value.length() > sIdx) {\r\n\t\t\t\t\t\t\tm = Character.toUpperCase(pattern.charAt(mIdx++));\r\n\t\t\t\t\t\t\tif(Character.toUpperCase(value.charAt(sIdx)) != m) {\r\n\t\t\t\t\t\t\t\tif(m == '%' || m == '_') {\r\n\t\t\t\t\t\t\t\t\tmIdx--;\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tmIdx = lastmIdx;\r\n\t\t\t\t\t\t\t\tcontinue weiter;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tsIdx++;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\trange = false;\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tif(Character.toUpperCase(value.charAt(sIdx)) != m) return false;\r\n\t\t\t\t\t\tsIdx++;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\twhile(pattern.length() > mIdx) {\r\n            //Search mask is not too ends yet it may only '%' be contained \r\n\t\t\tif(Character.toUpperCase(pattern.charAt(mIdx++)) != '%') return false;\r\n\t\t}\r\n\t\twhile(value.length() > sIdx && !range) return false;\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\t\r\n\tstatic int long2int(long value){\r\n\t\tif(value > Integer.MAX_VALUE)\r\n\t\t\treturn Integer.MAX_VALUE;\r\n\t\tif(value < Integer.MIN_VALUE)\r\n\t\t\treturn Integer.MIN_VALUE;\r\n\t\treturn (int)value;\r\n\t}\r\n\t\r\n\tstatic long double2long(double value){\r\n\t\tif(value > Long.MAX_VALUE)\r\n\t\t\treturn Long.MAX_VALUE;\r\n\t\tif(value < Long.MIN_VALUE)\r\n\t\t\treturn Long.MIN_VALUE;\r\n\t\treturn (long)value;\r\n\t}\r\n\r\n\r\n\r\n    static float bytes2float( byte[] bytes ){\r\n        return Float.intBitsToFloat( bytes2int( bytes ) );\r\n    }\r\n\r\n    static double bytes2double( byte[] bytes ){\r\n        return Double.longBitsToDouble( bytes2long( bytes ) );\r\n    }\r\n\r\n    static long bytes2long( byte[] bytes ){\r\n        long result = 0;\r\n        int length = Math.min( 8, bytes.length);\r\n        for(int i=0; i<length; i++){\r\n            result = (result << 8) | (bytes[i] & 0xFF);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    static int bytes2int( byte[] bytes ){\r\n        int result = 0;\r\n        int length = Math.min( 4, bytes.length);\r\n        for(int i=0; i<length; i++){\r\n            result = (result << 8) | (bytes[i] & 0xFF);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    static byte[] double2bytes( double value ){\r\n        return long2bytes(Double.doubleToLongBits(value));\r\n    }\r\n\r\n    static byte[] float2bytes( float value ){\r\n        return int2bytes(Float.floatToIntBits(value));\r\n    }\r\n\r\n    static byte[] long2bytes( long value ){\r\n        byte[] result = new byte[8];\r\n        result[0] = (byte)(value >> 56);\r\n        result[1] = (byte)(value >> 48);\r\n        result[2] = (byte)(value >> 40);\r\n        result[3] = (byte)(value >> 32);\r\n        result[4] = (byte)(value >> 24);\r\n        result[5] = (byte)(value >> 16);\r\n        result[6] = (byte)(value >> 8);\r\n        result[7] = (byte)(value);\r\n        return result;\r\n    }\r\n    \r\n    static int money2int( long value ) {\r\n\t\tif (value < Integer.MIN_VALUE) return Integer.MIN_VALUE;\r\n\t\telse if (value > Integer.MAX_VALUE) return Integer.MAX_VALUE;\r\n\t\telse return (int) value;\r\n\t}\r\n\r\n\tstatic byte[] int2bytes( int value ){\r\n\t\tbyte[] result = new byte[4];\r\n\t\tresult[0] = (byte)(value >> 24);\r\n\t\tresult[1] = (byte)(value >> 16);\r\n\t\tresult[2] = (byte)(value >> 8);\r\n\t\tresult[3] = (byte)(value);\r\n\t\treturn result;\r\n\t}\r\n\r\n    static String bytes2hex( byte[] bytes ){\r\n        StringBuffer buf = new StringBuffer(bytes.length << 1);\r\n        for(int i=0; i<bytes.length; i++){\r\n            buf.append( digits[ (bytes[i] >> 4) & 0x0F ] );\r\n            buf.append( digits[ (bytes[i]     ) & 0x0F ] );\r\n        }\r\n        return buf.toString();\r\n    }\r\n\r\n    static byte[] hex2bytes( char[] hex, int offset, int length) throws SQLException{\r\n        try{\r\n            byte[] bytes = new byte[length / 2];\r\n            for(int i=0; i<bytes.length; i++){\r\n                bytes[i] = (byte)((hexDigit2int( hex[ offset++ ] ) << 4)\r\n                                | hexDigit2int( hex[ offset++ ] ));\r\n            }\r\n            return bytes;\r\n        }catch(Exception e){\r\n             throw SmallSQLException.create(Language.SEQUENCE_HEX_INVALID, String.valueOf(offset)); /*, offset*/\r\n        }\r\n    }\r\n\r\n    private static int hexDigit2int(char digit){\r\n        if(digit >= '0' && digit <= '9') return digit - '0';\r\n        digit |= 0x20;\r\n        if(digit >= 'a' && digit <= 'f') return digit - 'W'; // -'W'  ==  -'a' + 10\r\n        throw new RuntimeException();\r\n    }\r\n\r\n    static byte[] unique2bytes( String unique ) throws SQLException{\r\n        char[] chars = unique.toCharArray();\r\n        byte[] daten = new byte[16];\r\n        daten[3] = hex2byte( chars, 0 );\r\n        daten[2] = hex2byte( chars, 2 );\r\n        daten[1] = hex2byte( chars, 4 );\r\n        daten[0] = hex2byte( chars, 6 );\r\n\r\n        daten[5] = hex2byte( chars, 9 );\r\n        daten[4] = hex2byte( chars, 11 );\r\n\r\n        daten[7] = hex2byte( chars, 14 );\r\n        daten[6] = hex2byte( chars, 16 );\r\n\r\n        daten[8] = hex2byte( chars, 19 );\r\n        daten[9] = hex2byte( chars, 21 );\r\n\r\n        daten[10] = hex2byte( chars, 24 );\r\n        daten[11] = hex2byte( chars, 26 );\r\n        daten[12] = hex2byte( chars, 28 );\r\n        daten[13] = hex2byte( chars, 30 );\r\n        daten[14] = hex2byte( chars, 32 );\r\n        daten[15] = hex2byte( chars, 34 );\r\n        return daten;\r\n    }\r\n\r\n    private static byte hex2byte( char[] hex, int offset) throws SQLException{\r\n        try{\r\n                return (byte)((hexDigit2int( hex[ offset++ ] ) << 4)\r\n                                | hexDigit2int( hex[ offset++ ] ));\r\n        }catch(Exception e){\r\n             throw SmallSQLException.create(Language.SEQUENCE_HEX_INVALID_STR, new Object[] { new Integer(offset), new String(hex) });\r\n        }\r\n    }\r\n\r\n    static String bytes2unique( byte[] daten, int offset ){\r\n    \tif(daten.length-offset < 16){\r\n    \t\tbyte[] temp = new byte[16];\r\n    \t\tSystem.arraycopy(daten, offset, temp, 0, daten.length-offset);\r\n    \t\tdaten = temp;\r\n    \t}\r\n        char[] chars = new char[36];\r\n        chars[8] = chars[13] = chars[18] = chars[23] = '-';\r\n\r\n        chars[0] = digits[ (daten[offset+3] >> 4) & 0x0F ];\r\n        chars[1] = digits[ (daten[offset+3]     ) & 0x0F ];\r\n        chars[2] = digits[ (daten[offset+2] >> 4) & 0x0F ];\r\n        chars[3] = digits[ (daten[offset+2]     ) & 0x0F ];\r\n        chars[4] = digits[ (daten[offset+1] >> 4) & 0x0F ];\r\n        chars[5] = digits[ (daten[offset+1]     ) & 0x0F ];\r\n        chars[6] = digits[ (daten[offset+0] >> 4) & 0x0F ];\r\n        chars[7] = digits[ (daten[offset+0]     ) & 0x0F ];\r\n\r\n        chars[ 9] = digits[ (daten[offset+5] >> 4) & 0x0F ];\r\n        chars[10] = digits[ (daten[offset+5]     ) & 0x0F ];\r\n        chars[11] = digits[ (daten[offset+4] >> 4) & 0x0F ];\r\n        chars[12] = digits[ (daten[offset+4]     ) & 0x0F ];\r\n\r\n        chars[14] = digits[ (daten[offset+7] >> 4) & 0x0F ];\r\n        chars[15] = digits[ (daten[offset+7]     ) & 0x0F ];\r\n        chars[16] = digits[ (daten[offset+6] >> 4) & 0x0F ];\r\n        chars[17] = digits[ (daten[offset+6]     ) & 0x0F ];\r\n\r\n        chars[19] = digits[ (daten[offset+8] >> 4) & 0x0F ];\r\n        chars[20] = digits[ (daten[offset+8]     ) & 0x0F ];\r\n        chars[21] = digits[ (daten[offset+9] >> 4) & 0x0F ];\r\n        chars[22] = digits[ (daten[offset+9]     ) & 0x0F ];\r\n\r\n        chars[24] = digits[ (daten[offset+10] >> 4) & 0x0F ];\r\n        chars[25] = digits[ (daten[offset+10]     ) & 0x0F ];\r\n        chars[26] = digits[ (daten[offset+11] >> 4) & 0x0F ];\r\n        chars[27] = digits[ (daten[offset+11]     ) & 0x0F ];\r\n        chars[28] = digits[ (daten[offset+12] >> 4) & 0x0F ];\r\n        chars[29] = digits[ (daten[offset+12]     ) & 0x0F ];\r\n        chars[30] = digits[ (daten[offset+13] >> 4) & 0x0F ];\r\n        chars[31] = digits[ (daten[offset+13]     ) & 0x0F ];\r\n        chars[32] = digits[ (daten[offset+14] >> 4) & 0x0F ];\r\n        chars[33] = digits[ (daten[offset+14]     ) & 0x0F ];\r\n        chars[34] = digits[ (daten[offset+15] >> 4) & 0x0F ];\r\n        chars[35] = digits[ (daten[offset+15]     ) & 0x0F ];\r\n        return new String(chars);\r\n    }\r\n\r\n    static boolean string2boolean( String val){\r\n        try{\r\n            return Double.parseDouble( val ) != 0;\r\n        }catch(NumberFormatException e){/*ignore it if it not a number*/}\r\n        return \"true\".equalsIgnoreCase( val ) || \"yes\".equalsIgnoreCase( val ) || \"t\".equalsIgnoreCase( val );\r\n    }\r\n\t\r\n\t\r\n\tstatic long doubleToMoney(double value){\r\n\t\tif(value < 0)\r\n\t\t\treturn (long)(value * 10000 - 0.5);\r\n\t\treturn (long)(value * 10000 + 0.5);\r\n\t}\r\n\r\n    static int indexOf( char value, char[] str, int offset, int length ){\r\n        value |= 0x20;\r\n        for(int end = offset+length;offset < end; offset++){\r\n            if((str[offset] | 0x20) == value) return offset;\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    static int indexOf( int value, int[] list ){\r\n        int offset = 0;\r\n        for(int end = list.length; offset < end; offset++){\r\n            if((list[offset]) == value) return offset;\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    static int indexOf( byte[] value, byte[] list, int offset ){\r\n        int length = value.length;\r\n        loop1:\r\n        for(int end = list.length-length; offset <= end; offset++){\r\n            for(int i=0; i<length; i++ ){\r\n                if(list[offset+i] != value[i]){\r\n                    continue loop1;\r\n                }\r\n            }\r\n            return offset;\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    static int compareBytes( byte[] leftBytes, byte[] rightBytes){\r\n        int length = Math.min( leftBytes.length, rightBytes.length );\r\n        int comp = 0;\r\n        for(int i=0; i<length; i++){\r\n            if(leftBytes[i] != rightBytes[i]){\r\n                comp = leftBytes[i] < rightBytes[i] ? -1 : 1;\r\n                break;\r\n            }\r\n        }\r\n        if(comp == 0 && leftBytes.length != rightBytes.length){\r\n            comp = leftBytes.length < rightBytes.length ? -1 : 1;\r\n        }\r\n        return comp;\r\n    }\r\n\t\r\n    \r\n    /**\r\n     * \r\n     * @param colNames\r\n     * @param data\r\n     * @return\r\n     * @throws SQLException\r\n     */\r\n    static CommandSelect createMemoryCommandSelect( SSConnection con, String[] colNames, Object[][] data) throws SQLException{\r\n\t\tMemoryResult source = new MemoryResult(data, colNames.length);\r\n\t\tCommandSelect cmd = new CommandSelect(con.log);\r\n\t\tfor(int i=0; i<colNames.length; i++){\r\n\t\t\tExpressionName expr = new ExpressionName(colNames[i]);\r\n\t\t\tcmd.addColumnExpression( expr );\r\n\t\t\texpr.setFrom( source, i, source.getColumn(i));\r\n\t\t}\r\n\t\tcmd.setSource(source);\r\n\t\treturn cmd;\r\n    }\r\n\t\r\n\r\n\t/**\r\n     *  recycle Integer objects, this is faster as to garbage the objects\r\n\t */\r\n\tstatic final Integer getInteger(int value){\r\n\t\tif(value >= -4 && value < 256){\r\n\t\t\treturn integerCache[ value+4 ];\t\t\r\n\t\t}else\r\n\t\t\treturn new Integer(value);\r\n\t}\r\n\t\r\n\t/**\r\n     * recycle Integer objects, this is faster as to garbage the objects\r\n\t */\r\n\tstatic final Short getShort(int value){\r\n\t\tif(value >= -4 && value < 256){\r\n\t\t\treturn shortCache[ value+4 ];\t\t\r\n\t\t}else\r\n\t\t\treturn new Short((short)value);\r\n\t}\r\n    \r\n    \r\n    /**\r\n     * Open a RandomAccessFile and lock it that no other thread or VM can open it..\r\n     * \r\n     * @param file\r\n     *            The file that should be open.\r\n     * @return a FileChannel\r\n     * @throws FileNotFoundException\r\n     *             If the file can not open\r\n     * @param readonly open database in read only mode\r\n     * @throws SQLException\r\n     *             If the file can't lock.\r\n     */\r\n    static final FileChannel openRaFile( File file, boolean readonly ) throws FileNotFoundException, SQLException{\r\n        RandomAccessFile raFile = new RandomAccessFile(file, readonly ? \"r\" : \"rw\" );\r\n        FileChannel channel = raFile.getChannel();\r\n        if( !readonly ){\r\n            try{\r\n                FileLock lock = channel.tryLock();\r\n                if(lock == null){\r\n                    throw SmallSQLException.create(Language.CANT_LOCK_FILE, file);\r\n                }\r\n            }catch(SQLException sqlex){\r\n                throw sqlex;\r\n            }catch(Throwable th){\r\n                throw SmallSQLException.createFromException(Language.CANT_LOCK_FILE, file, th);\r\n            }\r\n        }\r\n        return channel;\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Get all the ExpressionName objects that are part of the tree.\r\n     * If it only a constant expression then a empty list is return.\r\n     * @param tree the expression to scan\r\n     * @return the list of ExpressionName instances\r\n     */\r\n    static final Expressions getExpressionNameFromTree(Expression tree){\r\n        Expressions list = new Expressions();\r\n        getExpressionNameFromTree( list, tree );\r\n        return list;\r\n    }\r\n    \r\n    /**\r\n     * Scan the tree recursively.\r\n     */\r\n    private static final void getExpressionNameFromTree(Expressions list, Expression tree){\r\n        if(tree.getType() == Expression.NAME ){\r\n            list.add(tree);\r\n        }\r\n        Expression[] params = tree.getParams();\r\n        if(params != null){\r\n            for(int i=0; i<params.length; i++){\r\n                getExpressionNameFromTree( list, tree );\r\n            }\r\n        }\r\n    }\r\n\r\n    final static char[] digits = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};\r\n}"},{"path":"/src/smallsql/junit/TestThreads.java","source":"/*\r\n * Created on 13.07.2008\r\n */\r\npackage smallsql.junit;\r\n\r\nimport java.sql.*;\r\nimport java.util.ArrayList;\r\n\r\n/**\r\n * Test some thread problems.\r\n * \r\n * @author Volker Berlin\r\n */\r\npublic class TestThreads extends BasicTestCase{\r\n\r\n    volatile Throwable throwable;\r\n\r\n\r\n    /**\r\n     * Test the concurrently read of a table\r\n     * \r\n     * @throws Throwable\r\n     *             if an thread problem occur\r\n     */\r\n    public void testConcurrentRead() throws Throwable{\r\n        ArrayList threadList = new ArrayList();\r\n        throwable = null;\r\n\r\n        // Any table from another test that include rows.\r\n        final String sql = \"Select * From table_OrderBy1\";\r\n\r\n        // calculate the row count of this table\r\n        final Connection con = AllTests.getConnection();\r\n        Statement st = con.createStatement();\r\n        ResultSet rs = st.executeQuery(\"Select * From table_OrderBy1\");\r\n        int count = 0;\r\n        while(rs.next()){\r\n            count++;\r\n        }\r\n        final int rowCount = count;\r\n\r\n        // start threads that check the row count\r\n        for(int i = 0; i < 200; i++){\r\n            Thread thread = new Thread(new Runnable(){\r\n\r\n                public void run(){\r\n                    try{\r\n                        assertRowCount(rowCount, sql);\r\n                    }catch(Throwable ex){\r\n                        throwable = ex;\r\n                    }\r\n                }\r\n\r\n            });\r\n            threadList.add(thread);\r\n            thread.start();\r\n        }\r\n\r\n        // wait until all threads are finish\r\n        for(int i = 0; i < threadList.size(); i++){\r\n            Thread thread = (Thread)threadList.get(i);\r\n            thread.join(5000);\r\n        }\r\n\r\n        // throw the exception if one occur\r\n        if(throwable != null){\r\n            throw throwable;\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Create a table with a single row. In different threads on the same connection a int value will be increment.\r\n     * \r\n     * @throws Throwable\r\n     *             if an thread problem occur\r\n     */\r\n    public void testConcurrentThreadWrite() throws Throwable{\r\n        ArrayList threadList = new ArrayList();\r\n        throwable = null;\r\n        final Connection con = AllTests.getConnection();\r\n        Statement st = con.createStatement();\r\n        try{\r\n            st.execute(\"CREATE TABLE ConcurrentWrite( value int)\");\r\n            st.execute(\"INSERT INTO ConcurrentWrite(value) Values(0)\");\r\n\r\n            // start threads that check the row count\r\n            for(int i = 0; i < 200; i++){\r\n                Thread thread = new Thread(new Runnable(){\r\n\r\n                    public void run(){\r\n                        try{\r\n                            Statement st2 = con.createStatement();\r\n                            int count = st2.executeUpdate(\"UPDATE ConcurrentWrite SET value = value + 1\");\r\n                            assertEquals(\"Update Count\", 1, count);\r\n                        }catch(Throwable ex){\r\n                            throwable = ex;\r\n                        }\r\n                    }\r\n\r\n                });\r\n                threadList.add(thread);\r\n                thread.start();\r\n            }\r\n\r\n            // wait until all threads are finish\r\n            for(int i = 0; i < threadList.size(); i++){\r\n                Thread thread = (Thread)threadList.get(i);\r\n                thread.join(5000);\r\n            }\r\n\r\n            // throw the exception if one occur\r\n            if(throwable != null){\r\n                throw throwable;\r\n            }\r\n\r\n            assertEqualsRsValue(new Integer(200), \"SELECT value FROM ConcurrentWrite\");\r\n        }finally{\r\n            dropTable(con, \"ConcurrentWrite\");\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Create a table with a single row. In different connections a int value will be increment.\r\n     * \r\n     * @throws Throwable\r\n     *             if an thread problem occur\r\n     */\r\n    public void testConcurrentConnectionWrite() throws Throwable{\r\n        ArrayList threadList = new ArrayList();\r\n        throwable = null;\r\n        Connection con = AllTests.getConnection();\r\n        Statement st = con.createStatement();\r\n        try{\r\n            st.execute(\"CREATE TABLE ConcurrentWrite( value int)\");\r\n            st.execute(\"INSERT INTO ConcurrentWrite(value) Values(0)\");\r\n\r\n            // start threads that check the row count\r\n            for(int i = 0; i < 200; i++){\r\n                Thread thread = new Thread(new Runnable(){\r\n\r\n                    public void run(){\r\n                        try{\r\n                            Connection con2 = AllTests.createConnection();\r\n                            Statement st2 = con2.createStatement();\r\n                            int count = st2.executeUpdate(\"UPDATE ConcurrentWrite SET value = value + 1\");\r\n                            assertEquals(\"Update Count\", 1, count);\r\n                            con2.close();\r\n                        }catch(Throwable ex){\r\n                            throwable = ex;\r\n                        }\r\n                    }\r\n\r\n                });\r\n                threadList.add(thread);\r\n                thread.start();\r\n            }\r\n\r\n            // wait until all threads are finish\r\n            for(int i = 0; i < threadList.size(); i++){\r\n                Thread thread = (Thread)threadList.get(i);\r\n                thread.join(5000);\r\n            }\r\n\r\n            // throw the exception if one occur\r\n            if(throwable != null){\r\n                throw throwable;\r\n            }\r\n\r\n            assertEqualsRsValue(new Integer(200), \"SELECT value FROM ConcurrentWrite\");\r\n        }finally{\r\n            dropTable(con, \"ConcurrentWrite\");\r\n        }\r\n    }\r\n\r\n}\r\n"},{"path":"/src/smallsql/database/ExpressionFunctionConvert.java","source":"/* =============================================================\r\n * SmallSQL : a free Java DBMS library for the Java(tm) platform\r\n * =============================================================\r\n *\r\n * (C) Copyright 2004-2007, by Volker Berlin.\r\n *\r\n * Project Info:  http://www.smallsql.de/\r\n *\r\n * This library is free software; you can redistribute it and/or modify it \r\n * under the terms of the GNU Lesser General Public License as published by \r\n * the Free Software Foundation; either version 2.1 of the License, or \r\n * (at your option) any later version.\r\n *\r\n * This library is distributed in the hope that it will be useful, but \r\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \r\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public \r\n * License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, \r\n * USA.  \r\n *\r\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc. \r\n * in the United States and other countries.]\r\n *\r\n * ---------------\r\n * ExpressionFunctionConvert.java\r\n * ---------------\r\n * Author: Volker Berlin\r\n * \r\n * Created on 29.04.2004\r\n */\r\npackage smallsql.database;\r\n\r\nimport java.util.Arrays;\r\nimport smallsql.database.language.Language;\r\n\r\n/**\r\n * @author Volker Berlin\r\n */\r\npublic class ExpressionFunctionConvert extends ExpressionFunction {\r\n\r\n\tfinal private Column datatype;\r\n\t\r\n\tpublic ExpressionFunctionConvert(Column datatype, Expression value, Expression style) {\r\n\t\tsuper();\r\n\t\tthis.datatype = datatype;\r\n\t\tExpression[] params = (style == null) ? new Expression[]{value} : new Expression[]{value, style};\r\n\t\tsetParams( params );\r\n\t}\r\n\t\r\n\r\n\tint getFunction() {\r\n\t\treturn SQLTokenizer.CONVERT;\r\n\t}\r\n\t\r\n\r\n\tboolean isNull() throws Exception {\r\n\t\treturn param1.isNull();\r\n\t}\r\n\r\n\r\n\tboolean getBoolean() throws Exception {\r\n\t\treturn ExpressionValue.getBoolean( getObject(), getDataType() );\r\n\t}\r\n\r\n\t\r\n\tint getInt() throws Exception {\r\n\t\treturn ExpressionValue.getInt( getObject(), getDataType() );\r\n\t}\r\n\r\n\r\n\tlong getLong() throws Exception {\r\n\t\treturn ExpressionValue.getLong( getObject(), getDataType() );\r\n\t}\r\n\r\n\r\n\tfloat getFloat() throws Exception {\r\n\t\treturn ExpressionValue.getFloat( getObject(), getDataType() );\r\n\t}\r\n\r\n\r\n\tdouble getDouble() throws Exception {\r\n\t\treturn ExpressionValue.getDouble( getObject(), getDataType() );\r\n\t}\r\n\r\n\r\n\tlong getMoney() throws Exception {\r\n\t\treturn ExpressionValue.getMoney(getObject(), getDataType());\r\n\t}\r\n\t\r\n\r\n\tMutableNumeric getNumeric() throws Exception {\r\n\t\treturn ExpressionValue.getNumeric(getObject(), getDataType());\r\n\t}\r\n\r\n\r\n\tString getString() throws Exception {\r\n\t\tObject obj = getObject();\r\n\t\tif(obj == null) return null;\r\n\t\tswitch(datatype.getDataType()){\r\n\t\t\tcase SQLTokenizer.BIT:\r\n\t\t\t\treturn ((Boolean)obj).booleanValue() ? \"1\" : \"0\";\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n            case SQLTokenizer.LONGVARBINARY:\r\n                    return new String( (byte[])obj );\r\n\t\t}\r\n\t\treturn obj.toString();\r\n\t}\r\n\r\n\t\r\n\tObject getObject() throws Exception {\r\n\t\tif(param1.isNull()) return null;\r\n\t\tfinal int dataType = getDataType();\r\n\t\tswitch(dataType){\r\n\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\treturn convertToString();\r\n\t\t\tcase SQLTokenizer.VARCHAR:{\r\n\t\t\t\tString str = convertToString();\r\n\t\t\t\tint length = datatype.getDisplaySize();\r\n\t\t\t\tif(length > str.length())\r\n\t\t\t\t\treturn str;\r\n\t\t\t\treturn str.substring(0,length);\r\n\t\t\t}\r\n\t\t\tcase SQLTokenizer.CHAR:{\r\n\t\t\t\tString str = convertToString();\r\n\t\t\t\tint length = datatype.getDisplaySize();\r\n\t\t\t\tif(length > str.length()){\r\n\t\t\t\t\tchar[] buffer = new char[length-str.length()];\r\n\t\t\t\t\tArrays.fill(buffer, ' ');\r\n\t\t\t\t\treturn str + new String(buffer);\r\n\t\t\t\t}\r\n\t\t\t\treturn str.substring(0,length);\r\n\t\t\t}\r\n\t\t\tcase SQLTokenizer.LONGVARBINARY:\r\n\t\t\t\treturn param1.getBytes();\r\n\t\t\tcase SQLTokenizer.VARBINARY:{\r\n\t\t\t\tbyte[] bytes = param1.getBytes();\r\n\t\t\t\tint length = datatype.getPrecision();\r\n\t\t\t\tif(length < bytes.length){\r\n\t\t\t\t\tbyte[] buffer = new byte[length];\r\n\t\t\t\t\tSystem.arraycopy(bytes, 0, buffer, 0, Math.min(bytes.length,length) );\r\n\t\t\t\t\treturn buffer;\r\n\t\t\t\t}\r\n\t\t\t\treturn bytes;\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\tcase SQLTokenizer.BINARY:{\r\n\t\t\t\tbyte[] bytes = param1.getBytes();\r\n\t\t\t\tint length = datatype.getPrecision();\r\n\t\t\t\tif(length != bytes.length){\r\n\t\t\t\t\tbyte[] buffer = new byte[length];\r\n\t\t\t\t\tSystem.arraycopy(bytes, 0, buffer, 0, Math.min(bytes.length,length) );\r\n\t\t\t\t\treturn buffer;\r\n\t\t\t\t}\r\n\t\t\t\treturn bytes;\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\tcase SQLTokenizer.BOOLEAN:\r\n\t\t\tcase SQLTokenizer.BIT:\r\n\t\t\t\treturn param1.getBoolean() ? Boolean.TRUE : Boolean.FALSE;\r\n\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\treturn Utils.getInteger(param1.getInt() & 0xFF);\r\n\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\treturn Utils.getInteger((short)param1.getInt());\r\n\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\treturn Utils.getInteger(param1.getInt());\r\n\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\treturn new Long(param1.getLong());\r\n\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\treturn new Float(param1.getFloat());\r\n\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\treturn new Double(param1.getDouble());\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\treturn new DateTime( getDateTimeLong(), dataType );\r\n\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\tMutableNumeric num = param1.getNumeric();\r\n\t\t\t\tif(num != null && (dataType == SQLTokenizer.NUMERIC || dataType == SQLTokenizer.DECIMAL))\r\n\t\t\t\t\tnum.setScale(getScale());\r\n\t\t\t\treturn num;\r\n\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\tcase SQLTokenizer.SMALLMONEY:\r\n\t\t\t\treturn Money.createFromUnscaledValue(param1.getMoney());\r\n\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\tswitch(param1.getDataType()){\r\n\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\t\t\t\treturn Utils.bytes2unique( Utils.unique2bytes(param1.getString()), 0);\r\n\t\t\t\t}\r\n\t\t\t\treturn Utils.bytes2unique(param1.getBytes(), 0);\r\n\t\t}\r\n\t\tObject[] param = { SQLTokenizer.getKeyWord(dataType) };\r\n\t\tthrow SmallSQLException.create(Language.UNSUPPORTED_TYPE_CONV, param);\r\n\t}\r\n\t\r\n\t\r\n\tfinal private String convertToString() throws Exception{\r\n\t\tif(param2 != null){\r\n\t\t\tint type = param1.getDataType();\r\n\t\t\tswitch(type){\r\n\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\ttype = SQLTokenizer.TIMESTAMP;\r\n\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\treturn new DateTime( param1.getLong(), type ).toString(param2.getInt());\r\n\t\t\t\tdefault:\r\n\t\t\t\t\treturn param1.getString();\r\n\t\t\t}\r\n\t\t\t//TODO Format for MONEY, REAL and DOUBLE\r\n\t\t}else\r\n\t\t\treturn param1.getString();\r\n\t}\r\n\t\r\n\t\r\n\tfinal private long getDateTimeLong() throws Exception{\r\n\t\t//try{\r\n\t\t\tswitch(param1.getDataType()){\r\n\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\treturn DateTime.parse( param1.getString() );\r\n\t\t\t}\r\n\t\t//}catch(Exception e){/* do nothing */}\r\n\t\treturn param1.getLong();\r\n\t}\r\n\r\n\r\n\tfinal int getDataType() {\r\n\t\treturn datatype.getDataType();\r\n\t}\r\n\t\r\n\t\r\n\tfinal int getPrecision(){\r\n\t\tfinal int dataType = getDataType();\r\n\t\tswitch(dataType){\r\n\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\tcase SQLTokenizer.VARBINARY:\r\n\t\t\tcase SQLTokenizer.BINARY:\r\n\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\treturn datatype.getPrecision();\r\n\t\t\tdefault:\r\n\t\t\t\treturn super.getPrecision();\r\n\t\t}\r\n\t}\r\n\r\n\t\r\n\tfinal int getScale() {\r\n\t\treturn datatype.getScale();\r\n\t}\r\n\t\r\n\r\n}\r\n"},{"path":"/src/smallsql/database/Index.java","source":"/* =============================================================\r\n * SmallSQL : a free Java DBMS library for the Java(tm) platform\r\n * =============================================================\r\n *\r\n * (C) Copyright 2004-2007, by Volker Berlin.\r\n *\r\n * Project Info:  http://www.smallsql.de/\r\n *\r\n * This library is free software; you can redistribute it and/or modify it \r\n * under the terms of the GNU Lesser General Public License as published by \r\n * the Free Software Foundation; either version 2.1 of the License, or \r\n * (at your option) any later version.\r\n *\r\n * This library is distributed in the hope that it will be useful, but \r\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \r\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public \r\n * License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, \r\n * USA.  \r\n *\r\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc. \r\n * in the United States and other countries.]\r\n *\r\n * ---------------\r\n * Index.java\r\n * ---------------\r\n * Author: Volker Berlin\r\n * \r\n */\r\npackage smallsql.database;\r\n\r\nimport java.sql.SQLException;\r\nimport java.util.ArrayList;\r\n\r\n\r\n/**\r\n * To index data there need to solve the follow problems\r\n * - change the values that need to save in the index to a value with sort order that is compatible\r\n *   with the index algorithm.\r\n * - multiple column index need to support. There should no identical save with combinations of values.\r\n * - The data type for column should be constant.\r\n * - the data need to save fast.\r\n * - the size of the index should be small (also with a small count of values)\r\n * - It should use for unique index and nor unique. The unique index can save only one rowOffset.\r\n *   The non unique can save multiple rowOffsets in a LongTreeList.\r\n * - Problem ORDER BY with Joins? There are more as one rowOffset per row.\r\n * \r\n * \r\n * Algorithm:\r\n * - convert the values that the binary order is equals to the value order. We need to handle\r\n *   sign, floating numbers, case insensitive, different binary length (MutableNumeric).\r\n * - create a 256 byte large mask for the first byte.\r\n * - create a 256 byte large status mask\r\n * - create a 256 large Object array\r\n * \r\n * \r\n * @author Volker Berlin\r\n *\r\n */\r\nclass Index{\r\n\r\n\tfinal IndexNode rootPage;\r\n\t\r\n\t/**\r\n\t * Create an Index in the memory. An Index is like a sorted list.\r\n\t * @param unique true if there are no duplicated values allow.\r\n\t */\r\n\tIndex(boolean unique){\r\n\t\trootPage = new IndexNode(unique, (char)-1);\r\n\t}\r\n\t\r\n    \r\n    Index(IndexNode rootPage){\r\n        this.rootPage = rootPage;\r\n    }\r\n    \r\n    \r\n\tIndexScrollStatus createScrollStatus(Expressions expressions){\r\n\t\treturn new IndexScrollStatus(rootPage, expressions);\r\n\t}\r\n\t\r\n\t/**\r\n     * Returns a Long (unique) or a LongTreeList with rowOffsets. If the value in expressions does not exist then it\r\n     * return a null.\r\n     * \r\n     * @param expressions\r\n     *            The value that are search in the Index.\r\n     * @param searchNullValues\r\n     *            expressions with NULL values should return a result.\r\n     * @param nodeList\r\n     *            optional, can be null. The search path in the index tree.\r\n     */\r\n\tfinal Object findRows(Expressions expressions, boolean searchNullValues, ArrayList nodeList) throws Exception{\r\n        IndexNode page = rootPage;\r\n        int count = expressions.size();\r\n        for(int i = 0; i < count; i++){\r\n            page = findRows(page, expressions.get(i), searchNullValues, nodeList);\r\n            if(page == null)\r\n                return null;\r\n            if(i + 1 == count)\r\n                return page.getValue();\r\n            else\r\n                page = (IndexNode)page.getValue();\r\n        }\r\n        throw new Error();\r\n    }\r\n\t\r\n\t\r\n\t/**\r\n     * Returns a Long (unique) or a LongTreeList with rowOffsets. If the value in expressions does not exist then it\r\n     * return a null.\r\n     * \r\n     * @param expressions\r\n     *            The value that are search in the Index.\r\n     * @param searchNullValues\r\n     *            a expression with NULL values should return a result.\r\n     * @param nodeList\r\n     *            optional, can be null. The search path in the index tree.\r\n     */\r\n    final Object findRows(Expression[] expressions, boolean searchNullValues, ArrayList nodeList) throws Exception{\r\n        IndexNode page = rootPage;\r\n        int count = expressions.length;\r\n        for(int i = 0; i < count; i++){\r\n            page = findRows(page, expressions[i], searchNullValues, nodeList);\r\n            if(page == null)\r\n                return null;\r\n            if(i + 1 == count)\r\n                return page.getValue();\r\n            else\r\n                page = (IndexNode)page.getValue();\r\n        }\r\n        throw new Error();\r\n    }\r\n\t\r\n\t\r\n\t/**\r\n     * Return the last IndexNode for the expression. If the value in expressions does not exist then it return a null.\r\n     * \r\n     * @param page\r\n     *            the start point of the search. If it the first expression of a list then it is the rootPage\r\n     * @param expr\r\n     *            the searching expression\r\n     * @param searchNullValues\r\n     *            a expression with NULL values should return a result.\r\n     * @param nodeList\r\n     *            optional, can be null. The search path in the index tree.\r\n     * @return the mapping IndexNode or null.\r\n     */\r\n\tfinal private IndexNode findRows(IndexNode page, Expression expr, boolean searchNullValues, ArrayList nodeList) throws Exception{\r\n\t\t\tif(expr.isNull()){\r\n                if(!searchNullValues){\r\n                    return null;\r\n                }\r\n\t\t\t\tpage = findNull(page);\r\n\t\t\t}else{\r\n\t\t\t\tswitch(expr.getDataType()){\r\n\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\tpage = find( page, floatToBinarySortOrder( expr.getFloat()), 2, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\t\tpage = find( page, doubleToBinarySortOrder( expr.getDouble()), 4, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\t\tpage = find( page, expr.getInt(), 1, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\t\tpage = find( page, shortToBinarySortOrder( expr.getInt()), 1, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\tpage = find( page, intToBinarySortOrder( expr.getInt()), 2, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\tcase SQLTokenizer.SMALLMONEY:\r\n\t\t\t\t\t\tpage = find( page, longToBinarySortOrder( expr.getLong()), 4, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.NVARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.LONGNVARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\t\t\t\tpage = find( page, stringToBinarySortOrder( expr.getString(), false ), nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.NCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\t\tpage = find( page, stringToBinarySortOrder( expr.getString(), true ), nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.VARBINARY:\r\n\t\t\t\t\tcase SQLTokenizer.BINARY:\r\n\t\t\t\t\tcase SQLTokenizer.LONGVARBINARY:\r\n\t\t\t\t\tcase SQLTokenizer.BLOB:\r\n\t\t\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\t\t\tpage = find( page, bytesToBinarySortOrder( expr.getBytes()), nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.BIT:\r\n\t\t\t\t\tcase SQLTokenizer.BOOLEAN:\r\n\t\t\t\t\t\tpage = find( page, expr.getBoolean() ? 2 : 1, 1, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\tcase SQLTokenizer.DECIMAL:\t\t\t\t\t\t\r\n\t\t\t\t\t\tpage = find( page, numericToBinarySortOrder( expr.getNumeric() ), nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault: \r\n\t\t\t\t\t\t//TODO more data types\r\n\t\t\t\t\t\tthrow new Error(String.valueOf(expr.getDataType()));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn page;\r\n\t}\r\n\r\n\t\r\n\t/**\r\n\t * Add a value to the index.\r\n\t * @param rowOffset Is the value that is save in the index. It is typical a row number or a rowOffset.\r\n\t * @param expressions This is the list of ORDER BY columns and describe the position in the index.\r\n\t */\r\n\tfinal void addValues( long rowOffset, Expressions expressions ) throws Exception{\r\n\t\tIndexNode page = this.rootPage;\r\n\t\tint count = expressions.size();\r\n\t\tfor(int i=0; i<count; i++){\r\n\t\t\tExpression expr = expressions.get(i);\r\n\t\t\tboolean isLastValues = (i == count-1);\r\n\t\t\tif(expr.isNull()){\r\n\t\t\t\tpage = addNull(page, rowOffset, isLastValues);\r\n\t\t\t}else{\r\n\t\t\t\tswitch(expr.getDataType()){\r\n\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, floatToBinarySortOrder( expr.getFloat()), isLastValues, 2 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, doubleToBinarySortOrder( expr.getDouble()), isLastValues, 4 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, expr.getInt(), isLastValues, 1 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, shortToBinarySortOrder( expr.getInt()), isLastValues, 1 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, intToBinarySortOrder( expr.getInt()), isLastValues, 2 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\tcase SQLTokenizer.SMALLMONEY:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, longToBinarySortOrder( expr.getLong()), isLastValues, 4 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.NVARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.LONGNVARCHAR:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, stringToBinarySortOrder( expr.getString(), false ), isLastValues );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.NCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, stringToBinarySortOrder( expr.getString(), true ), isLastValues );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.VARBINARY:\r\n\t\t\t\t\tcase SQLTokenizer.BINARY:\r\n\t\t\t\t\tcase SQLTokenizer.LONGVARBINARY:\r\n\t\t\t\t\tcase SQLTokenizer.BLOB:\r\n\t\t\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, bytesToBinarySortOrder( expr.getBytes()), isLastValues );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.BIT:\r\n\t\t\t\t\tcase SQLTokenizer.BOOLEAN:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, expr.getBoolean() ? 2 : 1, isLastValues, 1 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, numericToBinarySortOrder( expr.getNumeric()), isLastValues );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault: \r\n\t\t\t\t\t\t//TODO more data types\r\n\t\t\t\t\t\tthrow new Error(String.valueOf(expr.getDataType()));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\t\t\r\n\t}\r\n\t\r\n\t\r\n\tfinal void removeValue( long rowOffset, Expressions expressions ) throws Exception{\r\n\t\tArrayList nodeList = new ArrayList();\r\n\t\tObject obj = findRows(expressions, true, nodeList);\r\n\t\tif(!rootPage.getUnique()){\r\n\t\t\tLongTreeList list = (LongTreeList)obj;\r\n\t\t\tlist.remove(rowOffset);\r\n\t\t\tif(list.getSize() > 0) return;\r\n\t\t}\r\n\t\tIndexNode node = (IndexNode)nodeList.get(nodeList.size()-1);\r\n\t\tnode.clearValue();\r\n\t\tfor(int i = nodeList.size()-2; i >= 0; i--){\r\n\t\t\tif(!node.isEmpty())\r\n\t\t\t\tbreak;\r\n\t\t\tIndexNode parent = (IndexNode)nodeList.get(i);\r\n\t\t\tparent.removeNode( node.getDigit() );\r\n\t\t\tnode = parent;\r\n\t\t}\r\n\t}\r\n\t\r\n\t\r\n\tfinal private IndexNode findNull(IndexNode page){\r\n\t\treturn page.getChildNode( (char)0 );\r\n\t}\r\n\t\r\n\r\n\tfinal private IndexNode addNull(IndexNode page, long rowOffset, boolean isLastValue) throws SQLException{\r\n\t\tif(isLastValue){\r\n\t\t\tpage.addNode( (char)0, rowOffset );\r\n\t\t\treturn null;\r\n\t\t}else\r\n\t\t\treturn page.addRoot((char)0);\r\n\t}\r\n\r\n\t\r\n\tfinal private IndexNode find(IndexNode node, long key, int digitCount, ArrayList nodeList){\r\n\t\tfor(int i=digitCount-1; i>=0; i--){\r\n\t\t\tchar digit = (char)(key >> (i<<4));\r\n\t\t\tnode = node.getChildNode(digit);\r\n\t\t\t\r\n\t\t\tif(node == null) return null;\r\n\t\t\tif(nodeList != null) nodeList.add(node);\r\n\r\n\t\t\tif(equals(node.getRemainderValue(), key, i)){\r\n\t\t\t\treturn node;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn node;\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * The key has a binary sort order. This means the most significant byte is in the high byte.\r\n\t * @param digitCount The count of 16Bit digits.\r\n\t */\r\n\tfinal private IndexNode add(IndexNode node, long rowOffset, long key, boolean isLastValue, int digitCount) throws SQLException{\r\n\t\tfor(int i=digitCount-1; i>=0; i--){\r\n\t\t\tchar digit = (char)(key >> (i<<4));\r\n\t\t\tif(i == 0){\r\n\t\t\t\tif(isLastValue){\r\n\t\t\t\t\tnode.addNode( digit, rowOffset );\r\n\t\t\t\t\treturn null;\r\n\t\t\t\t}\r\n\t\t\t\treturn node.addRoot(digit);\r\n\t\t\t}\r\n\t\t\tnode = node.addNode(digit);\r\n\t\t\tif(node.isEmpty()){\r\n\t\t\t\tif(isLastValue){\r\n\t\t\t\t\tnode.addRemainderKey( rowOffset, key, i );\r\n\t\t\t\t\treturn null;\r\n\t\t\t\t}\r\n\t\t\t\treturn node.addRootValue( key, i);\r\n\t\t\t}else\r\n\t\t\tif(equals(node.getRemainderValue(), key, i)){\r\n\t\t\t\tif(isLastValue){\r\n\t\t\t\t\tnode.saveValue( rowOffset);\r\n\t\t\t\t\treturn null;\r\n\t\t\t\t}\r\n\t\t\t\treturn node.addRoot();\r\n\t\t\t}\t\t\r\n\t\t}\r\n\t\tthrow new Error();\r\n\t}\r\n\t\r\n\t\r\n\tfinal private IndexNode find(IndexNode node, char[] key, ArrayList nodeList){\r\n\t\tint length = key.length;\r\n\t\tint i=-1;\r\n\t\twhile(true){\r\n\t\t\t// the first digit include 0-null; 1-empty; 2 another value\r\n\t\t\tchar digit = (i<0) ? (length == 0 ? (char)1 : 2)\r\n\t\t\t\t\t\t\t  : (key[i]);\r\n\t\t\tnode = node.getChildNode(digit);\r\n\r\n\t\t\tif(node == null) return null;\r\n\t\t\tif(nodeList != null) nodeList.add(node);\r\n\t\t\tif(++i == length){\r\n\t\t\t\treturn node;\r\n\t\t\t}\r\n\r\n\t\t\tif(equals(node.getRemainderValue(), key, i)){\r\n\t\t\t\treturn node;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * Add a byte array to the Index.\r\n\t */\r\n\tfinal private IndexNode add(IndexNode node, long rowOffset, char[] key, boolean isLast) throws SQLException{\r\n\t\tint length = key.length;\r\n\t\tint i=-1;\r\n\t\twhile(true){\r\n\t\t\t// the first digit include 0-null; 1-empty; 2 another value\r\n\t\t\tchar digit = (i<0) ? (length == 0 ? (char)1 : 2)\r\n\t\t\t\t\t\t\t  : (key[i]);\r\n\t\t\tif(++i == length){\r\n\t\t\t\tif(isLast){\r\n\t\t\t\t\tnode.addNode( digit, rowOffset );\r\n\t\t\t\t\treturn null;\r\n\t\t\t\t}\r\n\t\t\t\treturn node.addRoot(digit);\r\n\t\t\t}\r\n\t\t\tnode = node.addNode(digit);\r\n\t\t\tif(node.isEmpty()){\r\n\t\t\t\tif(isLast){\r\n\t\t\t\t\tnode.addRemainderKey( rowOffset, key, i );\r\n\t\t\t\t\treturn null;\r\n\t\t\t\t}\r\n\t\t\t\treturn node.addRootValue( key, i );\r\n\t\t\t}else\r\n\t\t\tif(equals(node.getRemainderValue(), key, i)){\r\n\t\t\t\tif(isLast){\r\n\t\t\t\t\tnode.saveValue(rowOffset);\r\n\t\t\t\t\treturn null;\r\n\t\t\t\t}\r\n\t\t\t\treturn node.addRoot();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * Remove all entries\r\n\t */\r\n\tfinal void clear(){\r\n\t\trootPage.clear();\r\n\t}\r\n\t/*================================================================\r\n\t * Normalize functions\r\n\t * convert the value to a binary with identical sort order \r\n\t * like the original values. \r\n\t ================================================================*/\r\n\t\r\n\t\r\n\tfinal static private int floatToBinarySortOrder(float value){\r\n\t\tint intValue = Float.floatToIntBits(value);\r\n\t\treturn (intValue<0) ?\r\n\t\t\t~intValue :\r\n\t\t\tintValue ^ 0x80000000;\t\t\t\r\n\t}\r\n\t\r\n\tfinal static private long doubleToBinarySortOrder(double value){\r\n\t\tlong intValue = Double.doubleToLongBits(value);\r\n\t\treturn (intValue<0) ?\r\n\t\t\t~intValue :\r\n\t\t\tintValue ^ 0x8000000000000000L;\t\t\t\r\n\t}\r\n\t\r\n\tfinal static private int shortToBinarySortOrder(int value){\r\n\t\treturn value ^ 0x8000;\r\n\t}\r\n\t\r\n\tfinal static private int intToBinarySortOrder(int value){\r\n\t\treturn value ^ 0x80000000;\r\n\t}\r\n\t\r\n\tfinal static private long longToBinarySortOrder(long value){\r\n\t\treturn value ^ 0x8000000000000000L;\r\n\t}\r\n\t\r\n\t\r\n\tfinal static private char[] stringToBinarySortOrder(String value, boolean needTrim){\r\n\t\tint length = value.length();\r\n\t\tif(needTrim){\r\n\t\t\twhile(length > 0 && value.charAt(length-1) == ' ') length--;\r\n\t\t}\r\n\t\tchar[] puffer = new char[length];\r\n\t\tfor(int i=0; i<length; i++){\r\n\t\t\tpuffer[i] = Character.toLowerCase(Character.toUpperCase( value.charAt(i) ));\r\n\t\t}\r\n\t\treturn puffer;\r\n\t}\r\n\t\r\n\t\r\n\tfinal static private char[] bytesToBinarySortOrder(byte[] value){\r\n\t\tint length = value.length;\r\n\t\tchar[] puffer = new char[length];\r\n\t\tfor(int i=0; i<length; i++){\r\n\t\t\tpuffer[i] = (char)(value[i] & 0xFF);\r\n\t\t}\r\n\t\treturn puffer;\r\n\t}\r\n\t\r\n\t\r\n\tfinal static private char[] numericToBinarySortOrder(MutableNumeric numeric){\r\n\t\tint[] value = numeric.getInternalValue();\r\n\t\tint count = 1;\r\n\t\tint i;\r\n\t\tfor(i=0; i<value.length; i++){\r\n\t\t\tif(value[i] != 0){\r\n\t\t\t\tcount = 2*(value.length - i)+1;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tchar[] puffer = new char[count];\r\n\t\tpuffer[0] = (char)count;\r\n\t\tfor(int c=1; c<count;){\r\n\t\t\tpuffer[c++] = (char)(value[i] >> 16);\r\n\t\t\tpuffer[c++] = (char)value[i++];\r\n\t\t}\r\n\t\treturn puffer;\r\n\t}\r\n\t\r\n\t\r\n\t/*================================================================\r\n\t * \r\n\t * Functions  for reading the index.\r\n\t *\r\n\t ================================================================*/\r\n\t\r\n\t\r\n\t\r\n\tprivate final boolean equals(char[] src1, char[] src2, int offset2){\r\n\t\tif(src1 == null) return false;\r\n\t\tint length = src1.length;\r\n\t\tif(length != src2.length - offset2) return false;\r\n\t\tfor(int i=0; i<length; i++){\r\n\t\t\tif(src1[i] != src2[i+offset2]) return false;\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\r\n\tprivate final boolean equals(char[] src1, long src2, int charCount){\r\n\t\tif(src1 == null) return false;\r\n\t\tint length = src1.length;\r\n\t\tif(length != charCount) return false;\r\n\t\tfor(int i=0, d = charCount-1; i<length; i++){\r\n\t\t\tif(src1[i] != (char)((src2 >> (d-- << 4)))) return false;\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n}\r\n"},{"path":"/src/smallsql/junit/TestFunctions.java","source":"/* =============================================================\r\n * SmallSQL : a free Java DBMS library for the Java(tm) platform\r\n * =============================================================\r\n *\r\n * (C) Copyright 2004-2007, by Volker Berlin.\r\n *\r\n * Project Info:  http://www.smallsql.de/\r\n *\r\n * This library is free software; you can redistribute it and/or modify it \r\n * under the terms of the GNU Lesser General Public License as published by \r\n * the Free Software Foundation; either version 2.1 of the License, or \r\n * (at your option) any later version.\r\n *\r\n * This library is distributed in the hope that it will be useful, but \r\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \r\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public \r\n * License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, \r\n * USA.  \r\n *\r\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc. \r\n * in the United States and other countries.]\r\n *\r\n * ---------------\r\n * TestFunktions.java\r\n * ---------------\r\n * Author: Volker Berlin\r\n * \r\n */\r\npackage smallsql.junit;\r\n\r\nimport junit.framework.*;\r\n\r\nimport java.math.*;\r\nimport java.sql.*;\r\n\r\npublic class TestFunctions extends BasicTestCase{\r\n\r\n    private TestValue testValue;\r\n\r\n    private static final String table = \"table_functions\";\r\n\r\n    private static final TestValue[] TESTS = new TestValue[]{\r\n\t\ta(\"$3\"               \t, new BigDecimal(\"3.0000\")),\r\n\t    a(\"$-3.1\"              \t, new BigDecimal(\"-3.1000\")),\r\n\t    a(\"-$3.2\"              \t, new BigDecimal(\"-3.2000\")),\r\n\t    a(\"1 + 2\"               , new Integer(3)),\r\n        a(\"3 * 2\"               , new Integer(6)),\r\n        a(\"Top 1 4 / 2\"         , new Integer(2)),\r\n        a(\"7/3\"         \t\t, new Integer(2)),\r\n        a(\"5 - 2\"               , new Integer(3)),\r\n        a(\"- aint\"              , new Integer(120)),\r\n        a(\"5 - - 2\"             , new Integer(7)),\r\n        a(\"5 - - - 2\"           , new Integer(3)),\r\n\t\ta(\"-.123E-1\"            , new Double(\"-0.0123\")),\r\n\t\ta(\".123E-1\"             , new Double(\"0.0123\")),\r\n\t\ta(\"123e-1\"              , new Double(\"12.3\")),\r\n\t\ta(\"123E1\"               , new Double(\"1230\")),\r\n\t\ta(\"2*5+2\"               , new Integer(\"12\")),\r\n\t\ta(\"'a''b'\"              , \"a'b\"),\r\n\t\ta(\"'a\\\"b'\"              , \"a\\\"b\"),\r\n        a(\"~1\"                  , new Integer(-2)),\r\n        a(\"abs(-5)\"             , new Integer(5)),\r\n        a(\"abs(aint)\"           , new Integer(120)),\r\n        a(\"abs(\"+table+\".aint)\" , new Integer(120)),\r\n        a(\"abs(null)\"           , null),\r\n        a(\"abs(cast(5 as money))\"  , new BigDecimal(\"5.0000\")),\r\n        a(\"abs(cast(-5 as money))\" , new BigDecimal(\"5.0000\")),\r\n        a(\"abs(cast(-5 as numeric(4,2)))\" , new BigDecimal(\"5.00\")),\r\n        a(\"abs(cast(5 as real))\"   , new Float(5)),\r\n        a(\"abs(cast(-5 as real))\"  , new Float(5)),\r\n        a(\"abs(cast(-5 as float))\" , new Double(5)),\r\n        a(\"abs(cast(5 as double))\" , new Double(5)),\r\n        a(\"abs(cast(5 as smallint))\",new Integer(5)),\r\n        a(\"abs(cast(-5 as bigint))\", new Long(5)),\r\n        a(\"abs(cast(5 as bigint))\",  new Long(5)),\r\n        a(\"convert(money, abs(-5))\", new BigDecimal(\"5.0000\")),\r\n\t\ta(\"convert(varchar(30), 11)\" \t, \"11\"),\r\n\t\ta(\"convert(varchar(30), null)\" \t, null),\r\n\t\ta(\"convert(varchar(1), 12)\" \t, \"1\"),\r\n\t\ta(\"convert(char(5), 11)\" \t\t, \"11   \"),\r\n\t\ta(\"convert(longvarchar, {d '1999-10-12'})\" \t, \"1999-10-12\"),\r\n\t\ta(\"convert(binary(5), '11')\" \t, new byte[]{'1','1',0,0,0}),\r\n\t\ta(\"convert(binary(5), null)\" \t, null),\r\n\t\ta(\"convert(varbinary(5), 11)\" \t, new byte[]{0,0,0,11}),\r\n\t\ta(\"convert(longvarbinary, '11')\", new byte[]{'1','1'}),\r\n\t\ta(\"convert(varchar(30),convert(varbinary(30),'Meherban'))\", \"Meherban\"),\r\n\t\ta(\"convert(bit, 1)\" \t\t\t, Boolean.TRUE),\r\n\t\ta(\"convert(bit, false)\" \t\t, Boolean.FALSE),\r\n\t\ta(\"convert(boolean, 0)\" \t\t, Boolean.FALSE),\r\n\t\ta(\"convert(varchar(30), convert(bit, false))\" \t\t, \"0\"),\r\n\t\ta(\"convert(varchar(30), convert(boolean, 0))\" \t\t, \"false\"),\r\n\t\ta(\"convert(bigint, 11)\" \t\t, new Long(11)),\r\n\t\ta(\"convert(int, 11)\" \t\t\t, new Integer(11)),\r\n\t\ta(\"{fn convert(11, Sql_integer)}\" \t\t\t, new Integer(11)),\r\n\t\ta(\"convert(integer, 11)\" \t\t\t, new Integer(11)),\r\n\t\ta(\"convert(smallint, 123456789)\", new Integer((short)123456789)),\r\n\t\ta(\"convert(tinyint, 123456789)\"\t, new Integer(123456789 & 0xFF)),\r\n\t\ta(\"convert(date, '1909-10-12')\" , Date.valueOf(\"1909-10-12\")),\r\n\t\ta(\"convert(date, null)\" \t\t, null),\r\n\t\ta(\"convert(date, {ts '1999-10-12 15:14:13.123456'})\" \t, Date.valueOf(\"1999-10-12\")),\r\n\t\ta(\"convert(date, now())\" \t\t, Date.valueOf( new Date(System.currentTimeMillis()).toString()) ),\r\n\t\ta(\"curdate()\" \t\t\t\t\t, Date.valueOf( new Date(System.currentTimeMillis()).toString()) ),\r\n\t\ta(\"current_date()\" \t\t\t\t, Date.valueOf( new Date(System.currentTimeMillis()).toString()) ),\r\n\t\ta(\"hour(curtime())\" \t\t\t, new Integer(new Time(System.currentTimeMillis()).getHours()) ),\r\n\t\ta(\"minute({t '10:11:12'})\" \t\t, new Integer(11) ),\r\n\t\ta(\"month( {ts '1899-10-12 15:14:13.123456'})\" \t, new Integer(10)),\r\n\t\ta(\"year({d '2004-12-31'})\"    , new Integer(2004)),\r\n\t\ta(\"convert(time, '15:14:13')\" \t, Time.valueOf(\"15:14:13\")),\r\n\t\ta(\"convert(time, null)\" \t\t, null),\r\n\t\ta(\"convert(timestamp, '1999-10-12 15:14:13.123456')\" \t, Timestamp.valueOf(\"1999-10-12 15:14:13.123\")),\r\n        a(\"cast({ts '1907-06-05 04:03:02.1'} as smalldatetime)\", Timestamp.valueOf(\"1907-06-05 04:03:00.0\")),\r\n        a(\"cast({ts '2007-06-05 04:03:02.1'} as smalldatetime)\", Timestamp.valueOf(\"2007-06-05 04:03:00.0\")),\r\n\t\ta(\"convert(varchar(30), {d '1399-10-12 3:14:13'},  -1)\" \t, \"1399-10-12\"),\r\n\t\ta(\"convert(varchar(30), {ts '1999-10-12  3:14:13.12'},  99)\" \t, \"1999-10-12 03:14:13.12\"),\r\n\t\ta(\"convert(varchar(30), {ts '1999-10-12  0:14:13.123456'},   0)\" \t, getMonth3L(10) + \" 12 1999 12:14AM\"),\r\n\t\ta(\"convert(varchar(30), {ts '1999-10-12 15:14:13.123456'},   1)\" \t, \"10/12/99\"),\r\n\t\ta(\"convert(varchar(30), {ts '1999-10-12 15:14:13.123456'},   2)\" \t, \"99.10.12\"),\r\n\t\ta(\"convert(varchar(30), {ts '1999-10-12 15:14:13.123456'},   3)\" \t, \"12/10/99\"),\r\n\t\ta(\"convert(varchar(30), {ts '1999-10-12 15:14:13.123456'},   4)\" \t, \"12.10.99\"),\r\n\t\ta(\"convert(varchar(30), {ts '1999-10-12 15:14:13.123456'},   5)\" \t, \"12-10-99\"),\r\n\t\ta(\"convert(varchar(30), {ts '1999-10-12 15:14:13.123456'},   6)\" \t, \"12 \" + getMonth3L(10) + \" 99\"),\r\n\t\ta(\"convert(varchar(30), {ts '1999-10-12 15:14:13.123456'},   7)\" \t, getMonth3L(10) + \" 12, 99\"),\r\n\t\ta(\"convert(varchar(30), {ts '1999-10-12 15:14:13.123456'},   8)\" \t, \"15:14:13\"),\r\n\t\ta(\"convert(varchar(30), {ts '1999-10-12 15:14:13.123456'},   9)\" \t, getMonth3L(10) + \" 12 1999 03:14:13:123PM\"),\r\n\t\ta(\"convert(varchar(30), {ts '1999-10-12 15:14:13.123456'},  10)\" \t, \"10-12-99\"),\r\n\t\ta(\"convert(varchar(30), {ts '1999-10-12 15:14:13.123456'},  11)\" \t, \"99/10/12\"),\r\n\t\ta(\"convert(varchar(30), {ts '1999-10-12 15:14:13.123456'},  12)\" \t, \"991012\"),\r\n\t\ta(\"convert(varchar(30), {ts '1999-10-12 15:14:13.123456'},  13)\" \t, \"12 \" + getMonth3L(10) + \" 1999 15:14:13:123\"),\r\n\t\ta(\"convert(varchar(30), {ts '1999-10-12 15:14:13.123456'},  14)\" \t, \"15:14:13:123\"),\r\n\t\ta(\"convert(varchar(30), {ts '1999-10-12 15:14:13.123456'},  20)\" \t, \"1999-10-12 15:14:13\"),\r\n\t\ta(\"convert(varchar(30), {ts '1999-10-12 15:14:13.123456'},  21)\" \t, \"1999-10-12 15:14:13.123\"),\r\n\t\ta(\"convert(varchar(30), {ts '1999-10-12 15:14:13.123456'}, 100)\" \t, getMonth3L(10) + \" 12 1999 03:14PM\"),\r\n\t\ta(\"convert(varchar(30), {ts '1999-10-12 15:14:13.123456'}, 101)\" \t, \"10/12/1999\"),\r\n\t\ta(\"convert(varchar(30), {ts '1999-10-12 15:14:13.123456'}, 102)\" \t, \"1999.10.12\"),\r\n\t\ta(\"convert(varchar(30), {ts '1999-10-12 15:14:13.123456'}, 103)\" \t, \"12/10/1999\"),\r\n\t\ta(\"convert(varchar(30), {ts '1999-10-12 15:14:13.123456'}, 104)\" \t, \"12.10.1999\"),\r\n\t\ta(\"convert(varchar(30), {ts '1999-10-12 15:14:13.123456'}, 105)\" \t, \"12-10-1999\"),\r\n\t\ta(\"convert(varchar(30), {ts '1999-10-12 15:14:13.123456'}, 106)\" \t, \"12 \" + getMonth3L(10) + \" 1999\"),\r\n\t\ta(\"convert(varchar(30), {ts '1999-10-12 15:14:13.123456'}, 107)\" \t, getMonth3L(10) + \" 12, 1999\"),\r\n\t\ta(\"convert(varchar(30), {ts '1999-10-12 15:14:13.123456'}, 108)\" \t, \"15:14:13\"),\r\n\t\ta(\"convert(varchar(30), {ts '1999-10-12  3:14:13.123456'}, 109)\" \t, getMonth3L(10) + \" 12 1999 03:14:13:123AM\"),\r\n\t\ta(\"convert(varchar(30), {ts '1999-10-12 15:14:13.123456'}, 109)\" \t, getMonth3L(10) + \" 12 1999 03:14:13:123PM\"),\r\n\t\ta(\"convert(varchar(30), {ts '1999-10-12 15:14:13.123456'}, 110)\" \t, \"10-12-1999\"),\r\n\t\ta(\"convert(varchar(30), {ts '1999-10-12 15:14:13.123456'}, 111)\" \t, \"1999/10/12\"),\r\n\t\ta(\"convert(varchar(30), {ts '1999-10-12 15:14:13.123456'}, 112)\" \t, \"19991012\"),\r\n\t\ta(\"convert(varchar(30), {ts '1999-10-12 15:14:13.123456'}, 113)\" \t, \"12 \" + getMonth3L(10) + \" 1999 15:14:13:123\"),\r\n\t\ta(\"convert(varchar(30), {ts '1999-10-12 15:14:13.123456'}, 114)\" \t, \"15:14:13:123\"),\r\n\t\ta(\"convert(varchar(30), {ts '1999-10-12 15:14:13.123456'}, 120)\" \t, \"1999-10-12 15:14:13\"),\r\n\t\ta(\"convert(varchar(30), {ts '1999-10-12 15:14:13.123456'}, 121)\" \t, \"1999-10-12 15:14:13.123\"),\r\n\t\ta(\"convert(varchar(30), {ts '1999-10-12 15:14:13.123456'}, 126)\" \t, \"1999-10-12T15:14:13.123\"),\r\n\t\ta(\"convert(varchar(30), {ts '1999-10-12  3:14:13.123456'}, 130)\" \t, \"12 \" + getMonth3L(10) + \" 1999 03:14:13:123AM\"),\r\n\t\ta(\"convert(varchar(30), {ts '1999-10-12 15:14:13.123456'}, 130)\" \t, \"12 \" + getMonth3L(10) + \" 1999 03:14:13:123PM\"),\r\n\t\ta(\"convert(varchar(30), {ts '1999-10-12 15:14:13.123456'}, 131)\" \t, \"12/10/99 15:14:13:123\"),\r\n\t\ta(\"convert(timestamp, null)\" \t, null),\r\n\t\ta(\"convert(real, 11)\" \t\t\t, new Float(11)),\r\n\t\ta(\"convert(real, null)\" \t\t, null),\r\n\t\ta(\"convert(float, 11.0)\" \t\t, new Double(11)),\r\n\t\ta(\"convert(double, '11')\" \t\t, new Double(11)),\r\n\t\ta(\"-convert(decimal, '11.123456')\" \t\t, new BigDecimal(\"-11\")),\r\n\t\ta(\"-convert(decimal(38,6), '11.123456')\" \t\t, new BigDecimal(\"-11.123456\")),\r\n\t\ta(\"convert(decimal(38,6), '11.123456') + 1\" \t\t, new BigDecimal(\"12.123456\")),\r\n\t\ta(\"convert(decimal(38,6), '11.123456') - 1\" \t\t, new BigDecimal(\"10.123456\")),\r\n\t\ta(\"convert(decimal(12,2), '11.0000') * 1\" \t\t, new BigDecimal(\"11.00\")),\r\n\t\ta(\"convert(decimal(12,2), '11.0000') * convert(decimal(12,2), 1)\" \t\t, new BigDecimal(\"11.0000\")),\r\n\t\ta(\"convert(decimal(12,2), '11.0000') / 1\" \t\t, new BigDecimal(\"11.0000000\")), //scale = Max(left scale+5, right scale +4)\r\n\t\ta(\"convert(decimal(12,0), 11) / convert(decimal(12,2), 1)\" \t\t, new BigDecimal(\"11.000000\")), //scale = Max(left scale+5, right scale +4)\r\n\t\ta(\"convert(money, -10000 / 10000.0)\" \t\t, new BigDecimal(\"-1.0000\")), //scale = Max(left scale+5, right scale +4)\r\n\t\ta(\"-convert(money, '11.123456')\" \t\t, new BigDecimal(\"-11.1235\")),\r\n\t\ta(\"-convert(smallmoney, '11.123456')\" \t, new BigDecimal(\"-11.1235\")),\r\n\t\ta(\"convert(uniqueidentifier, 0x12345678901234567890)\" \t, \"78563412-1290-5634-7890-000000000000\"),\r\n\t\ta(\"convert(uniqueidentifier, '78563412-1290-5634-7890-000000000000')\" \t, \"78563412-1290-5634-7890-000000000000\"),\r\n\t\ta(\"convert(binary(16), convert(uniqueidentifier, 0x12345678901234567890))\" \t, new byte[]{0x12,0x34,0x56,0x78,(byte)0x90,0x12,0x34,0x56,0x78,(byte)0x90,0,0,0,0,0,0}),\r\n\t\ta(\"Timestampdiff(day,         {d '2004-10-12'}, {d '2004-10-14'})\" \t\t, new Integer(2)),\r\n\t\ta(\"Timestampdiff(SQL_TSI_DAY, {d '2004-10-12'}, {d '2004-10-15'})\" \t\t, new Integer(3)),\r\n\t\ta(\"Timestampdiff(d,           {d '2004-10-12'}, {d '2004-10-16'})\" \t\t, new Integer(4)),\r\n\t\ta(\"Timestampdiff(dd,          {d '2004-10-12'}, {d '2004-10-17'})\" \t\t, new Integer(5)),\r\n\t\ta(\"Timestampdiff(SQL_TSI_YEAR,{d '2000-10-12'}, {d '2005-10-17'})\" \t\t, new Integer(5)),\r\n\t\ta(\"Timestampdiff(year,\t\t\t{d '2000-10-12'}, {d '2005-10-17'})\" \t\t, new Integer(5)),\r\n\t\ta(\"Timestampdiff(SQL_TSI_QUARTER,{d '2000-10-12'}, {d '2005-10-17'})\" \t, new Integer(20)),\r\n\t\ta(\"Timestampdiff(quarter,\t\t{d '2000-10-12'}, {d '2005-10-17'})\" \t, new Integer(20)),\r\n\t\ta(\"Timestampdiff(SQL_TSI_MONTH,\t{d '2004-10-12'}, {d '2005-11-17'})\" \t, new Integer(13)),\r\n\t\ta(\"Timestampdiff(month,\t\t\t{d '2004-10-12'}, {d '2005-11-17'})\" \t, new Integer(13)),\r\n\t\ta(\"Timestampdiff(SQL_TSI_WEEK,\t{d '2004-10-09'}, {d '2004-10-12'})\" \t\t, new Integer(1)),\r\n\t\ta(\"Timestampdiff(week,\t\t\t{d '2004-10-09'}, {d '2004-10-12'})\" \t\t, new Integer(1)),\r\n\t\ta(\"Timestampdiff(SQL_TSI_HOUR,\t{d '2004-10-12'}, {d '2004-10-13'})\" \t\t, new Integer(24)),\r\n\t\ta(\"Timestampdiff(hour,\t\t\t{d '2004-10-12'}, {d '2004-10-13'})\" \t\t, new Integer(24)),\r\n\t\ta(\"Timestampdiff(SQL_TSI_MINUTE,{t '10:10:10'}, {t '11:11:11'})\" \t\t, new Integer(61)),\r\n\t\ta(\"Timestampdiff(minute,\t\t{t '10:10:10'}, {t '11:11:11'})\" \t\t, new Integer(61)),\r\n\t\ta(\"Timestampdiff(SQL_TSI_SECOND,{t '00:00:10'}, {t '00:10:11'})\" \t\t, new Integer(601)),\r\n\t\ta(\"Timestampdiff(second,\t\t{t '00:00:10'}, {t '00:10:11'})\" \t\t, new Integer(601)),\r\n\t\ta(\"Timestampdiff(SQL_TSI_FRAC_SECOND,{ts '2004-10-12 00:00:10.1'}, {ts '2004-10-12 00:00:10.2'})\" \t\t, new Integer(100)),\r\n\t\ta(\"Timestampdiff(millisecond,{ts '2004-10-12 00:00:10.1'}, {ts '2004-10-12 00:00:10.2'})\" \t\t, new Integer(100)),\r\n\t\ta(\"{fn TimestampAdd(SQL_TSI_YEAR,     1, {d '2004-10-17'})}\" \t\t, Timestamp.valueOf(\"2005-10-17 00:00:00.0\")),\r\n        a(\"{fn TimestampAdd(SQL_TSI_QUARTER,  1, {d '2004-10-17'})}\"        , Timestamp.valueOf(\"2005-01-17 00:00:00.0\")),\r\n        a(\"{fn TimestampAdd(SQL_TSI_MONTH,    1, {d '2004-10-17'})}\"        , Timestamp.valueOf(\"2004-11-17 00:00:00.0\")),\r\n        a(\"{fn TimestampAdd(SQL_TSI_WEEK,     1, {d '2004-10-17'})}\"        , Timestamp.valueOf(\"2004-10-24 00:00:00.0\")),\r\n        a(\"{fn TimestampAdd(SQL_TSI_HOUR,     1, {d '2004-10-17'})}\"        , Timestamp.valueOf(\"2004-10-17 01:00:00.0\")),\r\n        a(\"{fn TimestampAdd(SQL_TSI_MINUTE,  61, {d '2004-10-17'})}\"        , Timestamp.valueOf(\"2004-10-17 01:01:00.0\")),\r\n        a(\"{fn TimestampAdd(SQL_TSI_SECOND,  61, {d '2004-10-17'})}\"        , Timestamp.valueOf(\"2004-10-17 00:01:01.0\")),\r\n        a(\"{fn TimestampAdd(SQL_TSI_FRAC_SECOND,1,{d '2004-10-17'})}\"       , Timestamp.valueOf(\"2004-10-17 00:00:00.001\")),\r\n\t\ta(\"Timestampdiff(second, null, {t '00:10:11'})\" \t\t, null),\r\n\t\ta(\"Timestampdiff(second, {t '00:10:11'}, null)\" \t\t, null),\r\n\t\ta(\"TimestampAdd(year,     1, null)\" \t\t, null),\r\n\t\ta(\"DayOfWeek({d '2006-02-16'})\" \t\t, new Integer(4)),\r\n\t\ta(\"DayOfWeek({d '2006-02-19'})\" \t\t, new Integer(7)),\r\n\t\ta(\"DayOfYear({d '2004-01-01'})\" \t\t, new Integer(1)),\r\n\t\ta(\"DayOfYear({d '2004-02-29'})\" \t\t, new Integer(60)),\r\n\t\ta(\"DayOfYear({d '2004-03-01'})\" \t\t, new Integer(61)),\r\n\t\ta(\"DayOfYear({d '2004-12-31'})\" \t\t, new Integer(366)),\r\n\t\ta(\"DayOfMonth({d '1904-07-17'})\" \t\t, new Integer(17)),\r\n\t\ta(\"locate('ae', 'QWAERAE')\"\t\t, new Integer(3)),\r\n\t\ta(\"locate('ae', 'QWAERAE', 3)\"\t, new Integer(3)),\r\n\t\ta(\"locate('ae', 'QWAERAE', 4)\"\t, new Integer(6)),\r\n\t\ta(\"locate('ae', 'QWAERAE', null)\"\t\t, new Integer(3)),\r\n\t\ta(\"locate(null, 'QWAERAE', 4)\"\t, null),\r\n\t\ta(\"locate('ae', null, 4)\"\t, null),\r\n\t\ta(\"{d '2004-10-12'}\"\t, \t\t\t\tjava.sql.Date.valueOf(\"2004-10-12\")),\r\n\t\ta(\"{ts '1999-10-12 15:14:13.123'}\"\t, \tTimestamp.valueOf(\"1999-10-12 15:14:13.123\")),\r\n\t\ta(\"{t '15:14:13'}\"\t, \t\t\t\t\tTime.valueOf(\"15:14:13\")),\r\n\t\ta(\"{fn length('abc')}\", \t\t\t\tnew Integer(3)),\r\n\t\ta(\"{fn length('abc ')}\", \t\t\t\tnew Integer(3)),\r\n\t\ta(\"{fn length(null)}\", \t\t\t\t\tnull),\r\n\t\ta(\"{fn Right('qwertzu', 3)}\", \t\t\t\"tzu\"),\r\n\t\ta(\"{fn Right('qwertzu', 13)}\", \t\t\t\"qwertzu\"),\r\n\t\ta(\"cast( Right('1234', 2) as real)\", \tnew Float(34)),\r\n\t\ta(\"cast( Right('1234', 2) as smallint)\",new Integer(34)),\r\n\t\ta(\"cast( Right('1234', 2) as boolean)\", Boolean.TRUE),\r\n\t\ta(\"right(0x1234567890, 2)\",\t\t\t\tnew byte[]{0x78,(byte)0x90}),\r\n\t\ta(\"right(null, 2)\",\t\t\t\t\t\tnull),\r\n        a(\"left(null, 2)\",                      null),\r\n        a(\"left('abcd', 2)\",                    \"ab\"),\r\n        a(\"left(0x1234567890, 2)\",              new byte[]{0x12,(byte)0x34}),\r\n\t\ta(\"cast({fn SubString('ab2.3qw', 3, 3)} as double)\", \tnew Double(2.3)),\r\n\t\ta(\"subString('qwert', 99, 2)\", \t\t\"\"),\r\n\t\ta(\"{fn SubString(0x1234567890, 0, 99)}\",new byte[]{0x12,0x34,0x56,0x78,(byte)0x90}),\r\n\t\ta(\"{fn SubString(0x1234567890, 2, 2)}\", new byte[]{0x34, 0x56}),\r\n\t\ta(\"{fn SubString(0x1234567890, 99, 2)}\", new byte[]{}),\r\n\t\ta(\"SubString(null, 99, 2)\", \t\t\tnull),\r\n        a(\"Insert('abcd', 2, 1, 'qw')\",         \"aqwcd\"),\r\n        a(\"Insert(0x1234, 2, 0, 0x56)\",         new byte[]{0x12,0x56,0x34}),\r\n        a(\"STUFF(null, 2, 0, 0x56)\",         \tnull),\r\n        a(\"lcase('Abcd')\",                      \"abcd\"),\r\n        a(\"ucase('Abcd')\",                      \"ABCD\"),\r\n        a(\"lcase(null)\",                        null),\r\n        a(\"ucase(null)\",                        null),\r\n        a(\"cast(1 as money) + SubString('a12', 2, 2)\",new BigDecimal(\"13.0000\")),\r\n        a(\"cast(1 as numeric(5,2)) + SubString('a12', 2, 2)\",new BigDecimal(\"13.00\")),\r\n        a(\"cast(1 as BigInt) + SubString('a12', 2, 2)\",new Long(13)),\r\n        a(\"cast(1 as real) + SubString('a12', 2, 2)\",new Float(13)),\r\n        a(\"1   + SubString('a12', 2, 2)\",       new Integer(13)),\r\n        a(\"1.0 + SubString('a12', 2, 2)\",       new Double(13)),\r\n        a(\"concat('abc', 'def')\",               \"abcdef\"),\r\n\t\ta(\"{fn IfNull(null, 'abc')}\", \t\t\t\"abc\"),\r\n\t\ta(\"{fn IfNull('asd', 'abc')}\", \t\t\t\"asd\"),\r\n\t\ta(\"iif(true, 1, 2)\", \t\t\t\t\tnew Integer(1)),\r\n\t\ta(\"iif(false, 1, 2)\", \t\t\t\t\tnew Integer(2)),\r\n\t\ta(\"CASE aVarchar WHEN 'qwert' THEN 25 WHEN 'asdfg' THEN 26 ELSE null END\", new Integer(25)),\r\n\t\ta(\"CASE WHEN aVarchar='qwert' THEN 'uu' WHEN aVarchar='bb' THEN 'gg' ELSE 'nn' END\", \"uu\"),\r\n\t\ta(\"{fn Ascii('')}\", \t\t\tnull),\r\n\t\ta(\"{fn Ascii(null)}\", \t\t\tnull),\r\n\t\ta(\"Ascii('abc')\", \t\t\t\tnew Integer(97)),\r\n\t\ta(\"{fn Char(97)}\", \t\t\t\t\"a\"),\r\n\t\ta(\"Char(null)\", \t\t\t\tnull),\r\n        a(\"$1 + Char(49)\",              new BigDecimal(\"2.0000\")),\r\n\t\ta(\"Exp(null)\", \t\t\t\t\tnull),\r\n\t\ta(\"exp(0)\", \t\t\t\t\tnew Double(1)),\r\n\t\ta(\"log(exp(2.4))\", \t\t\t\tnew Double(2.4)),\r\n\t\ta(\"log10(10)\", \t\t\t\t\tnew Double(1)),\r\n\t\ta(\"cos(null)\", \t\t\t\t\tnull),\r\n\t\ta(\"cos(0)\", \t\t\t\t\tnew Double(1)),\r\n\t\ta(\"acos(1)\", \t\t\t\t\tnew Double(0)),\r\n\t\ta(\"sin(0)\", \t\t\t\t\tnew Double(0)),\r\n\t\ta(\"cos(pi())\", \t\t\t\t\tnew Double(-1)),\r\n\t\ta(\"asin(0)\", \t\t\t\t\tnew Double(0)),\r\n\t\ta(\"asin(sin(0.5))\",\t\t\t\tnew Double(0.5)),\r\n\t\ta(\"tan(0)\", \t\t\t\t\tnew Double(0)),\r\n\t\ta(\"atan(tan(0.5))\",\t\t\t\tnew Double(0.5)),\r\n\t\ta(\"atan2(0,3)\",\t\t\t\t\tnew Double(0)),\r\n\t\ta(\"atan2(0,-3)\",\t\t\t\tnew Double(Math.PI)),\r\n\t\ta(\"atn2(0,null)\",\t\t\t\tnull),\r\n\t\ta(\"cot(0)\",\t\t\t\t\t\tnew Double(Double.POSITIVE_INFINITY)),\r\n\t\ta(\"tan(0)\", \t\t\t\t\tnew Double(0)),\r\n\t\ta(\"degrees(pi())\", \t\t\t\tnew Double(180)),\r\n\t\ta(\"degrees(radians(50))\", \t\tnew Double(50)),\r\n\t\ta(\"ceiling(123.45)\", \t\t\tnew Double(124)),\r\n\t\ta(\"ceiling(-123.45)\", \t\t\tnew Double(-123)),\r\n\t\ta(\"power(2, 3)\", \t\t\t\tnew Double(8)),\r\n\t\ta(\"5.0 % 2\", \t\t\t\t\tnew Double(1)),\r\n\t\ta(\"5 % 2\", \t\t\t\t\t\tnew Integer(1)),\r\n\t\ta(\"mod(5, 2)\", \t\t\t\t\tnew Integer(1)),\r\n\t\ta(\"FLOOR(123.45)\", \t\t\t\tnew Double(123)),\r\n\t\ta(\"FLOOR('123.45')\", \t\t\tnew Double(123)),\r\n\t\ta(\"FLOOR(-123.45)\", \t\t\tnew Double(-124)),\r\n\t\ta(\"FLOOR($123.45)\", \t\t\tnew BigDecimal(\"123.0000\")),\r\n\t\ta(\"Rand(0)\", \t\t\t\t\tnew Double(0.730967787376657)),\r\n\t\ta(\"ROUND(748.58, -4)\", \t\t\tnew Double(0)),\r\n\t\ta(\"ROUND(-748.58, -2)\", \t\tnew Double(-700)),\r\n\t\ta(\"ROUND('748.5876', 2)\", \t\tnew Double(748.59)),\r\n        a(\"round( 1e19, 0)\"       , new Double(1e19)),\r\n        a(\"truncate( -1e19,0)\"      , new Double(-1e19)),\r\n\t\ta(\"Sign('748.5876')\", \t\t\tnew Integer(1)),\r\n\t\ta(\"Sign(-2)\", \t\t\t\t\tnew Integer(-1)),\r\n        a(\"Sign(2)\",                    new Integer(1)),\r\n        a(\"Sign(0)\",                    new Integer(0)),\r\n        a(\"Sign(-$2)\",                  new Integer(-1)),\r\n        a(\"Sign($2)\",                   new Integer(1)),\r\n        a(\"Sign($0)\",                   new Integer(0)),\r\n        a(\"Sign(cast(-2 as bigint))\",   new Integer(-1)),\r\n        a(\"Sign(cast(2 as bigint))\",    new Integer(1)),\r\n        a(\"Sign(cast(0 as bigint))\",    new Integer(0)),\r\n        a(\"Sign(1.0)\",                  new Integer(1)),\r\n\t\ta(\"Sign(0.0)\", \t\t\t\t\tnew Integer(0)),\r\n        a(\"Sign(-.1)\",                  new Integer(-1)),\r\n        a(\"Sign(cast(0 as numeric(5)))\",new Integer(0)),\r\n\t\ta(\"Sign(null)\", \t\t\t\tnull),\r\n\t\ta(\"sqrt(9)\", \t\t\t\t\tnew Double(3)),\r\n\t\ta(\"Truncate(748.58, -4)\", \t\tnew Double(0)),\r\n\t\ta(\"Truncate(-748.58, -2)\", \t\tnew Double(-700)),\r\n\t\ta(\"Truncate('748.5876', 2)\", \tnew Double(748.58)),\r\n        a(\"rtrim(null)\",                null),\r\n        a(\"rtrim(0x0012345600)\",        new byte[]{0x00,0x12,0x34,0x56}),\r\n        a(\"rtrim(' abc ')\",             \" abc\"),\r\n        a(\"ltrim(null)\",                null),\r\n        a(\"ltrim(0x0012345600)\",        new byte[]{0x12,0x34,0x56,0x00}),\r\n        a(\"ltrim(' abc ')\",             \"abc \"),\r\n        a(\"space(3)\",                   \"   \"),\r\n        a(\"space(null)\",                null),\r\n        a(\"space(-3)\",                  null),\r\n        a(\"replace('abcabc','bc','4')\", \"a4a4\"),\r\n        a(\"replace('abcabc','bc',null)\",null),\r\n        a(\"replace('abcabc','','4')\",   \"abcabc\"),\r\n        a(\"replace(0x123456,0x3456,0x77)\", new byte[]{0x12,0x77}),\r\n        a(\"replace(0x123456,0x,0x77)\",  new byte[]{0x12,0x34,0x56}),\r\n        a(\"replace(0x123456,0x88,0x77)\",new byte[]{0x12,0x34,0x56}),\r\n        a(\"repeat('ab',4)\",             \"abababab\"),\r\n        a(\"repeat(null,4)\",             null),\r\n        a(\"repeat(0x1234,3)\",           new byte[]{0x12,0x34,0x12,0x34,0x12,0x34}),\r\n        a(\"DIFFERENCE('Green','Greene')\",new Integer(4)),\r\n        a(\"DIFFERENCE('Green',null)\",   null),\r\n        a(\"OCTET_LENGTH('SomeWord')\",   new Integer(16)),\r\n        a(\"OCTET_LENGTH('')\",   \t\tnew Integer(0)),\r\n        a(\"OCTET_LENGTH(null)\",   \t\tnull),\r\n        a(\"BIT_LENGTH('SomeWord')\",     new Integer(128)),\r\n        a(\"BIT_LENGTH('')\",   \t\t    new Integer(0)),\r\n        a(\"BIT_LENGTH(null)\",   \t\tnull),\r\n        a(\"CHAR_LENGTH('SomeWord')\",    new Integer(8)),\r\n        a(\"CHAR_LENGTH('')\",   \t\t    new Integer(0)),\r\n        a(\"CHAR_LENGTH(null)\",   \t\tnull),\r\n        a(\"CHARACTER_LENGTH('SomeWord')\", new Integer(8)),\r\n        a(\"CHARACTER_LENGTH('')\",   \tnew Integer(0)),\r\n        a(\"CHARACTER_LENGTH(null)\",   \tnull),\r\n        a(\"soundex('Wikipedia')\",       \"W213\"),\r\n        a(\"0x10 < 0x1020\",              Boolean.TRUE),\r\n\t};\r\n\r\n\r\n    private static TestValue a(String function, Object result){\r\n        TestValue value = new TestValue();\r\n        value.function  = function;\r\n        value.result    = result;\r\n        return value;\r\n    }\r\n\r\n    TestFunctions(TestValue testValue){\r\n        super(testValue.function);\r\n        this.testValue = testValue;\r\n    }\r\n    \r\n\r\n    public void tearDown(){\r\n        try{\r\n            Connection con = AllTests.getConnection();\r\n            Statement st = con.createStatement();\r\n            st.execute(\"drop table \" + table);\r\n            st.close();\r\n        }catch(Throwable e){\r\n            //e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    public void setUp(){\r\n        tearDown();\r\n        try{\r\n            Connection con = AllTests.getConnection();\r\n            Statement st = con.createStatement();\r\n            st.execute(\"create table \" + table + \"(aInt int, aVarchar varchar(100))\");\r\n            st.execute(\"Insert into \" + table + \"(aInt, aVarchar) Values(-120,'qwert')\");\r\n            st.close();\r\n        }catch(Throwable e){\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    public void runTest() throws Exception{\r\n    \tString query = \"Select \" + testValue.function + \",5 from \" + table;\r\n\t\tassertEqualsRsValue( testValue.result, query);\r\n        if(!testValue.function.startsWith(\"Top\")){\r\n            assertEqualsRsValue( testValue.result, \"Select \" + testValue.function + \" from \" + table + \" Group By \" + testValue.function);\r\n        }\r\n    }\r\n\r\n    public static Test suite() throws Exception{\r\n        TestSuite theSuite = new TestSuite(\"Functions\");\r\n        for(int i=0; i<TESTS.length; i++){\r\n            theSuite.addTest(new TestFunctions( TESTS[i] ) );\r\n        }\r\n        return theSuite;\r\n    }\r\n\r\n    private static class TestValue{\r\n        String function;\r\n        Object result;\r\n    }\r\n}"},{"path":"/src/smallsql/database/Table.java","source":"/* =============================================================\r\n * SmallSQL : a free Java DBMS library for the Java(tm) platform\r\n * =============================================================\r\n *\r\n * (C) Copyright 2004-2011, by Volker Berlin.\r\n *\r\n * Project Info:  http://www.smallsql.de/\r\n *\r\n * This library is free software; you can redistribute it and/or modify it \r\n * under the terms of the GNU Lesser General Public License as published by \r\n * the Free Software Foundation; either version 2.1 of the License, or \r\n * (at your option) any later version.\r\n *\r\n * This library is distributed in the hope that it will be useful, but \r\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \r\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public \r\n * License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, \r\n * USA.  \r\n *\r\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc. \r\n * in the United States and other countries.]\r\n *\r\n * ---------------\r\n * Table.java\r\n * ---------------\r\n * Author: Volker Berlin\r\n * \r\n */\r\npackage smallsql.database;\r\n\r\nimport java.io.*;\r\nimport java.nio.ByteBuffer;\r\nimport java.nio.channels.FileChannel;\r\nimport java.sql.*;\r\nimport java.util.ArrayList;\r\nimport java.util.HashMap;\r\nimport java.util.Iterator;\r\nimport java.util.List;\r\nimport smallsql.database.language.Language;\r\n\r\nclass Table extends TableView{\r\n\t\r\n\tprivate static final int INDEX = 1;\r\n\r\n    final Database database;\r\n    FileChannel raFile; // file handle of the table\r\n\tprivate Lobs lobs; // file handle of lob data for this table\r\n    long firstPage; // offset of the first page\r\n\r\n\tfinal private HashMap locks = new HashMap();\r\n\tprivate SSConnection tabLockConnection; // if set then it is the Connection with a LOCK_TAB\r\n\tprivate int tabLockCount;\r\n\t/** if set then it is the Connection with a LOCK_WRITE_TAB */\r\n\tfinal private ArrayList locksInsert = new ArrayList(); // liste der LOCK_INSERT\r\n\tfinal private HashMap serializeConnections = new HashMap();\r\n\tfinal IndexDescriptions indexes;\r\n\tfinal ForeignKeys references;\r\n\r\n\r\n\t/**\r\n\t * Constructor for read existing tables.\r\n\t */\r\n    Table( Database database, SSConnection con, String name, FileChannel raFile, long offset, int tableFormatVersion) throws Exception{\r\n        super( name, new Columns() );\r\n        this.database = database;\r\n        this.raFile   = raFile;\r\n\t\tthis.firstPage = offset;\r\n\t\tStoreImpl store = getStore(con, firstPage, SQLTokenizer.SELECT);\r\n        if(store == null){\r\n            throw SmallSQLException.create(Language.TABLE_FILE_INVALID, getFile(database));\r\n        }\r\n\t\tint count = store.readInt();\r\n\r\n\t\tfor(int i=0; i<count; i++){\r\n\t\t\tcolumns.add( store.readColumn(tableFormatVersion) );\r\n\t\t}\r\n\t\tindexes = new IndexDescriptions();\r\n        references = new ForeignKeys();\r\n\t\t\r\n\t\t// read additional informations\r\n\t\tint type;\r\n\t\twhile((type = store.readInt()) != 0){\r\n\t\t\tint offsetInPage = store.getCurrentOffsetInPage();\r\n\t\t\tint size = store.readInt();\r\n\t\t\tswitch(type){\r\n\t\t\t\tcase INDEX:\r\n\t\t\t\t\tindexes.add( IndexDescription.load( database, this, store) );\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tstore.setCurrentOffsetInPage(offsetInPage + size);\r\n\t\t}\r\n\t\t\r\n\t\tfirstPage = store.getNextPagePos();\r\n    }\r\n    \r\n\r\n    /**\r\n     * Constructor for creating of new tables.\r\n     */\r\n    Table(Database database, SSConnection con, String name, Columns columns, IndexDescriptions indexes, ForeignKeys foreignKeys) throws Exception{\r\n        this(database, con, name, columns, null, indexes, foreignKeys);\r\n    }\r\n    \r\n    /**\r\n     * Constructor for alter an existing tables.\r\n     */\r\n    Table(Database database, SSConnection con, String name, Columns columns, IndexDescriptions existIndexes, IndexDescriptions newIndexes, ForeignKeys foreignKeys) throws Exception{\r\n        super( name, columns );\r\n        this.database = database;\r\n        this.references = foreignKeys;\r\n        newIndexes.create(con, database, this);\r\n        if(existIndexes == null){\r\n            this.indexes = newIndexes;\r\n        }else{\r\n            this.indexes = existIndexes;\r\n            existIndexes.add(newIndexes);\r\n        }\r\n        \r\n        write(con);\r\n        for(int i=0; i<foreignKeys.size(); i++){\r\n            ForeignKey foreignKey = foreignKeys.get(i);\r\n            Table pkTable = (Table)database.getTableView(con, foreignKey.pkTable);\r\n            pkTable.references.add(foreignKey);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Constructor for extends class Lobs.\r\n     */\r\n    Table(Database database, String name){\r\n    \tsuper( name, null);\r\n    \tthis.database = database;\r\n\t\tindexes = null;\r\n        references = null;\r\n    }\r\n\r\n\t/**\r\n\t * Drop the Table. This method is static that the file does not need to load and also corrupt files can be dropped.\r\n\t */ \r\n    static void drop(Database database, String name) throws Exception{\r\n        boolean ok = new File( Utils.createTableViewFileName( database, name ) ).delete();\r\n        if(!ok) throw SmallSQLException.create(Language.TABLE_CANT_DROP, name);\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Drop a loaded table.\r\n     *\r\n     */\r\n    void drop(SSConnection con) throws Exception{\r\n\t\tTableStorePage storePage = requestLock( con, SQLTokenizer.CREATE, -1 );\r\n\t\tif(storePage == null){\r\n\t\t\tthrow SmallSQLException.create(Language.TABLE_CANT_DROP_LOCKED, name);\r\n        }\r\n\t\t// remove the all commits that point to this table\r\n\t\tcon.rollbackFile(raFile);\r\n\t\tclose();\r\n\t\tif(lobs != null)\r\n\t\t\tlobs.drop(con);\r\n\t\tif(indexes != null)\r\n\t\t\tindexes.drop(database);\r\n\t\tboolean ok = getFile(database).delete();\r\n\t\tif(!ok) throw SmallSQLException.create(Language.TABLE_CANT_DROP, name);\r\n    }\r\n    \r\n\r\n    /**\r\n     * Closed the file handle that the object can be garbaged.\r\n     */\r\n    @Override\r\n    void close() throws Exception{\r\n        if(indexes != null)\r\n            indexes.close();\r\n        raFile.close();\r\n        raFile = null;\r\n        if( lobs != null ){\r\n            lobs.close();\r\n            lobs = null;\r\n        }\r\n    }\r\n\r\n\r\n    private void write(SSConnection con) throws Exception{\r\n        raFile = createFile( con, database );\r\n        firstPage = 8;\r\n        StoreImpl store = getStore( con, firstPage, SQLTokenizer.CREATE);\r\n        int count = columns.size();\r\n        store.writeInt( count );\r\n        for(int i=0; i<count; i++){\r\n            store.writeColumn(columns.get(i));\r\n        }\r\n\r\n\t\t// write additional informations\r\n\t\tfor(int i=0; i<indexes.size(); i++){\r\n\t\t\tIndexDescription indexDesc = indexes.get(i);\r\n\t\t\tstore.writeInt( INDEX );\r\n\t\t\tint offsetStart = store.getCurrentOffsetInPage();\r\n\t\t\tstore.setCurrentOffsetInPage( offsetStart + 4 ); // place holder for length\r\n\t\t\t\r\n\t\t\t// write the IndexDescription\r\n\t\t\tindexDesc.save(store);\r\n\t\t\t\r\n\t\t\t// write the length information\r\n\t\t\tint offsetEnd = store.getCurrentOffsetInPage();\r\n\t\t\tstore.setCurrentOffsetInPage( offsetStart );\r\n\t\t\tstore.writeInt( offsetEnd - offsetStart);\r\n\t\t\tstore.setCurrentOffsetInPage( offsetEnd );\r\n\t\t}\r\n\t\tstore.writeInt( 0 ); // no more additional informations\r\n\t\t\r\n\t\tstore.writeFinsh(null); //The connection parameter is null because the table header is written immediately.\r\n        firstPage = store.getNextPagePos();\r\n    }\r\n    \r\n\r\n\t@Override\r\n    void writeMagic(FileChannel raFile) throws Exception{\r\n        ByteBuffer buffer = ByteBuffer.allocate(8);\r\n        buffer.putInt(MAGIC_TABLE);\r\n        buffer.putInt(TABLE_VIEW_VERSION);\r\n        buffer.position(0);\r\n        raFile.write(buffer);\r\n\t}\r\n\t\r\n\r\n    /*StoreImpl getStoreCreate( SSConnection con, long filePos ) throws Exception{\r\n        return StoreImpl.createStore( con, raFile, SQLTokenizer.CREATE, filePos );\r\n    }*/\r\n\r\n    StoreImpl getStore( SSConnection con, long filePos, int pageOperation ) throws Exception{\r\n\t\tTableStorePage storePage = requestLock( con, pageOperation, filePos );\r\n        return StoreImpl.createStore( this, storePage, pageOperation, filePos );\r\n    }\r\n\r\n    \r\n\tStoreImpl getStore( TableStorePage storePage, int pageOperation ) throws Exception{\r\n\t\t// is used for not committed INSERT pages, a new lock is not needed\r\n\t\treturn StoreImpl.recreateStore( this, storePage, pageOperation );\r\n\t}\r\n\t\r\n    /*StoreImpl getStoreUpdate( SSConnection con, long filePos ) throws Exception{\r\n        return StoreImpl.createStore( con, raFile, SQLTokenizer.UPDATE, filePos );\r\n    }\r\n\r\n    StoreImpl getStoreDelete( SSConnection con, long filePos ) throws Exception{\r\n        return StoreImpl.createStore( con, raFile, SQLTokenizer.DELETE, filePos );\r\n    }*/\r\n\t\r\n\r\n    StoreImpl getStoreInsert( SSConnection con ) throws Exception{\r\n\t\tTableStorePage storePage = requestLock( con, SQLTokenizer.INSERT, -1 );\r\n        return StoreImpl.createStore( this, storePage, SQLTokenizer.INSERT, -1 );\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Create a Store that is not invoke in a transaction for copy of data.\r\n     */\r\n\tStoreImpl getStoreTemp( SSConnection con ) throws Exception{\r\n\t\tTableStorePage storePage = new TableStorePage( con, this, LOCK_NONE, -2);\r\n\t\treturn StoreImpl.createStore( this, storePage, SQLTokenizer.INSERT, -2 );\r\n\t}\r\n        \r\n\r\n\tStoreImpl getLobStore(SSConnection con, long filePos, int pageOperation) throws Exception{\r\n\t\tif(lobs == null){\r\n\t\t\tlobs = new Lobs( this );\r\n\t\t}\r\n\t\treturn lobs.getStore( con, filePos, pageOperation );\r\n\t}\r\n    \r\n\r\n\t\r\n\t/**\r\n\t * Return the file offset of the first page with data after the table declaration.\r\n\t * This is equals to the first row.\r\n\t */\r\n    final long getFirstPage(){\r\n        return firstPage;\r\n    }\r\n\r\n\r\n    /**\r\n     * Return a list of Links to not commited rows. The list include only the rows that are visible for \r\n     * the current isolation level.\r\n     */\r\n    List getInserts(SSConnection con){\r\n\t\tsynchronized(locks){\r\n\t\t\tArrayList inserts = new ArrayList();\r\n\t\t\tif(con.isolationLevel <= Connection.TRANSACTION_READ_UNCOMMITTED){\r\n\t\t\t\tfor(int i=0; i<locksInsert.size(); i++){\r\n\t\t\t\t\tTableStorePageInsert lock = (TableStorePageInsert)locksInsert.get(i);\r\n\t\t\t\t\tinserts.add(lock.getLink());\r\n\t\t\t\t}\r\n\t\t\t}else{\r\n\t\t\t\tfor(int i=0; i<locksInsert.size(); i++){\r\n\t\t\t\t\tTableStorePageInsert lock = (TableStorePageInsert)locksInsert.get(i);\r\n\t\t\t\t\tif(lock.con == con)\r\n\t\t\t\t\t\tinserts.add(lock.getLink());\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn inserts;\r\n\t\t}    \t\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Request a page lock. If the request is valid then it return the StorePage. \r\n     * If the lock can not be created within 5 seconds then it throw an exception.\r\n     * @param con The connection that request the lock\r\n     * @param pageOperation The operation that should be perform\r\n     * @param page The offset of the page\r\n     * @return a valid StorePage\r\n     * @throws Exception if a timeout occurs\r\n     */\r\n    final TableStorePage requestLock(SSConnection con, int pageOperation, long page) throws Exception{\r\n    \tsynchronized(locks){\r\n            if(raFile == null){\r\n                throw SmallSQLException.create(Language.TABLE_MODIFIED, name);\r\n            }\r\n\t\t\tlong endTime = 0;\r\n\t\t\twhile(true){\r\n\t\t\t\tTableStorePage storePage = requestLockImpl( con, pageOperation, page);\r\n\t\t\t\tif(storePage != null) \r\n\t\t\t\t\treturn storePage; // the normal case should be the fasted\r\n\t\t\t\tif(endTime == 0)\r\n\t\t\t\t\tendTime = System.currentTimeMillis() + 5000;\r\n\t\t\t\tlong waitTime = endTime - System.currentTimeMillis();\r\n\t\t\t\tif(waitTime <= 0)\r\n\t\t\t\t\tthrow SmallSQLException.create(Language.TABLE_DEADLOCK, name);\r\n\t\t\t\tlocks.wait(waitTime);\r\n\t\t\t}\r\n    \t}\r\n    }\r\n    \r\n    /**\r\n     * Request a page lock. If the request is valid then it return the StorePage. \r\n     * In the other case it return null.\r\n     * @param page The fileOffset or -1 for a new page\r\n     * @throws SQLException \r\n     */\r\n\tfinal private TableStorePage requestLockImpl(SSConnection con, int pageOperation, long page) throws SQLException{\r\n\t\tsynchronized(locks){\r\n\t\t\tif(tabLockConnection != null && tabLockConnection != con) return null;\r\n\t\t\tswitch(con.isolationLevel){\r\n\t\t\t\tcase Connection.TRANSACTION_SERIALIZABLE:\r\n\t\t\t\t\tserializeConnections.put( con, con);\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\r\n\t\t\tswitch(pageOperation){\r\n\t\t\t\tcase SQLTokenizer.CREATE:{\r\n\t\t\t\t\t\t// first check if another connection has a lock before creating a table lock\r\n\t\t\t\t\t\tif(locks.size() > 0){\r\n\t\t\t\t\t\t\tIterator values = locks.values().iterator();\r\n\t\t\t\t\t\t\twhile(values.hasNext()){\r\n\t\t\t\t\t\t\t\tTableStorePage lock = (TableStorePage)values.next();\r\n\t\t\t\t\t\t\t\tif(lock.con != con) return null;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tfor(int i=0; i<locksInsert.size(); i++){\r\n\t\t\t\t\t\t\t//the first StorePage in the linked list must be ever TableStorePageInsert\r\n\t\t\t\t\t\t\tTableStorePageInsert lock = (TableStorePageInsert)locksInsert.get(i);\r\n\t\t\t\t\t\t\tif(lock.con != con) return null;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif(serializeConnections.size() > 0){\r\n\t\t\t\t\t\t\tIterator values = locks.values().iterator();\r\n\t\t\t\t\t\t\twhile(values.hasNext()){\r\n\t\t\t\t\t\t\t\tTableStorePage lock = (TableStorePage)values.next();\r\n\t\t\t\t\t\t\t\tif(lock.con != con) return null;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\ttabLockConnection = con;\r\n\t\t\t\t\t\ttabLockCount++;\r\n\t\t\t\t\t\tTableStorePage lock = new TableStorePage(con, this, LOCK_TAB, page);\r\n\t\t\t\t\t\tcon.add(lock);\r\n\t\t\t\t\t\treturn lock;\r\n\t\t\t\t\t}\r\n                case SQLTokenizer.ALTER:{\r\n                    // first check if there is any lock before creating a table lock\r\n                    if(locks.size() > 0 || locksInsert.size() > 0){\r\n                        return null;\r\n                    }\r\n                    if(serializeConnections.size() > 0){\r\n                        Iterator values = locks.values().iterator();\r\n                        while(values.hasNext()){\r\n                            TableStorePage lock = (TableStorePage)values.next();\r\n                            if(lock.con != con) return null;\r\n                        }\r\n                    }\r\n                    tabLockConnection = con;\r\n                    tabLockCount++;\r\n                    TableStorePage lock = new TableStorePage(con, this, LOCK_TAB, page);\r\n                    lock.rollback();\r\n                    return lock;\r\n                }\r\n\t\t\t\tcase SQLTokenizer.INSERT:{\r\n\t\t\t\t\t\t// if there are more as one Connection with a serializable lock then an INSERT is not valid\r\n\t\t\t\t\t\tif(serializeConnections.size() > 1) return null;\r\n\t\t\t\t\t\tif(serializeConnections.size() == 1 && serializeConnections.get(con) == null) return null;\r\n\t\t\t\t\t\tTableStorePageInsert lock = new TableStorePageInsert(con, this, LOCK_INSERT);\r\n\t\t\t\t\t\tlocksInsert.add( lock );\r\n\t\t\t\t\t\tcon.add(lock);\r\n\t\t\t\t\t\treturn lock;\r\n\t\t\t\t\t}\r\n\t\t\t\tcase SQLTokenizer.SELECT:\r\n\t\t\t\tcase SQLTokenizer.UPDATE:{\r\n\t\t\t\t\t\tLong pageKey = new Long(page); //TODO performance\r\n\t\t\t\t\t\tTableStorePage prevLock = null;\r\n\t\t\t\t\t\tTableStorePage lock = (TableStorePage)locks.get( pageKey );\r\n\t\t\t\t\t\tTableStorePage usableLock = null;\r\n\t\t\t\t\t\twhile(lock != null){\r\n\t\t\t\t\t\t\tif(lock.con == con || \r\n\t\t\t\t\t\t\t   con.isolationLevel <= Connection.TRANSACTION_READ_UNCOMMITTED){\r\n\t\t\t\t\t\t\t    usableLock = lock;\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t    if(lock.lockType == LOCK_WRITE){\r\n\t\t\t\t\t\t\t        return null; // write lock of another Connection\r\n\t\t\t\t\t\t\t    }\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tprevLock = lock;\r\n\t\t\t\t\t\t\tlock = lock.nextLock;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif(usableLock != null){\r\n\t\t\t\t\t\t    return usableLock;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tlock = new TableStorePage( con, this, LOCK_NONE, page);\r\n\t\t\t\t\t\tif(con.isolationLevel >= Connection.TRANSACTION_REPEATABLE_READ || pageOperation == SQLTokenizer.UPDATE){\r\n\t\t\t\t\t\t\tlock.lockType = pageOperation == SQLTokenizer.UPDATE ? LOCK_WRITE : LOCK_READ;\r\n\t\t\t\t\t\t\tif(prevLock != null){\r\n\t\t\t\t\t\t\t    prevLock.nextLock = lock.nextLock;\r\n\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t    locks.put( pageKey, lock );\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tcon.add(lock);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn lock;\t\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\tcase SQLTokenizer.LONGVARBINARY:\r\n\t\t\t\t\t// is used for written BLOB and CLOB\r\n\t\t\t\t\t// the difference to INSERT is that page described the size of the byte buffer\r\n\t\t\t\t\treturn new TableStorePage( con, this, LOCK_INSERT, -1);\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tthrow new Error(\"pageOperation:\"+pageOperation);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * Request a write lock for a page that is read. It add the resulting StorePage to the list of commits.\r\n     * @throws SQLException\r\n     *             if the connection was closed.\r\n\t */\r\n\tTableStorePage requestWriteLock(SSConnection con, TableStorePage readlock) throws SQLException{\r\n\t\tif(readlock.lockType == LOCK_INSERT){\r\n\t\t\tTableStorePage lock = new TableStorePage( con, this, LOCK_INSERT, -1);\r\n\t\t\treadlock.nextLock = lock;\r\n\t\t\tcon.add(lock);\r\n\t\t\treturn lock;\t\t\t\t\t\t\t\t\t\r\n\t\t}\r\n\t\tLong pageKey = new Long(readlock.fileOffset); //TODO performance\r\n\t\tTableStorePage prevLock = null;\r\n\t\tTableStorePage lock = (TableStorePage)locks.get( pageKey );\r\n\t\twhile(lock != null){\r\n\t\t\tif(lock.con != con) return null; // there is already any lock from another connection, we can not start write\r\n\t\t\tif(lock.lockType < LOCK_WRITE){\r\n\t\t\t\t// if there is only a read lock we can transfer it\r\n\t\t\t\t// this is required for rollback to a savepoint\r\n\t\t\t\tlock.lockType = LOCK_WRITE;\r\n\t\t\t\treturn lock;\r\n\t\t\t}\r\n\t\t\tprevLock = lock;\r\n\t\t\tlock = lock.nextLock;\r\n\t\t}\r\n\t\tlock = new TableStorePage( con, this, LOCK_WRITE, readlock.fileOffset);\r\n\t\tif(prevLock != null){\r\n\t\t    prevLock.nextLock = lock;\r\n\t\t} else {\r\n\t\t    locks.put( pageKey, lock );\r\n\t\t}\r\n\t\tcon.add(lock);\r\n\t\treturn lock;\t\t\t\t\t\t\t\t\t\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * Remove the lock from this table.\r\n\t */\r\n\tvoid freeLock(TableStorePage storePage){\r\n\t\tfinal int lockType = storePage.lockType;\r\n\t\tfinal long fileOffset = storePage.fileOffset;\r\n\t\tsynchronized(locks){\r\n\t\t\ttry{\r\n\t\t\t\tTableStorePage lock;\r\n\t\t\t\tTableStorePage prev;\r\n\t\t\t\tswitch(lockType){\r\n\t\t\t\t\tcase LOCK_INSERT:\r\n\t\t\t\t\t\tfor(int i=0; i<locksInsert.size(); i++){\r\n\t\t\t\t\t\t\tprev = lock = (TableStorePage)locksInsert.get(i);\r\n\t\t\t\t\t\t\twhile(lock != null){\r\n\t\t\t\t\t\t\t\tif(lock == storePage){\r\n\t\t\t\t\t\t\t\t\t//remove lock\r\n\t\t\t\t\t\t\t\t\tif(lock == prev){\r\n\t\t\t\t\t\t\t\t\t\tif(lock.nextLock == null){\r\n\t\t\t\t\t\t\t\t\t\t\t// the first lock is the only lock in the list\r\n\t\t\t\t\t\t\t\t\t\t\tlocksInsert.remove(i--);\r\n\t\t\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t\t\t// only the first lock of the list is remove\r\n\t\t\t\t\t\t\t\t\t\t\tlocksInsert.set( i, lock.nextLock );\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t\t// a lock in the mid or end is removed\r\n\t\t\t\t\t\t\t\t\t\tprev.nextLock = lock.nextLock;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tprev = lock;\r\n\t\t\t\t\t\t\t\tlock = lock.nextLock;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase LOCK_READ:\r\n\t\t\t\t\tcase LOCK_WRITE:\r\n\t\t\t\t\t\tLong pageKey = new Long(fileOffset); //TODO performance\r\n\t\t\t\t\t\tlock = (TableStorePage)locks.get( pageKey );\r\n\t\t\t\t\t\tprev = lock;\r\n\t\t\t\t\t\twhile(lock != null){\r\n\t\t\t\t\t\t\tif(lock == storePage){\r\n\t\t\t\t\t\t\t\t//lock entfernen\r\n\t\t\t\t\t\t\t\tif(lock == prev){\r\n\t\t\t\t\t\t\t\t\tif(lock.nextLock == null){\r\n\t\t\t\t\t\t\t\t\t\t// erste und einzige Lock in Liste\r\n\t\t\t\t\t\t\t\t\t\tlocks.remove(pageKey);\r\n\t\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t\t// the first lock in the list is removed\r\n\t\t\t\t\t\t\t\t\t\tlocks.put( pageKey, lock.nextLock );\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t// a lock in the middle or end of the list is removed\r\n\t\t\t\t\t\t\t\t\tprev.nextLock = lock.nextLock;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tprev = lock;\r\n\t\t\t\t\t\t\tlock = lock.nextLock;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// a run through can occur if a lock was step high and the type does not compare\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase LOCK_TAB:\r\n\t\t\t\t\t\tassert storePage.con == tabLockConnection : \"Internal Error with TabLock\";\r\n\t\t\t\t\t\tif(--tabLockCount == 0) tabLockConnection = null;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tthrow new Error();\r\n\t\t\t\t}\r\n\t\t\t}finally{\r\n\t\t\t\tlocks.notifyAll();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n}\r\n\r\n"},{"path":"/src/smallsql/junit/BasicTestCase.java","source":"/* =============================================================\r\n * SmallSQL : a free Java DBMS library for the Java(tm) platform\r\n * =============================================================\r\n *\r\n * (C) Copyright 2004-2007, by Volker Berlin.\r\n *\r\n * Project Info:  http://www.smallsql.de/\r\n *\r\n * This library is free software; you can redistribute it and/or modify it \r\n * under the terms of the GNU Lesser General Public License as published by \r\n * the Free Software Foundation; either version 2.1 of the License, or \r\n * (at your option) any later version.\r\n *\r\n * This library is distributed in the hope that it will be useful, but \r\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \r\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public \r\n * License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, \r\n * USA.  \r\n *\r\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc. \r\n * in the United States and other countries.]\r\n *\r\n * ---------------\r\n * Column.java\r\n * ---------------\r\n * BasicTestCase: Volker Berlin\r\n * \r\n */\r\npackage smallsql.junit;\r\n\r\nimport junit.framework.*;\r\n\r\nimport java.io.*;\r\nimport java.math.BigDecimal;\r\nimport java.sql.*;\r\nimport java.text.DateFormatSymbols;\r\n\r\npublic class BasicTestCase extends TestCase {\r\n\r\n\t/** Localized 3-letters months */\r\n\tprotected static final String[] MONTHS = \r\n\t\tnew DateFormatSymbols().getShortMonths();\r\n\r\n\tpublic BasicTestCase(){\r\n        super();\r\n    }\r\n\r\n    public BasicTestCase(String name){\r\n        super(makeNameValid(name));\r\n    }\r\n    \r\n    private static String makeNameValid(String name){\r\n    \treturn name.replace(',' , ';').replace('(','{');\r\n    }\r\n    \r\n    void dropTable(Connection con, String name) throws SQLException{\r\n\t\ttry {\r\n\t\t\tStatement st = con.createStatement();\r\n\t\t\tst.execute(\"drop table \"+name);\r\n\t\t\tst.close();\r\n\t\t} catch (SQLException e) {\r\n            String msg = e.getMessage();\r\n            if(msg.indexOf(\"[SmallSQL]Table\")==0 && msg.indexOf(name)>0 && msg.indexOf(\"can't be dropped.\")>0 ){\r\n                return;\r\n            }\r\n            throw e;\r\n        }\r\n    }\r\n\r\n    void dropView(Connection con, String name){\r\n\t\ttry {\r\n\t\t\tStatement st = con.createStatement();\r\n\t\t\tst.execute(\"drop view \"+name);\r\n\t\t\tst.close();\r\n\t\t} catch (SQLException e) {/* ignore it, if the view not exist */}\r\n    }\r\n\r\n\tpublic void assertRSMetaData( ResultSet rs, String[] colNames, int[] types) throws Exception{\r\n\t\tResultSetMetaData rm = rs.getMetaData();\r\n\t\tint count = rm.getColumnCount();\r\n\t\tassertEquals( \"Column count:\", colNames.length, count);\r\n\t\tfor(int i=1; i<=count; i++){\r\n\t\t\tassertEquals(\"Col \"+i+\" name\", colNames[i-1], rm.getColumnName(i));\r\n\t\t\tassertEquals(\"Col \"+i+\" label\", colNames[i-1], rm.getColumnLabel(i));\r\n\t\t\tassertEquals(\"Col \"+i+\" type\", types   [i-1], rm.getColumnType(i));\r\n\t\t\tswitch(types[i-1]){\r\n\t\t\t\tcase Types.VARCHAR:\r\n\t\t\t\t\tassertTrue  (\"Wrong Precision (\" + rm.getColumnTypeName(i) + \") for Column \"+i+\": \"+rm.getPrecision(i), rm.getPrecision(i) > 0);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase Types.INTEGER:\r\n\t\t\t\t\tassertTrue  (\"Wrong Precision (\" + rm.getColumnTypeName(i) + \") for Column \"+i, rm.getPrecision(i) > 0);\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tprivate final static char[] digits = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};\r\n\tprivate static String bytes2hex( byte[] bytes ){\r\n\t\tStringBuffer buf = new StringBuffer(bytes.length << 1);\r\n\t\tfor(int i=0; i<bytes.length; i++){\r\n\t\t\tbuf.append( digits[ (bytes[i] >> 4) & 0x0F ] );\r\n\t\t\tbuf.append( digits[ (bytes[i]     ) & 0x0F ] );\r\n\t\t}\r\n\t\treturn buf.toString();\r\n\t}\r\n\t\r\n\tpublic void assertEqualsObject( String msg, Object obj1, Object obj2 ){\r\n\t\tif(obj1 instanceof byte[]){\r\n\t\t\tif(!java.util.Arrays.equals( (byte[])obj1, (byte[])obj2)){\r\n\t\t\t\tfail(msg + \" expected:\" + bytes2hex((byte[])obj1)+ \" but was:\"+bytes2hex((byte[])obj2));\r\n\t\t\t}\r\n\t\t}else{ \r\n\t\t\tif(obj1 instanceof BigDecimal)\r\n\t\t\t\tif(((BigDecimal)obj1).compareTo((BigDecimal)obj2) == 0) return;\r\n\t\t\r\n\t\t\tassertEquals( msg, obj1, obj2);\r\n\t\t}\r\n\t}\r\n\t\r\n    public void assertEqualsObject( String msg, Object obj1, Object obj2, boolean needTrim ){\r\n        if(needTrim && obj1 != null){\r\n            // trim for CHAR and BINARY\r\n            if(obj1 instanceof String) obj1 = ((String)obj1).trim();\r\n            if(obj1 instanceof byte[]){\r\n                byte[] tmp = (byte[])obj1;\r\n                int k=tmp.length-1;\r\n                for(; k>= 0; k--) if(tmp[k] != 0) break;\r\n                k++;\r\n                byte[] tmp2 = new byte[k];\r\n                System.arraycopy( tmp, 0, tmp2, 0, k);\r\n                obj1 = tmp2;\r\n            }\r\n        }\r\n\t\tif(needTrim && obj2 != null){\r\n\t\t\t// trim for CHAR and BINARY\r\n\t\t\tif(obj2 instanceof String) obj2 = ((String)obj2).trim();\r\n\t\t\tif(obj2 instanceof byte[]){\r\n\t\t\t\tbyte[] tmp = (byte[])obj2;\r\n\t\t\t\tint k=tmp.length-1;\r\n\t\t\t\tfor(; k>= 0; k--) if(tmp[k] != 0) break;\r\n\t\t\t\tk++;\r\n\t\t\t\tbyte[] tmp2 = new byte[k];\r\n\t\t\t\tSystem.arraycopy( tmp, 0, tmp2, 0, k);\r\n\t\t\t\tobj2 = tmp2;\r\n\t\t\t}\r\n\t\t}\r\n\t\tassertEqualsObject( msg, obj1, obj2);\r\n    }\r\n    \r\n    \r\n\tvoid assertRowCount(int sollCount, String sql ) throws Exception{\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs = st.executeQuery(sql);\r\n        assertRowCount(sollCount,rs);\r\n    }\r\n    \r\n    \r\n    void assertRowCount(int sollCount, ResultSet rs ) throws Exception{\r\n\t\tint colCount = rs.getMetaData().getColumnCount();\r\n\t\tint count = 0;\r\n\t\t//System.out.println(sql);\r\n\t\twhile(rs.next()){\r\n\t\t\tcount++;\r\n\t\t\tfor(int i=1; i<=colCount; i++){\r\n\t\t\t\trs.getObject(i);\r\n\t\t\t\t//System.out.print( \" \"+rs.getObject(i));\r\n\t\t\t}\r\n\t\t\t//System.out.println();\r\n\t\t}\r\n\t\tassertEquals( \"Wrong row count\", sollCount, count);\r\n\t\tfor(int i=1; i<=colCount; i++){\r\n\t\t\ttry{\r\n\t\t\t\t// if not a SQLException occur then it is an error\r\n\t\t\t\tfail( \"Column:\"+i+\" Value:\"+String.valueOf(rs.getObject(i)));\r\n\t\t\t}catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\t\t}\r\n\t\tassertFalse( \"Scroll after last\", rs.next() );\r\n\t}\r\n\r\n\t\r\n    /**\r\n     * Identical to the Implementation from Utils.string2boolean\r\n     */\r\n    private boolean string2boolean( String val){\r\n        try{\r\n            return Double.parseDouble( val ) != 0;\r\n        }catch(NumberFormatException e){/*ignore it if it not a number*/}\r\n        return \"true\".equalsIgnoreCase( val ) || \"yes\".equalsIgnoreCase( val ) || \"t\".equalsIgnoreCase( val );\r\n    }\r\n\t\r\n\t/**\r\n\t * Test a single Value of a the ResultSet that was produce from the SQL\r\n\t */\r\n   \tvoid assertEqualsRsValue(Object obj, String sql) throws Exception{\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs = st.executeQuery(sql);\r\n\t\tassertTrue( \"No row produce\", rs.next());\r\n        assertEqualsRsValue(obj,rs,false);\r\n    }\r\n    \r\n    \r\n    void assertEqualsRsValue(Object obj, ResultSet rs, boolean needTrim) throws Exception{\r\n        String name = rs.getMetaData().getColumnName(1);\r\n\t\tassertEqualsObject( \"Values not identical on read:\", obj, rs.getObject(name), needTrim);\r\n\t\tif(obj instanceof Time){\r\n\t\t\tassertEquals(\"Time is different:\", obj, rs.getTime(name) );\r\n\t\t\tassertEquals(\"Time String is different:\", obj.toString(), rs.getString(name) );\r\n\t\t}\r\n\t\tif(obj instanceof Timestamp){\r\n\t\t\tassertEquals(\"Timestamp is different:\", obj, rs.getTimestamp(name) );\r\n\t\t\tassertEquals(\"Timestamp String is different:\", obj.toString(), rs.getString(name) );\r\n\t\t}\r\n\t\tif(obj instanceof Date){\r\n\t\t\tassertEquals(\"Date is different:\", obj, rs.getDate(name) );\r\n\t\t\tassertEquals(\"Date String is different:\", obj.toString(), rs.getString(name) );\r\n\t\t}\r\n\t\tif(obj instanceof String){\r\n            String str = (String)obj;\r\n            assertEqualsObject(\"String is different:\", str, rs.getString(name), needTrim );\r\n\t\t\tassertEquals(\"String Boolean is different:\", string2boolean(str), rs.getBoolean(name) );\r\n            try{\r\n                assertEquals(\"String Long is different:\", Long.parseLong(str), rs.getLong(name) );\r\n            }catch(NumberFormatException ex){/* ignore */}\r\n            try{\r\n                assertEquals(\"String Integer is different:\", Integer.parseInt(str), rs.getInt(name) );\r\n            }catch(NumberFormatException ex){/* ignore */}\r\n            try{\r\n                assertEquals(\"String Float is different:\", Float.parseFloat(str), rs.getFloat(name), 0.0 );\r\n            }catch(NumberFormatException ex){/* ignore */}\r\n            try{\r\n                assertEquals(\"String Double is different:\", Double.parseDouble(str), rs.getDouble(name), 0.0 );\r\n            }catch(NumberFormatException ex){/* ignore */}\r\n\t\t}\r\n\t\tif(obj instanceof BigDecimal){\r\n            if(!needTrim){\r\n                assertEquals(\"BigDecimal is different:\", obj, rs.getBigDecimal(name) );\r\n                assertEquals(\"Scale is different:\", ((BigDecimal)obj).scale(), rs.getMetaData().getScale(1));\r\n            }\r\n            assertEquals(\"Scale Meta is different:\", rs.getBigDecimal(name).scale(), rs.getMetaData().getScale(1));\r\n\t\t\tBigDecimal big2 = ((BigDecimal)obj).setScale(2,BigDecimal.ROUND_HALF_EVEN);\r\n\t\t\tassertEquals(\"BigDecimal mit scale is different:\", big2, rs.getBigDecimal(name, 2) );\r\n\t\t}\r\n\t\tif(obj instanceof Integer){\r\n\t\t\tassertEquals(\"Scale is different:\", 0, rs.getMetaData().getScale(1));\r\n\t\t}\r\n\t\tif(obj instanceof Number){\r\n            long longValue = ((Number)obj).longValue();\r\n\t\t\tint intValue = ((Number)obj).intValue();\r\n            if(longValue >= Integer.MAX_VALUE)\r\n                intValue = Integer.MAX_VALUE;\r\n            if(longValue <= Integer.MIN_VALUE)\r\n                intValue = Integer.MIN_VALUE;\r\n\t\t\tassertEquals(\"int is different:\", intValue, rs.getInt(name) );\r\n\t\t\tassertEquals(\"long is different:\", longValue, rs.getLong(name) );\r\n\t\t\tif(intValue >= Short.MIN_VALUE && intValue <= Short.MAX_VALUE)\r\n\t\t\t\tassertEquals(\"short is different:\", (short)intValue, rs.getShort(name) );\r\n\t\t\tif(intValue >= Byte.MIN_VALUE && intValue <= Byte.MAX_VALUE)\r\n\t\t\t\tassertEquals(\"byte is different:\", (byte)intValue, rs.getByte(name) );\r\n\t\t\t\r\n\t\t\tdouble value = ((Number)obj).doubleValue();\r\n\t\t\tassertEquals(\"Double is different:\", value, rs.getDouble(name),0.0 );\r\n\t\t\tassertEquals(\"Float is different:\", (float)value, rs.getFloat(name),0.0 );\r\n\t\t\tString valueStr = obj.toString();\r\n            if(!needTrim){\r\n                assertEquals(\"Number String is different:\", valueStr, rs.getString(name) );\r\n            }\r\n\t\t\tBigDecimal decimal = Double.isInfinite(value) || Double.isNaN(value) ? null : new BigDecimal(valueStr);\r\n            assertEqualsObject(\"Number BigDecimal is different:\", decimal, rs.getBigDecimal(name) );\r\n\t\t\tassertEquals(\"Number boolean is different:\", value != 0, rs.getBoolean(name) );\r\n\t\t}\r\n\t\tif(obj == null){\r\n\t\t\tassertNull(\"String is different:\", rs.getString(name) );\r\n\t\t\tassertNull(\"Date is different:\", rs.getDate(name) );\r\n\t\t\tassertNull(\"Time is different:\", rs.getTime(name) );\r\n\t\t\tassertNull(\"Timestamp is different:\", rs.getTimestamp(name) );\r\n\t\t\tassertNull(\"BigDecimal is different:\", rs.getBigDecimal(name) );\r\n\t\t\tassertNull(\"BigDecimal with scale is different:\", rs.getBigDecimal(name, 2) );\r\n\t\t\tassertNull(\"Bytes with scale is different:\", rs.getBytes(name) );\r\n\t\t\tassertEquals(\"Double is different:\", 0, rs.getDouble(name),0 );\r\n\t\t\tassertEquals(\"Float is different:\", 0, rs.getFloat(name),0 );\r\n\t\t\tassertEquals(\"Long is different:\", 0, rs.getLong(name) );\r\n\t\t\tassertEquals(\"Int is different:\", 0, rs.getInt(name) );\r\n\t\t\tassertEquals(\"SmallInt is different:\", 0, rs.getShort(name) );\r\n\t\t\tassertEquals(\"TinyInt is different:\", 0, rs.getByte(name) );\r\n\t\t\tassertEquals(\"Boolean is different:\", false, rs.getBoolean(name) );\r\n\t\t}\r\n\t\tif(obj instanceof byte[]){\r\n\t\t    assertTrue(\"Binary should start with 0x\", rs.getString(name).startsWith(\"0x\"));\r\n\t\t}\r\n\t\t\r\n\t\tResultSetMetaData metaData = rs.getMetaData();\r\n\t\tString className = metaData.getColumnClassName(1);\r\n\t\tassertNotNull( \"ClassName:\", className);\r\n\t\tif(obj != null){\r\n\t\t\tClass gotClass = Class.forName(className);\r\n\t\t\tClass objClass = obj.getClass();\r\n\t\t\tString objClassName = objClass.getName();\r\n\t\t\t\r\n\t\t\tint expectedLen = metaData.getColumnDisplaySize(1);\r\n\r\n\t\t\t// B/CLOBs must be treated as special cases\t\t\t\r\n\t\t\tif (gotClass.equals(java.sql.Blob.class)) {\r\n\t\t\t\tassertTrue(\r\n\t\t\t\t\t\"ClassName assignable: \"+className+\"<->\"+objClassName,\r\n\t\t\t\t\tobjClass.equals(new byte[0].getClass()));\r\n\r\n\t\t\t\tString message = \"Check DisplaySize: \" + expectedLen + \"!=\" + Integer.MAX_VALUE + \")\";\r\n\t\t\t\tassertTrue( message, expectedLen == Integer.MAX_VALUE );\r\n\t\t\t}\r\n\t\t\telse if (gotClass.equals(java.sql.Clob.class)) { // same as NCLOB\r\n\t\t\t\tassertTrue(\r\n\t\t\t\t\t\"ClassName assignable: \"+className+\"<->\"+objClassName,\r\n\t\t\t\t\tobjClass.equals(String.class));\r\n\r\n\t\t\t\tString message = \"Check DisplaySize: \" + expectedLen + \"!=\" + Integer.MAX_VALUE + \")\";\r\n\t\t\t\tassertTrue( message, expectedLen == Integer.MAX_VALUE );\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tString foundStr = rs.getString(name);\r\n\t\t\t\t\r\n\t\t\t\tassertTrue(\"ClassName assignable: \"+className+\"<->\"+objClassName, gotClass.isAssignableFrom(objClass));\r\n\t\t\t\tassertTrue( \"DisplaySize to small \"+ expectedLen +\"<\"+foundStr.length()+\" (\" + foundStr + \")\", expectedLen >= foundStr.length() );\r\n\t\t\t}\r\n\t\t}\r\n   \t}\r\n    \r\n    \r\n    void assertSQLException(String sqlstate, int vendorCode, SQLException ex) {\r\n        StringWriter sw = new StringWriter();\r\n        ex.printStackTrace(new PrintWriter(sw));\r\n        assertEquals( \"Vendor Errorcode:\"+sw, vendorCode, ex.getErrorCode() );\r\n        assertEquals( \"SQL State:\"+sw, sqlstate, ex.getSQLState());\r\n    }\r\n    \r\n\r\n   \t\r\n\tvoid printSQL(String sql) throws SQLException{\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs = st.executeQuery(sql);\r\n\t\tprintRS( rs );\r\n\t}\r\n\t\r\n   \tvoid printRS(ResultSet rs) throws SQLException{\r\n   \t\tint count = rs.getMetaData().getColumnCount();\r\n\t\twhile(rs.next()){ \r\n\t\t\tfor(int i=1; i<=count; i++){\r\n\t\t\t\tSystem.out.print(rs.getString(i) + '\\t');\r\n\t\t\t} \r\n\t\t\tSystem.out.println();\r\n\t\t}\r\n\r\n   \t}\r\n   \t\r\n   \t/**\r\n\t * Returns the localized 3-letters month.\r\n\t * \r\n\t * @param ordinal\r\n\t *            month ordinal (1-based).\r\n\t * @return 3-letters month.\r\n\t */\r\n   \tstatic String getMonth3L(int ordinal) {\r\n   \t\treturn MONTHS[ordinal - 1];\r\n   \t}\r\n}"},{"path":"/src/smallsql/junit/BenchTest.java","source":"/* =============================================================\r\n * SmallSQL : a free Java DBMS library for the Java(tm) platform\r\n * =============================================================\r\n *\r\n * (C) Copyright 2004-2006, by Volker Berlin.\r\n *\r\n * Project Info:  http://www.smallsql.de/\r\n *\r\n * This library is free software; you can redistribute it and/or modify it \r\n * under the terms of the GNU Lesser General Public License as published by \r\n * the Free Software Foundation; either version 2.1 of the License, or \r\n * (at your option) any later version.\r\n *\r\n * This library is distributed in the hope that it will be useful, but \r\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \r\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public \r\n * License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, \r\n * USA.  \r\n *\r\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc. \r\n * in the United States and other countries.]\r\n *\r\n * ---------------\r\n * BenchTest.java\r\n * ---------------\r\n * Author: Volker Berlin\r\n * \r\n */\r\npackage smallsql.junit;\r\n\r\nimport java.sql.*;\r\n\r\npublic class BenchTest\r\n{\r\n    static byte[] byteArray = {23, 34, 67 };\r\n    static byte[] largeByteArray = new byte[4000];\r\n    \r\n    static String driverClassName = \"smallsql.database.SSDriver\";\r\n    static String userName        = \"sa\";\r\n    static String password        = \"\";\r\n    static String jdbcUrl         = \"jdbc:smallsql:AllTests\";\r\n    static int    rowCount        = 10000;\r\n    \r\n    static Connection con;\r\n    static final String tableName = \"BenchTest2\";\r\n        \r\n    \r\n    public static void main(String[] args) throws SQLException{\r\n        for(int i=0; i<args.length;){\r\n            String option = args[i++];\r\n            if      (option.equals(\"-driver\")  ) driverClassName = args[i++];\r\n            else if (option.equals(\"-user\")    ) userName = args[i++];\r\n            else if (option.equals(\"-password\")) password = args[i++];\r\n            else if (option.equals(\"-url\")     ) jdbcUrl  = args[i++];\r\n            else if (option.equals(\"-rowcount\")) rowCount = Integer.parseInt(args[i++]);\r\n            else if (option.equals(\"-?\") | option.equals(\"-help\")){\r\n                System.out.println( \"Valid options are :\\n\\t-driver\\n\\t-url\\n\\t-user\\n\\t-password\\n\\t-rowcount\");\r\n                System.exit(0);\r\n            }\r\n            else {System.out.println(\"Option \" + option + \" is ignored\");i++;}\r\n        }\r\n        System.out.println( \"Driver:  \\t\" + driverClassName);\r\n        System.out.println( \"Username:\\t\" + userName);\r\n        System.out.println( \"Password:\\t\" + password);\r\n        System.out.println( \"JDBC URL:\\t\" + jdbcUrl);\r\n        System.out.println( \"Row Count:\\t\" + rowCount);\r\n        System.out.println();\r\n        try{\r\n            Class.forName(driverClassName).newInstance();\r\n            con = DriverManager.getConnection( jdbcUrl, userName,password);\r\n            System.out.println( con.getMetaData().getDriverName() + \" \" + con.getMetaData().getDriverVersion());\r\n            System.out.println();\r\n            createTestTable( con );\r\n            test_InsertClassic( con );\r\n            test_DeleteAll( con );\r\n            test_InsertEmptyRows( con );\r\n            test_DeleteRows( con );\r\n            test_InsertRows( con );\r\n            test_RowRequestPages( con );\r\n            test_UpdateRows( con );\r\n            test_UpdateRowsPrepare( con );\r\n            test_UpdateRowsPrepareSP( con );\r\n            test_UpdateRowsPrepareBatch( con );\r\n            test_Scroll_getXXX( con );\r\n            test_UpdateLargeBinary( con );\r\n            test_UpdateLargeBinaryWithSP( con );\r\n        }catch(Exception e){\r\n            e.printStackTrace();\r\n        }finally{\r\n            if (con != null){\r\n                //dropTestTable( con );\r\n                con.close();\r\n            }\r\n        }\r\n    }\r\n    \r\n    \r\n    \r\n    /**\r\n      *  1. Test\r\n      *  Insert rows with default values with a classic insert statement.\r\n      */  \r\n    static void test_InsertClassic(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test insert rows with default values with a classic insert statement: \" + rowCount + \" rows\");\r\n        \r\n        try{\r\n            Statement st = con.createStatement( ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE );\r\n            long time = -System.currentTimeMillis();\r\n            for (int i=0; i<rowCount; i++){\r\n                st.execute(\"INSERT INTO \" + tableName + \"(i) VALUES(\" + i +\")\");\r\n            }\r\n            time += System.currentTimeMillis();\r\n            ResultSet rs = st.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n            rs.next();\r\n            int count = rs.getInt(1);\r\n            if (count != rowCount)\r\n                System.out.println( \"  Failed: Only \" + count + \" rows were inserted.\");\r\n            else System.out.println( \"  Test time: \" + time + \" ms\");\r\n            st.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }\r\n    \r\n    \r\n    \r\n    /**\r\n      *  2. Test\r\n      *  Delete all rows with a single statement.\r\n      */  \r\n    static void test_DeleteAll(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test delete all rows: \" + rowCount + \" rows\");\r\n        \r\n        try{\r\n            long time = -System.currentTimeMillis();\r\n            Statement st = con.createStatement();\r\n            st.execute(\"DELETE FROM \" + tableName);\r\n            time += System.currentTimeMillis();\r\n            System.out.println( \"  Test time: \" + time + \" ms\");\r\n            st.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }\r\n    \r\n    \r\n    \r\n    /**\r\n      *  3. Test\r\n      *  Insert only empty rows with the default values of the row with the method insertRow().\r\n      */  \r\n    static void test_InsertEmptyRows(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test insert empty rows with insertRow(): \" + rowCount + \" rows\");\r\n        \r\n        try{\r\n            Statement st = con.createStatement( ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE );\r\n            ResultSet rs = st.executeQuery(\"SELECT * FROM \"+tableName);\r\n            long time = -System.currentTimeMillis();\r\n            for (int i=0; i<rowCount; i++){\r\n                rs.moveToInsertRow();\r\n                rs.insertRow();\r\n            }\r\n            time += System.currentTimeMillis();\r\n            rs = st.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n            rs.next();\r\n            int count = rs.getInt(1);\r\n            if (count != rowCount)\r\n                 System.out.println( \"  Failed: Only \" + count + \" rows were inserted.\");\r\n            else System.out.println( \"  Test time: \" + time + \" ms\");\r\n            st.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }\r\n    \r\n    \r\n    \r\n    /**\r\n      *  4. Test\r\n      *  Delete rows with the method deleteRow().\r\n      */  \r\n    static void test_DeleteRows(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test delete rows with deleteRow(): \" + rowCount + \" rows\");\r\n        \r\n        try{\r\n            Statement st1 = con.createStatement();\r\n            ResultSet rs = st1.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n            rs.next();\r\n            int count = rs.getInt(1);\r\n            if (count != rowCount){\r\n                // There are not the correct count of rows.\r\n                if (count == 0){\r\n                    createTestDataWithClassicInsert( con );\r\n                    rs = st1.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n                    rs.next();\r\n                    count = rs.getInt(1);\r\n                }\r\n                if (count != rowCount){\r\n                    System.out.println( \"  Failed: Only \" + (rowCount-count) + \" rows were deleted.\");\r\n                    return;\r\n                }\r\n            }\r\n            st1.close();\r\n            \r\n            Statement st = con.createStatement( ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE );\r\n            rs = st.executeQuery(\"SELECT * FROM \"+tableName);\r\n            long time = -System.currentTimeMillis();\r\n            for (int i=0; i<rowCount; i++){\r\n                rs.next();\r\n                rs.deleteRow();\r\n            }\r\n            time += System.currentTimeMillis();\r\n            rs = st.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n            rs.next();\r\n            count = rs.getInt(1);\r\n            if (count != 0)\r\n                 System.out.println( \"  Failed: Only \" + (rowCount-count) + \" rows were deleted.\");\r\n            else System.out.println( \"  Test time: \" + time + \" ms\");\r\n            st.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }\r\n    \r\n    \r\n    \r\n    /**\r\n      *  5. Test\r\n      *  Insert rows with the method insertRow().\r\n      */  \r\n    static void test_InsertRows(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test insert rows with insertRow(): \" + rowCount + \" rows\");\r\n        \r\n        try{\r\n            Statement st = con.createStatement( ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE );\r\n            ResultSet rs = st.executeQuery(\"SELECT * FROM \" + tableName);\r\n            long time = -System.currentTimeMillis();\r\n            for (int i=0; i<rowCount; i++){\r\n                rs.moveToInsertRow();\r\n\t            rs.updateBytes (  \"bi\", byteArray );\r\n\t            rs.updateString(  \"c\" , \"Test\" );\r\n\t            rs.updateDate  (  \"d\" , new Date( System.currentTimeMillis() ) );\r\n\t            rs.updateFloat (  \"de\", (float)1234.56789 );\r\n\t            rs.updateFloat (  \"f\" , (float)9876.54321 );\r\n\t            rs.updateBytes (  \"im\", largeByteArray );\r\n\t            rs.updateInt   (  \"i\" , i );\r\n\t            rs.updateDouble(  \"m\" , 23.45 );\r\n\t            rs.updateDouble(  \"n\" , 567.45 );\r\n\t            rs.updateFloat (  \"r\" , (float)78.89 );\r\n\t            rs.updateTime  (  \"sd\", new Time( System.currentTimeMillis() ) );\r\n\t            rs.updateShort (  \"si\", (short)i );\r\n\t            rs.updateFloat (  \"sm\", (float)34.56 );\r\n\t            rs.updateString(  \"sy\", \"sysname (30) NULL\" );\r\n\t            rs.updateString(  \"t\" , \"ntext NULL, sample to save in the field\" );\r\n\t            rs.updateByte  (  \"ti\", (byte)i );\r\n\t            rs.updateBytes (  \"vb\", byteArray );\r\n\t            rs.updateString(  \"vc\", \"nvarchar (255) NULL\" );\r\n                rs.insertRow();\r\n            }\r\n            time += System.currentTimeMillis();\r\n            rs = st.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n            rs.next();\r\n            int count = rs.getInt(1);\r\n            if (count != rowCount){\r\n                  st.execute(\"DELETE FROM \" + tableName);\r\n                  System.out.println( \"  Failed: Only \" + count + \" rows were inserted.\");\r\n            }else System.out.println( \"  Test time: \" + time + \" ms\");\r\n            st.close();\r\n        }catch(Exception e){\r\n        \te.printStackTrace();\r\n            try{\r\n                // reset for the next test\r\n                Statement st = con.createStatement();\r\n                st.execute(\"DELETE FROM \" + tableName);\r\n                st.close();\r\n            }catch(Exception ee){/* ignore it */}\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }\r\n    \r\n    \r\n    \r\n    /**\r\n      *  6. Test\r\n      *  Request one page of rows from a large ResultSet.\r\n      */  \r\n    static void test_RowRequestPages(Connection con){\r\n        int pages = 100; \r\n        int rows  = rowCount / pages;\r\n        System.out.println();\r\n        System.out.println( \"Test request row pages : \" + pages + \" pages, \" +rows + \" rows per page\");\r\n        try{\r\n            Statement st1 = con.createStatement();\r\n            ResultSet rs = st1.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n            rs.next();\r\n            int count = rs.getInt(1);\r\n            if (count != rowCount){\r\n                // There are not the correct count of rows.\r\n                if (count == 0){\r\n                    createTestDataWithClassicInsert( con );\r\n                    rs = st1.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n                    rs.next();\r\n                    count = rs.getInt(1);\r\n                }\r\n                if (count != rowCount){\r\n                    System.out.println( \"  Failed: Only \" + (rowCount-count) + \" rows were found.\");\r\n                    return;\r\n                }\r\n            }\r\n            st1.close();\r\n            \r\n            long time = -System.currentTimeMillis();\r\n            Statement st = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_READ_ONLY);\r\n            st.setFetchSize( rows );\r\n            for (int i=0; i<pages; i++){\r\n                rs = st.executeQuery(\"SELECT * FROM \" + tableName);\r\n                rs.absolute( i*rows+1 );\r\n                for (int r=1; r<rows; r++){\r\n                    // only (rows-1) rows because absolute has already the first row\r\n                    if (!rs.next()){\r\n                        System.out.println( \"  Failed: No rows were found at page \" + i + \" page and row \" + r);\r\n                        return;\r\n                    }\r\n                    int col_i = rs.getInt(\"i\");\r\n                    if (col_i != (i*rows+r)){\r\n                        System.out.println( \"  Failed: Wrong row \" + col_i + \", it should be row \" + (i*rows+r));\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n            time += System.currentTimeMillis();\r\n            System.out.println( \"  Test time: \" + time + \" ms\");\r\n            st.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }\r\n\r\n    \r\n    \r\n    /**\r\n      *  7. Test\r\n      *  Update rows with the method updateRow().\r\n      */  \r\n    static void test_UpdateRows(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test update rows with updateRow(): \" + rowCount + \" rows\");\r\n        \r\n        try{\r\n            Statement st = con.createStatement( ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE );\r\n            ResultSet rs = st.executeQuery(\"SELECT * FROM \" + tableName);\r\n            int colCount = rs.getMetaData().getColumnCount();\r\n            long time = -System.currentTimeMillis();\r\n            int count = 0;\r\n            while(rs.next()){\r\n                for (int i=2; i<=colCount; i++){\r\n                    rs.updateObject( i, rs.getObject(i) );\r\n                }\r\n                rs.updateRow();\r\n                count++;\r\n            }\r\n            time += System.currentTimeMillis();\r\n            if (count != rowCount)\r\n                 System.out.println( \"  Failed: Only \" + count + \" rows were updated.\");\r\n            else System.out.println( \"  Test time: \" + time + \" ms\");\r\n            st.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\" + e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }\r\n    \r\n    \r\n    \r\n    /**\r\n      *  8. Test\r\n      *  Update rows with a PreparedStatement.\r\n      */  \r\n    static void test_UpdateRowsPrepare(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test update rows with a PreparedStatement: \" + rowCount + \" rows\");\r\n        try{\r\n            PreparedStatement pr = con.prepareStatement( \"UPDATE \" + tableName + \" SET bi=?,c=?,d=?,de=?,f=?,im=?,i=?,m=?,n=?,r=?,sd=?,si=?,sm=?,sy=?,t=?,ti=?,vb=?,vc=? WHERE i=?\" );\r\n            long time = -System.currentTimeMillis();\r\n            for (int i=0; i<rowCount; i++){\r\n\t            pr.setBytes (  1, byteArray );\r\n\t            pr.setString(  2 , \"Test\" );\r\n\t            pr.setDate  (  3 , new Date( System.currentTimeMillis() ) );\r\n\t            pr.setFloat (  4, (float)1234.56789 );\r\n\t            pr.setFloat (  5 , (float)9876.54321 );\r\n\t            pr.setBytes (  6, largeByteArray );\r\n\t            pr.setInt   (  7 , i );\r\n\t            pr.setDouble(  8 , 23.45 );\r\n\t            pr.setDouble(  9 , 567.45 );\r\n\t            pr.setFloat (  10 , (float)78.89 );\r\n\t            pr.setTime  (  11, new Time( System.currentTimeMillis() ) );\r\n\t            pr.setShort (  12, (short)23456 );\r\n\t            pr.setFloat (  13, (float)34.56 );\r\n\t            pr.setString(  14, \"sysname (30) NULL\" );\r\n\t            pr.setString(  15 , \"text NULL\" );\r\n\t            pr.setByte  (  16, (byte)28 );\r\n\t            pr.setBytes (  17, byteArray );\r\n\t            pr.setString(  18, \"varchar (255) NULL\" );\r\n\t            pr.setInt   (  19 , i );\r\n                int updateCount = pr.executeUpdate();\r\n                if (updateCount != 1){\r\n                    System.out.println( \"  Failed: Update count should be 1 but it is \" + updateCount + \".\");\r\n                    return;\r\n                }\r\n            }\r\n            time += System.currentTimeMillis();\r\n            System.out.println( \"  Test time: \" + time + \" ms\");\r\n            pr.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }\r\n    \r\n    \r\n    \r\n    /**\r\n      *  9. Test\r\n      *  Update rows with a PreparedStatement and a stored procedure.\r\n      */  \r\n    static void test_UpdateRowsPrepareSP(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test update rows with a PreparedStatement and a stored procedure: \" + rowCount + \" rows\");\r\n        \r\n        try{\r\n            Statement st = con.createStatement();\r\n            try{st.execute(\"drop procedure sp_\"+tableName);}catch(Exception e){/* ignore it */}\r\n            st.execute(\"create procedure sp_\"+tableName+\" (@bi binary,@c nchar(255),@d datetime,@de decimal,@f float,@im image,@i int,@m money,@n numeric(18, 0),@r real,@sd smalldatetime,@si smallint,@sm smallmoney,@sy sysname,@t ntext,@ti tinyint,@vb varbinary(255),@vc nvarchar(255)) as UPDATE \" + tableName + \" SET bi=@bi,c=@c,d=@d,de=@de,f=@f,im=@im,i=@i,m=@m,n=@n,r=@r,sd=@sd,si=@si,sm=@sm,sy=@sy,t=@t,ti=@ti,vb=@vb,vc=@vc WHERE i=@i\");\r\n\r\n            PreparedStatement pr = con.prepareStatement( \"exec sp_\" + tableName + \" ?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?\" );\r\n            long time = -System.currentTimeMillis();\r\n            for (int i=0; i<rowCount; i++){\r\n\t            pr.setBytes (  1, byteArray );\r\n\t            pr.setString(  2 , \"Test\" );\r\n\t            pr.setDate  (  3 , new Date( System.currentTimeMillis() ) );\r\n\t            pr.setFloat (  4, (float)1234.56789 );\r\n\t            pr.setFloat (  5 , (float)9876.54321 );\r\n\t            pr.setBytes (  6, largeByteArray );\r\n\t            pr.setInt   (  7 , i );\r\n\t            pr.setDouble(  8 , 23.45 );\r\n\t            pr.setDouble(  9 , 567.45 );\r\n\t            pr.setFloat (  10 , (float)78.89 );\r\n\t            pr.setTime  (  11, new Time( System.currentTimeMillis() ) );\r\n\t            pr.setShort (  12, (short)23456 );\r\n\t            pr.setFloat (  13, (float)34.56 );\r\n\t            pr.setString(  14, \"sysname (30) NULL\" );\r\n\t            pr.setString(  15 , \"text NULL\" );\r\n\t            pr.setByte  (  16, (byte)28 );\r\n\t            pr.setBytes (  17, byteArray );\r\n\t            pr.setString(  18, \"varchar (255) NULL\" );\r\n                int updateCount = pr.executeUpdate();\r\n                if (updateCount != 1){\r\n                    System.out.println( \"  Failed: Update count should be 1 but it is \" + updateCount + \".\");\r\n                    return;\r\n                }\r\n            }\r\n            time += System.currentTimeMillis();\r\n            System.out.println( \"  Test time: \" + time + \" ms\");\r\n            st.execute(\"drop procedure sp_\"+tableName);\r\n            st.close();\r\n            pr.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }\r\n    \r\n\r\n    \r\n    /**\r\n      *  10. Test\r\n      *  Update rows with a PreparedStatement and Batch.\r\n      */  \r\n    static void test_UpdateRowsPrepareBatch(Connection con){\r\n        int batchSize = 10;\r\n        int batches = rowCount / batchSize;\r\n        System.out.println();\r\n        System.out.println( \"Test update rows with PreparedStatement and Batches: \" + batches + \" batches, \" + batchSize + \" batch size\");\r\n        \r\n        try{\r\n            PreparedStatement pr = con.prepareStatement( \"UPDATE \" + tableName + \" SET bi=?,c=?,d=?,de=?,f=?,im=?,i=?,m=?,n=?,r=?,sd=?,si=?,sm=?,sy=?,t=?,ti=?,vb=?,vc=? WHERE i=?\" );\r\n            long time = -System.currentTimeMillis();\r\n            for (int i=0; i<batches; i++){\r\n                for (int r=0; r<batchSize; r++){\r\n\t                pr.setBytes (  1, byteArray );\r\n\t                pr.setString(  2 , \"Test\" );\r\n\t                pr.setDate  (  3 , new Date( System.currentTimeMillis() ) );\r\n\t                pr.setFloat (  4, (float)1234.56789 );\r\n\t                pr.setFloat (  5 , (float)9876.54321 );\r\n\t                pr.setBytes (  6, largeByteArray );\r\n\t                pr.setInt   (  7 , i*batchSize + r );\r\n\t                pr.setDouble(  8 , 23.45 );\r\n\t                pr.setDouble(  9 , 567.45 );\r\n\t                pr.setFloat (  10 , (float)78.89 );\r\n\t                pr.setTime  (  11, new Time( System.currentTimeMillis() ) );\r\n\t                pr.setShort (  12, (short)23456 );\r\n\t                pr.setFloat (  13, (float)34.56 );\r\n\t                pr.setString(  14, \"sysname (30) NULL\" );\r\n\t                pr.setString(  15 , \"text NULL\" );\r\n\t                pr.setByte  (  16, (byte)28 );\r\n\t                pr.setBytes (  17, byteArray );\r\n\t                pr.setString(  18, \"varchar (255) NULL\" );\r\n\t                pr.setInt   (  19 , i );\r\n\t                pr.addBatch();\r\n\t            }\r\n                int[] updateCount = pr.executeBatch();\r\n                if (updateCount.length != batchSize){\r\n                    System.out.println( \"  Failed: Update count size should be \" + batchSize + \" but it is \" + updateCount.length + \".\");\r\n                    return;\r\n                }\r\n            }\r\n            time += System.currentTimeMillis();\r\n            System.out.println( \"  Test time: \" + time + \" ms\");\r\n            pr.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }\r\n     \r\n    \r\n    \r\n    /**\r\n      *  11. Test\r\n      *  Scroll and call the getXXX methods for every columns.\r\n      */  \r\n    static void test_Scroll_getXXX(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test scroll and call the getXXX methods for every columns: \" + rowCount + \" rows\");\r\n        \r\n        try{\r\n            Statement st = con.createStatement();\r\n            long time = -System.currentTimeMillis();\r\n            ResultSet rs = st.executeQuery(\"SELECT * FROM \" + tableName);\r\n            for (int i=0; i<rowCount; i++){\r\n                    rs.next();\r\n\t                rs.getInt   (  1 );\r\n\t                rs.getBytes (  2 );\r\n\t                rs.getString(  3 );\r\n\t                rs.getDate  (  4 );\r\n\t                rs.getFloat (  5 );\r\n\t                rs.getFloat (  6 );\r\n\t                rs.getBytes (  7 );\r\n\t                rs.getInt   (  8 );\r\n\t                rs.getDouble(  9 );\r\n\t                rs.getDouble(  10 );\r\n\t                rs.getFloat (  11 );\r\n\t                rs.getTime  (  12 );\r\n\t                rs.getShort (  13 );\r\n\t                rs.getFloat (  14 );\r\n\t                rs.getString(  15 );\r\n\t                rs.getString(  16 );\r\n\t                rs.getByte  (  17 );\r\n\t                rs.getBytes (  18 );\r\n\t                rs.getString(  19 );\r\n            }\r\n            time += System.currentTimeMillis();\r\n            System.out.println( \"  Test time: \" + time + \" ms\");\r\n            st.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }\r\n     \r\n    \r\n    /**\r\n      *  12. Test\r\n      *  Update large binary data.\r\n      */  \r\n    static void test_UpdateLargeBinary(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test update large binary data: \" + rowCount + \"KB bytes\");\r\n        \r\n        try{\r\n            java.io.FileOutputStream fos = new java.io.FileOutputStream(tableName+\".bin\");\r\n            byte bytes[] = new byte[1024];\r\n            for(int i=0; i<rowCount; i++){\r\n                fos.write(bytes);\r\n            }\r\n            fos.close();\r\n            java.io.FileInputStream fis = new java.io.FileInputStream(tableName+\".bin\");\r\n            long time = -System.currentTimeMillis();\r\n            PreparedStatement pr = con.prepareStatement(\"Update \" + tableName + \" set im=? WHERE pr=1\");\r\n            pr.setBinaryStream( 1, fis, rowCount*1024 );\r\n            pr.execute();\r\n            pr.close();\r\n            time += System.currentTimeMillis();\r\n            System.out.println( \"  Test time: \" + time + \" ms\");\r\n            fis.close();\r\n            java.io.File file = new java.io.File(tableName+\".bin\");\r\n            file.delete();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }\r\n     \r\n    \r\n\r\n    \r\n    /**\r\n      *  12. Test\r\n      *  Update large binary data with a SP.\r\n      */  \r\n    static void test_UpdateLargeBinaryWithSP(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test update large binary data with a SP: \" + rowCount + \"KB bytes\");\r\n        \r\n        try{\r\n            java.io.FileOutputStream fos = new java.io.FileOutputStream(tableName+\".bin\");\r\n            byte bytes[] = new byte[1024];\r\n            for(int i=0; i<rowCount; i++){\r\n                fos.write(bytes);\r\n            }\r\n            fos.close();\r\n            java.io.FileInputStream fis = new java.io.FileInputStream(tableName+\".bin\");\r\n            long time = -System.currentTimeMillis();\r\n            Statement st = con.createStatement();\r\n            st.execute(\"CREATE PROCEDURE #UpdateLargeBinary(@im image) as Update \" + tableName + \" set im=@im WHERE pr=2\");\r\n            PreparedStatement pr = con.prepareStatement(\"exec #UpdateLargeBinary ?\");\r\n            pr.setBinaryStream( 1, fis, rowCount*1024 );\r\n            pr.execute();\r\n            st.execute(\"DROP PROCEDURE #UpdateLargeBinary\");\r\n            st.close();\r\n            pr.close();\r\n            time += System.currentTimeMillis();\r\n            System.out.println( \"  Test time: \" + time + \" ms\");\r\n            fis.close();\r\n            java.io.File file = new java.io.File(tableName+\".bin\");\r\n            file.delete();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }\r\n     \r\n    \r\n\r\n    \r\n    /**\r\n      *  Create a new Table for testing\r\n      */  \r\n    static void createTestTable(Connection con) throws SQLException{\r\n            Statement st;\r\n            st = con.createStatement();\r\n            //delete old table\r\n            dropTestTable( con );\r\n\r\n            //create table\r\n            st.execute(\r\n                \"CREATE TABLE \" + tableName + \" (\"+\r\n\t            \"    pr  numeric IDENTITY,\"+\r\n\t            \"    bi  binary (255) NULL ,\"+\r\n\t            \"    c   nchar (255) NULL ,\"+\r\n\t            \"    d   datetime NULL ,\"+\r\n\t            \"    de  decimal(18, 0) NULL ,\"+\r\n\t            \"    f   float NULL ,\"+\r\n\t            \"    im  image NULL ,\"+\r\n\t            \"    i   int NULL ,\"+\r\n\t            \"    m   money NULL ,\"+\r\n\t            \"    n   numeric(18, 0) NULL ,\"+\r\n\t            \"    r   real NULL ,\"+\r\n\t            \"    sd  smalldatetime NULL ,\"+\r\n\t            \"    si  smallint NULL ,\"+\r\n\t            \"    sm  smallmoney NULL ,\"+\r\n\t            \"    sy  sysname NULL ,\"+\r\n\t            \"    t   ntext NULL ,\"+\r\n\t            \"    ti  tinyint NULL ,\"+\r\n\t            \"    vb  varbinary (255) NULL ,\"+\r\n\t            \"    vc  nvarchar (255) NULL, \"+\r\n\t            \"CONSTRAINT PK_BenchTest2 PRIMARY KEY CLUSTERED (pr) \"+\r\n\t            \")\");\r\n\t        st.close();  \r\n    }\r\n    \r\n\r\n    \r\n    static void deleteTestTable(Connection con){\r\n        try{\r\n            Statement st = con.createStatement();\r\n            st.execute(\"DELETE FROM \" + tableName);\r\n            st.close();\r\n        }catch(Exception e){/* ignore it */}\r\n    }\r\n\r\n    static void dropTestTable(Connection con){\r\n        try{\r\n            Statement st = con.createStatement();\r\n            st.execute(\"drop table \" + tableName);\r\n            st.close();\r\n        }catch(Exception e){/* ignore it */}\r\n    }\r\n    \r\n    // create test data after the insert test is failed\r\n    static void createTestDataWithClassicInsert(Connection con) throws SQLException{\r\n        String sql = \"INSERT INTO \" + tableName + \"(bi,c,d,de,f,im,i,m,n,r,si,sd,sm,sy,t,ti,vb,vc) VALUES(0x172243,'Test','20010101',1234.56789,9876.54321,0x\";\r\n        for(int i=0; i<largeByteArray.length; i++){\r\n            sql += \"00\";\r\n        }\r\n        Statement st = con.createStatement();\r\n        for (int i=0; i<rowCount; i++){\r\n            st.execute(sql + \",\"+i+\",23.45,567.45,78.89,\"+i+\",'11:11:11',34.56,'sysname (30) NULL','ntext NULL, sample to save in the field',\"+(i & 0xFF)+\",0x172243,'nvarchar (255) NULL')\"  );\r\n        }\r\n        st.close();\r\n    }\r\n}"},{"path":"/src/smallsql/database/ExpressionFunctionRound.java","source":"/* =============================================================\r\n * SmallSQL : a free Java DBMS library for the Java(tm) platform\r\n * =============================================================\r\n *\r\n * (C) Copyright 2004-2006, by Volker Berlin.\r\n *\r\n * Project Info:  http://www.smallsql.de/\r\n *\r\n * This library is free software; you can redistribute it and/or modify it \r\n * under the terms of the GNU Lesser General Public License as published by \r\n * the Free Software Foundation; either version 2.1 of the License, or \r\n * (at your option) any later version.\r\n *\r\n * This library is distributed in the hope that it will be useful, but \r\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \r\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public \r\n * License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, \r\n * USA.  \r\n *\r\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc. \r\n * in the United States and other countries.]\r\n *\r\n * ---------------\r\n * ExpressionFunctionRound.java\r\n * ---------------\r\n * Author: Volker Berlin\r\n * \r\n */\r\npackage smallsql.database;\r\n\r\n\r\nfinal class ExpressionFunctionRound extends ExpressionFunctionReturnP1Number {\r\n\r\n    final int getFunction(){ return SQLTokenizer.ROUND; }\r\n\r\n    boolean isNull() throws Exception{\r\n        return param1.isNull() || param2.isNull();\r\n    }\r\n\t\r\n\r\n    final double getDouble() throws Exception{\r\n\t\tif(isNull()) return 0;\r\n\t\tfinal int places = param2.getInt();\r\n\t\tdouble value = param1.getDouble();\r\n\t\tlong factor = 1;\r\n\t\tif(places > 0){\r\n\t\t\tfor(int i=0; i<places; i++){\r\n\t\t\t\tfactor *= 10;\r\n\t\t\t}\r\n\t\t\tvalue *= factor;\r\n\t\t}else{\r\n\t\t\tfor(int i=0; i>places; i--){\r\n\t\t\t\tfactor *= 10;\r\n\t\t\t}\r\n\t\t\tvalue /= factor;\r\n\t\t}\r\n\t\tvalue = Math.rint( value );\r\n\t\tif(places > 0){\r\n\t\t\tvalue /= factor;\r\n\t\t}else{\r\n\t\t\tvalue *= factor;\r\n\t\t}\r\n\t\treturn value;\r\n    }\r\n\t\r\n\r\n}"},{"path":"/src/smallsql/database/IndexScrollStatus.java","source":"/* =============================================================\r\n * SmallSQL : a free Java DBMS library for the Java(tm) platform\r\n * =============================================================\r\n *\r\n * (C) Copyright 2004-2007, by Volker Berlin.\r\n *\r\n * Project Info:  http://www.smallsql.de/\r\n *\r\n * This library is free software; you can redistribute it and/or modify it \r\n * under the terms of the GNU Lesser General Public License as published by \r\n * the Free Software Foundation; either version 2.1 of the License, or \r\n * (at your option) any later version.\r\n *\r\n * This library is distributed in the hope that it will be useful, but \r\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \r\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public \r\n * License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, \r\n * USA.  \r\n *\r\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc. \r\n * in the United States and other countries.]\r\n *\r\n * ---------------\r\n * IndexScrollStatus.java\r\n * ---------------\r\n * Author: Volker Berlin\r\n * \r\n * Created on 18.04.2005\r\n */\r\npackage smallsql.database;\r\n\r\n/**\r\n * This class save the status of the scrolling through a Index. This is like a Cursor.\r\n */\r\nclass IndexScrollStatus {\r\n\tprivate final IndexNode rootPage;\r\n\tprivate final Expressions expressions; // is used for the description of ASC and DESC\r\n\r\n\tprivate final java.util.Stack nodeStack = new java.util.Stack(); //TODO performance Stack durch nicht synchronisierte Klasse ersetzten\r\n\t/** Used for getRowOffset() as context cash between 2 calls */\r\n\tprivate LongTreeList longList;\r\n\tprivate LongTreeListEnum longListEnum = new LongTreeListEnum();\r\n\r\n\r\n\tIndexScrollStatus(IndexNode rootPage, Expressions expressions){\t\r\n\t\tthis.rootPage\t= rootPage;\r\n\t\tthis.expressions= expressions;\r\n\t\treset();\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * Reset this index to start a new scan of it with nextRowoffset()\r\n\t */\r\n\tfinal void reset(){\r\n\t\tnodeStack.clear();\r\n\t\tboolean asc = (expressions.get(0).getAlias() != SQLTokenizer.DESC_STR);\r\n\t\tnodeStack.push( new IndexNodeScrollStatus(rootPage, asc, true, 0) );\r\n\t}\r\n\r\n\t\r\n\t/**\r\n\t * Return the next rowOffset of this index. You need to call reset() before the first use. \r\n\t * @param next if true the next rowOffset else the previous rowOffset\r\n\t */\r\n\tfinal long getRowOffset( boolean scroll){\r\n\t\tif(longList != null){\r\n\t\t\tlong rowOffset = scroll ? \r\n\t\t\t\t\t\t\t\tlongList.getNext(longListEnum) : \r\n\t\t\t\t\t\t\t\tlongList.getPrevious(longListEnum);\r\n\t\t\tif(rowOffset < 0){\r\n\t\t\t\t// No more entries on this node\r\n\t\t\t\tlongList = null;\r\n\t\t\t}else{\r\n\t\t\t\treturn rowOffset;\r\n\t\t\t}\r\n\t\t}\r\n\t\twhile(true){\r\n\t\t\tIndexNodeScrollStatus status = (IndexNodeScrollStatus)nodeStack.peek();\r\n\t\t\tint level = status.level;\r\n\t\t\tif(!status.asc ^ scroll){\r\n\t\t\t\t//ASC order\r\n\t\t\t\tint idx = ++status.idx;\r\n\t\t\t\tif(idx == -1){\r\n\t\t\t\t\tif(status.nodeValue != null){\r\n\t\t\t\t\t\tif(status.nodeValue instanceof IndexNode){\r\n\t\t\t\t\t\t\tlevel++;\r\n\t\t\t\t\t\t\tnodeStack.push(\r\n\t\t\t\t\t\t\t\tnew IndexNodeScrollStatus( \t(IndexNode)status.nodeValue, \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(expressions.get(level).getAlias() != SQLTokenizer.DESC_STR), \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tscroll, level));\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}else\r\n\t\t\t\t\t\t\treturn getReturnValue(status.nodeValue);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//There is no RowOffset in this node\r\n\t\t\t\t\tidx = ++status.idx;\r\n\t\t\t\t}\r\n\t\t\t\tif(idx >= status.nodes.length){\r\n\t\t\t\t\t//No more nodes in this level\r\n\t\t\t\t\tif(nodeStack.size() > 1){\r\n\t\t\t\t\t\tnodeStack.pop();\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\t//No more RowOffsets in this Index\r\n                        status.idx = status.nodes.length; //to prevent problems with scroll back after multiple calls after the end.\r\n\t\t\t\t\t\treturn -1;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tIndexNode node = status.nodes[idx];\r\n\t\t\t\tnodeStack.push( new IndexNodeScrollStatus(node, status.asc, scroll, level) );\r\n\t\t\t}else{\r\n\t\t\t\t//DESC order\r\n\t\t\t\tint idx = --status.idx;\r\n\t\t\t\tif(idx == -1){\r\n\t\t\t\t\tif(status.nodeValue != null){\r\n\t\t\t\t\t\tif(status.nodeValue instanceof IndexNode){\r\n\t\t\t\t\t\t\tlevel++;\r\n\t\t\t\t\t\t\tnodeStack.push(\r\n\t\t\t\t\t\t\t\tnew IndexNodeScrollStatus( \t(IndexNode)status.nodeValue, \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(expressions.get(level).getAlias() != SQLTokenizer.DESC_STR), \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tscroll, level));\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}else\r\n\t\t\t\t\t\t\treturn getReturnValue(status.nodeValue);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//There is no RowOffset in this node\r\n\t\t\t\t}\r\n\t\t\t\tif(idx < 0){\r\n\t\t\t\t\t//No more nodes in this level\r\n\t\t\t\t\tif(nodeStack.size() > 1){\r\n\t\t\t\t\t\tnodeStack.pop();\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\t//No more RowOffsets in this Index\r\n\t\t\t\t\t\treturn -1;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tIndexNode node = status.nodes[idx];\r\n\t\t\t\tnodeStack.push( new IndexNodeScrollStatus(node, status.asc, scroll, level) );\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\t\r\n\r\n\t/**\r\n\t * Move the index after the last position. The next call nextRowOffset() returns a -1\r\n\t *\r\n\t */\r\n\tfinal void afterLast(){\r\n\t\tlongList = null;\r\n\t\tnodeStack.setSize(1);\r\n\t\t((IndexNodeScrollStatus)nodeStack.peek()).afterLast();\r\n\t}\r\n\t\r\n    \r\n    /**\r\n     * Check if the index is after the last position.\r\n     */\r\n    /*final boolean isAfterLast(){\r\n        if(longList != null || nodeStack.size() != 1){\r\n            return false;\r\n        }\r\n        return ((IndexNodeScrollStatus)nodeStack.peek()).isAfterLast();\r\n    }*/\r\n    \r\n\t\r\n\tprivate final long getReturnValue( Object value){\r\n\t\tif(rootPage.getUnique()){\r\n\t\t\treturn ((Long)value).longValue();\r\n\t\t}else{\r\n\t\t\tlongList = (LongTreeList)value;\r\n\t\t\tlongListEnum.reset();\r\n\t\t\treturn longList.getNext(longListEnum); // there be should one value as minimum\r\n\t\t}\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n\t\t\r\n\r\n}\r\n"},{"path":"/src/smallsql/junit/TestOrderBy.java","source":"/* =============================================================\r\n * SmallSQL : a free Java DBMS library for the Java(tm) platform\r\n * =============================================================\r\n *\r\n * (C) Copyright 2004-2006, by Volker Berlin.\r\n *\r\n * Project Info:  http://www.smallsql.de/\r\n *\r\n * This library is free software; you can redistribute it and/or modify it \r\n * under the terms of the GNU Lesser General Public License as published by \r\n * the Free Software Foundation; either version 2.1 of the License, or \r\n * (at your option) any later version.\r\n *\r\n * This library is distributed in the hope that it will be useful, but \r\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \r\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public \r\n * License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, \r\n * USA.  \r\n *\r\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc. \r\n * in the United States and other countries.]\r\n *\r\n * ---------------\r\n * TestOrderBy.java\r\n * ---------------\r\n * Author: Volker Berlin\r\n * \r\n */\r\npackage smallsql.junit;\r\n\r\nimport java.sql.*;\r\nimport java.util.ArrayList;\r\n\r\n/**\r\n * @author Administrator\r\n *\r\n * To change the template for this generated type comment go to\r\n * Window - Preferences - Java - Code Generation - Code and Comments\r\n */\r\npublic class TestOrderBy extends BasicTestCase {\r\n\r\n\tstatic private boolean init;\r\n\tprivate static final String table1 = \"table_OrderBy1\";\r\n\tprivate static final String table2 = \"table_OrderBy2\";\r\n\tprivate static final String table3 = \"table_OrderBy3\";\r\n\tstatic private int valueCount;\r\n\t\r\n\tpublic void init(){\r\n\t\tif(init) return;\r\n\t\ttry{\r\n\t\t\tConnection con = AllTests.getConnection();\r\n\t\t\tdropTable( con, table1 );\r\n\t\t\tdropTable( con, table2 );\r\n\t\t\tdropTable( con, table3 );\r\n\t\t\tStatement st = con.createStatement();\r\n\t\t\tst.execute(\"create table \" + table1 + \"(v varchar(30), c char(30), nv nvarchar(30),i int, d float, r real, bi bigint, b boolean)\");\r\n\t\t\tst.execute(\"create table \" + table2 + \"(c2 char(30))\");\r\n\t\t\tst.execute(\"create table \" + table3 + \"(vc varchar(30), vb varbinary(30))\");\r\n\t\t\tst.close();\r\n\t\t\t\r\n\t\t\tPreparedStatement pr = con.prepareStatement(\"INSERT into \" + table1 + \"(v,c,nv,i,d,r,bi,b) Values(?,?,?,?,?,?,?,?)\");\r\n\t\t\tPreparedStatement pr2= con.prepareStatement(\"INSERT into \" + table2 + \"(c2) Values(?)\");\r\n\t\t\tfor(int i=150; i>-10; i--){\r\n\t\t\t\tpr.setString( 1, String.valueOf(i));\r\n\t\t\t\tpr.setString( 2, String.valueOf(i));\r\n\t\t\t\tpr.setString( 3, String.valueOf( (char)i ));\r\n\t\t\t\tpr.setInt   ( 4, i );\r\n\t\t\t\tpr.setDouble( 5, i );\r\n\t\t\t\tpr.setFloat ( 6, i );\r\n\t\t\t\tpr.setInt   ( 7, i );\r\n\t\t\t\tpr.setBoolean( 8, i == 0 );\r\n\t\t\t\tpr.execute();\r\n\t\t\t\tpr2.setString( 1, String.valueOf(i));\r\n\t\t\t\tpr2.execute();\r\n\t\t\t\tvalueCount++;\r\n\t\t\t}\r\n\t\t\tpr.setObject( 1, null, Types.VARCHAR);\r\n\t\t\tpr.setObject( 2, null, Types.VARCHAR);\r\n\t\t\tpr.setObject( 3, null, Types.VARCHAR);\r\n\t\t\tpr.setObject( 4, null, Types.VARCHAR);\r\n\t\t\tpr.setObject( 5, null, Types.VARCHAR);\r\n\t\t\tpr.setObject( 6, null, Types.VARCHAR);\r\n\t\t\tpr.setObject( 7, null, Types.VARCHAR);\r\n\t\t\tpr.setObject( 8, null, Types.VARCHAR);\r\n\t\t\tpr.execute();\r\n\t\t\tpr2.setObject( 1, null, Types.VARCHAR);\r\n\t\t\tpr2.execute();\r\n\t\t\tpr2.setString( 1, \"\");\r\n\t\t\tpr2.execute();\r\n\r\n\t\t\tpr.close();\r\n\r\n\t\t\tpr = con.prepareStatement(\"INSERT into \" + table3 + \"(vc, vb) Values(?,?)\");\r\n\t\t\tpr.setString( 1, table3);\r\n\t\t\tpr.setBytes( 2, table3.getBytes());\r\n\t\t\tpr.execute();\r\n\t\t\tpr.setString( 1, \"\");\r\n\t\t\tpr.setBytes( 2, new byte[0]);\r\n\t\t\tpr.execute();\r\n\t\t\tpr.setString( 1, null);\r\n\t\t\tpr.setBytes( 2, null);\r\n\t\t\tpr.execute();\r\n\t\t\t\r\n\t\t\tinit = true;\r\n\t\t}catch(Throwable e){\r\n\t\t\te.printStackTrace();\r\n\t\t}\r\n\t}\r\n\t\r\n\t\r\n\tpublic void testOrderBy_char() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tString oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by c\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = rs.getString(\"c\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"c\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tString newValue = rs.getString(\"c\");\r\n\t\t\tassertTrue( oldValue + \"<\" + newValue, oldValue.compareTo( newValue ) < 0 );\r\n\t\t\toldValue = newValue;\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\trs.close();\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void testOrderBy_varchar() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tString oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by v\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tString newValue = rs.getString(\"v\");\r\n\t\t\tassertTrue( oldValue + \"<\" + newValue, oldValue.compareTo( newValue ) < 0 );\r\n\t\t\toldValue = newValue;\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void testOrderBy_varchar_asc() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tString oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by v ASC\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tString newValue = rs.getString(\"v\");\r\n\t\t\tassertTrue( oldValue.compareTo( newValue ) < 0 );\r\n\t\t\toldValue = newValue;\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\trs.close();\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void testOrderBy_varchar_desc() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tString oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by v desc\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(oldValue != null && rs.next()){\r\n\t\t\tString newValue = rs.getString(\"v\");\r\n\t\t\tif(newValue != null){\r\n\t\t\t\tassertTrue( oldValue.compareTo( newValue ) > 0 );\r\n\t\t\t\tcount++;\r\n\t\t\t}\r\n\t\t\toldValue = newValue;\r\n\t\t}\r\n\t\tassertNull(oldValue);\r\n\t\tassertFalse( rs.next() );\r\n\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\t\r\n\tpublic void testOrderBy_varchar_DescAsc() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tString oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by v desc, i asc\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(oldValue != null && rs.next()){\r\n\t\t\tString newValue = rs.getString(\"v\");\r\n\t\t\tif(newValue != null){\r\n\t\t\t\tassertTrue( oldValue.compareTo( newValue ) > 0 );\r\n\t\t\t\tcount++;\r\n\t\t\t}\r\n\t\t\toldValue = newValue;\r\n\t\t}\r\n\t\tassertNull(oldValue);\r\n\t\tassertFalse( rs.next() );\r\n\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\t\r\n\tpublic void testOrderBy_varchar_GroupBy() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tString oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT first(v) cc FROM \" + table1 + \" Group By i ORDER  by first(V)\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = rs.getString(\"cc\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"cc\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tassertTrue( oldValue.compareTo( rs.getString(\"cc\") ) < 0 );\r\n\t\t\toldValue = rs.getString(\"cc\");\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void testOrderBy_varchar_Join() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tString oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" t1 Inner join \"+table2+\" t2 on t1.c=t2.c2  ORDER  by v\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tassertTrue( oldValue.compareTo( rs.getString(\"v\") ) < 0 );\r\n\t\t\toldValue = rs.getString(\"v\");\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void testOrderBy_nvarchar() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tString oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by nv\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = rs.getString(\"nv\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"nv\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tassertTrue( String.CASE_INSENSITIVE_ORDER.compare( oldValue, rs.getString(\"nv\") ) <= 0 );\r\n\t\t\toldValue = rs.getString(\"nv\");\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void testOrderBy_int() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tInteger oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by i\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = (Integer)rs.getObject(\"i\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = (Integer)rs.getObject(\"i\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tassertTrue( oldValue.compareTo( (Integer)rs.getObject(\"i\") ) < 0 );\r\n\t\t\toldValue = (Integer)rs.getObject(\"i\");\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void test_function() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tint oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by abs(i)\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\tassertNull(rs.getObject(\"i\"));\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = Math.abs( rs.getInt(\"i\") );\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tint newValue = Math.abs( rs.getInt(\"i\") );\r\n\t\t\tassertTrue( oldValue <= newValue );\r\n\t\t\toldValue = newValue;\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void test_functionAscDesc() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tint oldValue;\r\n\t\tint oldValue2;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by abs(i) Asc, i desc\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\tassertNull(rs.getObject(\"i\"));\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = Math.abs( rs.getInt(\"i\") );\r\n\t\toldValue2 = rs.getInt(\"i\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tint newValue2 = rs.getInt(\"i\");\r\n\t\t\tint newValue = Math.abs( newValue2 );\r\n\t\t\tassertTrue( oldValue <= newValue );\r\n\t\t\tif(oldValue == newValue){\r\n\t\t\t\tassertTrue( oldValue2 > newValue2 );\r\n\t\t\t}\r\n\t\t\toldValue = newValue;\r\n\t\t\toldValue2 = newValue2;\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void testOrderBy_int_asc() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tInteger oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by i Asc\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = (Integer)rs.getObject(\"i\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = (Integer)rs.getObject(\"i\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tassertTrue( oldValue.compareTo( (Integer)rs.getObject(\"i\") ) < 0 );\r\n\t\t\toldValue = (Integer)rs.getObject(\"i\");\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void testOrderBy_int_desc() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tInteger oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by i Desc\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = (Integer)rs.getObject(\"i\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(oldValue != null && rs.next()){\r\n\t\t\tInteger newValue = (Integer)rs.getObject(\"i\");\r\n\t\t\tif(newValue != null){\r\n\t\t\t\tassertTrue( oldValue.compareTo( newValue ) > 0 );\r\n\t\t\t\tcount++;\r\n\t\t\t}\r\n\t\t\toldValue = newValue;\r\n\t\t}\r\n\t\tassertNull(oldValue);\r\n\t\tassertFalse( rs.next() );\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void testOrderBy_double() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tDouble oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by d\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = (Double)rs.getObject(\"d\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = (Double)rs.getObject(\"d\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tassertTrue( oldValue.compareTo( (Double)rs.getObject(\"d\") ) < 0 );\r\n\t\t\toldValue = (Double)rs.getObject(\"d\");\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void testOrderBy_real() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tFloat oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by r\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = (Float)rs.getObject(\"r\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = (Float)rs.getObject(\"r\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tassertTrue( oldValue.compareTo( (Float)rs.getObject(\"r\") ) < 0 );\r\n\t\t\toldValue = (Float)rs.getObject(\"r\");\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void test_bigint() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tLong oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by bi\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = (Long)rs.getObject(\"bi\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = (Long)rs.getObject(\"bi\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tassertTrue( oldValue.compareTo( (Long)rs.getObject(\"bi\") ) < 0 );\r\n\t\t\toldValue = (Long)rs.getObject(\"bi\");\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void test_bigint_withDoublicateValues() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tLong oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT bi/2 bi_2 FROM \" + table1 + \" ORDER  by (bi/2)\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = (Long)rs.getObject(\"bi_2\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = (Long)rs.getObject(\"bi_2\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tLong newValue = (Long)rs.getObject(\"bi_2\");\r\n\t\t\tassertTrue( oldValue + \"<=\"+newValue, oldValue.compareTo( newValue ) <= 0 );\r\n\t\t\toldValue = newValue;\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void test_boolean() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tboolean oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by b\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = rs.getBoolean(\"b\");\r\n\t\tassertFalse(oldValue);\r\n\t\tassertTrue(rs.wasNull());\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getBoolean(\"b\");\r\n\t\tassertFalse(oldValue);\t\t\r\n\t\tassertFalse(rs.wasNull());\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(!oldValue && rs.next()){\r\n\t\t\toldValue = rs.getBoolean(\"b\");\r\n\t\t\tassertFalse(rs.wasNull());\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\twhile(oldValue && rs.next()){\r\n\t\t\toldValue = rs.getBoolean(\"b\");\r\n\t\t\tassertFalse(rs.wasNull());\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertFalse(rs.next());\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void testVarcharEmpty() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table3 + \" ORDER  by vc\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\t\t\r\n\t\tassertNull( rs.getObject(\"vc\") );\r\n\r\n\t\tassertTrue( rs.next() );\r\n\t\tassertEquals( \"\", rs.getObject(\"vc\") );\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\tassertEquals( table3, rs.getObject(\"vc\") );\r\n\t\t\r\n\t\tassertFalse( rs.next() );\r\n\t}\r\n\t\r\n\r\n\tpublic void testVarbinaryEmpty() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table3 + \" ORDER  by vb\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\t\t\r\n\t\tassertNull( rs.getObject(\"vb\") );\r\n\r\n\t\tassertTrue( rs.next() );\r\n\t\tassertEqualsObject( \"\", new byte[0], rs.getObject(\"vb\"), false );\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\tassertEqualsObject( \"\", table3.getBytes(), rs.getObject(\"vb\"), false );\r\n\t\t\r\n\t\tassertFalse( rs.next() );\r\n\t}\r\n\r\n\r\n\tpublic void test2Columns() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs = null;\r\n\t\tString oldValue;\r\n\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1+\",\"+table2+\" ORDER  by v, c2\");\r\n\r\n\t\tassertTrue( rs.next() );\r\n\t\tassertNull( rs.getObject(\"v\") );\r\n\t\tassertNull( rs.getObject(\"c2\") );\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"c2\");\r\n\r\n\t\tint count = 1;\r\n\t\twhile(rs.next() && rs.getString(\"v\") == null){\r\n\t\t\tString newValue = rs.getString(\"c2\");\r\n\t\t\tassertTrue( oldValue.compareTo( newValue ) < 0 );\r\n\t\t\toldValue = newValue;\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount+1, count );\r\n\t\t\r\n\t\tboolean isNext = true;\r\n\t\twhile(isNext){\r\n\t\t\tString vValue = rs.getString(\"v\");\r\n\t\t\tassertNull( rs.getObject(\"c2\") );\r\n\t\t\r\n\t\t\tassertTrue( rs.next() );\r\n\t\t\toldValue = rs.getString(\"c2\");\r\n\t\t\tassertEquals( vValue, rs.getString(\"v\") );\r\n\r\n\t\t\tisNext = rs.next();\r\n\t\t\tcount = 1;\r\n\t\t\twhile(isNext && vValue.equals(rs.getString(\"v\"))){\r\n\t\t\t\tString newValue = rs.getString(\"c2\");\r\n\t\t\t\tassertTrue( oldValue.compareTo( newValue ) < 0 );\r\n\t\t\t\toldValue = newValue;\r\n\t\t\t\tcount++;\r\n\t\t\t\tisNext = rs.next();\r\n\t\t\t}\r\n\t\t\tassertEquals( valueCount+1, count );\r\n\t\t}\r\n\t}\r\n\r\n\t\r\n\r\n\tpublic void testOrderBy_Scollable() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);\r\n\t\tResultSet rs;\r\n\t\tint count;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by v\");\r\n\t\t\r\n\t\t//jetzt irgendwo in die Mitte scrollen\r\n\t\trs.next();\r\n\t\trs.next();\r\n\t\trs.previous(); //dann soll der Zeiger nicht am Ende des bereits gefetchten stehen\r\n\t\t\r\n\t\trs.last();\r\n\t\tcount = 0;\r\n\t\twhile(rs.previous()) count++;\t\t\r\n\t\tassertEquals( valueCount, count );\r\n\r\n\t\trs.beforeFirst();\r\n\t\tcount = -1;\r\n\t\twhile(rs.next()) count++;\t\t\r\n\t\tassertEquals( valueCount, count );\r\n\r\n\t\trs.beforeFirst();\r\n\t\tcount = -1;\r\n\t\twhile(rs.next()) count++;\t\t\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\r\n\t\r\n\tpublic void testOrderBy_ScollableDesc() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);\r\n\t\tResultSet rs;\r\n\t\tint count;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by i desc, d\");\r\n\t\t\r\n\t\t//jetzt irgendwo in die Mitte scrollen\r\n\t\trs.next();\r\n\t\trs.next();\r\n\t\trs.previous(); //dann soll der Zeiger nicht am Ende des bereits gefetchten stehen\r\n\t\t\r\n\t\trs.last();\r\n\t\tcount = 0;\r\n\t\twhile(rs.previous()) count++;\t\t\r\n\t\tassertEquals( valueCount, count );\r\n\r\n\t\trs.beforeFirst();\r\n\t\tcount = -1;\r\n\t\twhile(rs.next()) count++;\t\t\r\n\t\tassertEquals( valueCount, count );\r\n\r\n\t\trs.beforeFirst();\r\n\t\tcount = -1;\r\n\t\twhile(rs.next()) count++;\t\t\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\r\n\t\r\n\tpublic void testOrderBy_Scollable2() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);\r\n\t\tResultSet rs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by v\");\r\n\r\n\t\t\r\n\t\tint colCount = rs.getMetaData().getColumnCount();\r\n\t\tArrayList result = new ArrayList();\r\n\t\twhile(rs.next()){\r\n\t\t\tObject[] row = new Object[colCount];\r\n\t\t\tfor(int i=0; i<colCount; i++){\r\n\t\t\t\trow[i] = rs.getObject(i+1);\r\n\t\t\t}\r\n\t\t\tresult.add(row);\r\n\t\t}\r\n\t\t\r\n\t\tint rowCount = result.size();\r\n\t\twhile(rs.previous()){\r\n\t\t\tObject[] row = (Object[])result.get(--rowCount);\r\n\t\t\tfor(int i=0; i<colCount; i++){\r\n\t\t\t\tassertEquals( \"Difference in row:\"+rowCount, row[i], rs.getObject(i+1));\r\n\t\t\t}\r\n\t\t}\r\n\t\tassertEquals( \"RowCount different between next and previous:\"+rowCount, 0, rowCount);\r\n\t}\r\n\r\n\t\r\n\tpublic void testUnion() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tString oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT v, 5 as Const FROM \" + table1 + \" Union All Select vc, 6 From \" + table3 + \" ORDER by v\");\r\n\t\t\r\n\t\tassertRSMetaData(rs, new String[]{\"v\", \"Const\"}, new int[]{Types.VARCHAR, Types.INTEGER});\r\n\t\t\r\n\t\tassertTrue( rs.next() );\t\t\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\tassertNull(oldValue);\r\n\t\t\r\n\t\tassertTrue( rs.next() );\t\t\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\tassertNull(oldValue);\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\t\r\n\t\tint count = 3;\r\n\t\twhile(rs.next()){\r\n\t\t\tString newValue = rs.getString(\"v\");\r\n\t\t\tassertTrue( oldValue.compareTo( newValue ) < 0 );\r\n\t\t\toldValue = newValue;\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount+4, count );\r\n\t}\r\n\r\n\r\n}\r\n"},{"path":"/src/smallsql/junit/TestOrderBy.java","source":"/* =============================================================\r\n * SmallSQL : a free Java DBMS library for the Java(tm) platform\r\n * =============================================================\r\n *\r\n * (C) Copyright 2004-2006, by Volker Berlin.\r\n *\r\n * Project Info:  http://www.smallsql.de/\r\n *\r\n * This library is free software; you can redistribute it and/or modify it \r\n * under the terms of the GNU Lesser General Public License as published by \r\n * the Free Software Foundation; either version 2.1 of the License, or \r\n * (at your option) any later version.\r\n *\r\n * This library is distributed in the hope that it will be useful, but \r\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \r\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public \r\n * License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, \r\n * USA.  \r\n *\r\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc. \r\n * in the United States and other countries.]\r\n *\r\n * ---------------\r\n * TestOrderBy.java\r\n * ---------------\r\n * Author: Volker Berlin\r\n * \r\n */\r\npackage smallsql.junit;\r\n\r\nimport java.sql.*;\r\nimport java.util.ArrayList;\r\n\r\n/**\r\n * @author Administrator\r\n *\r\n * To change the template for this generated type comment go to\r\n * Window - Preferences - Java - Code Generation - Code and Comments\r\n */\r\npublic class TestOrderBy extends BasicTestCase {\r\n\r\n\tstatic private boolean init;\r\n\tprivate static final String table1 = \"table_OrderBy1\";\r\n\tprivate static final String table2 = \"table_OrderBy2\";\r\n\tprivate static final String table3 = \"table_OrderBy3\";\r\n\tstatic private int valueCount;\r\n\t\r\n\tpublic void init(){\r\n\t\tif(init) return;\r\n\t\ttry{\r\n\t\t\tConnection con = AllTests.getConnection();\r\n\t\t\tdropTable( con, table1 );\r\n\t\t\tdropTable( con, table2 );\r\n\t\t\tdropTable( con, table3 );\r\n\t\t\tStatement st = con.createStatement();\r\n\t\t\tst.execute(\"create table \" + table1 + \"(v varchar(30), c char(30), nv nvarchar(30),i int, d float, r real, bi bigint, b boolean)\");\r\n\t\t\tst.execute(\"create table \" + table2 + \"(c2 char(30))\");\r\n\t\t\tst.execute(\"create table \" + table3 + \"(vc varchar(30), vb varbinary(30))\");\r\n\t\t\tst.close();\r\n\t\t\t\r\n\t\t\tPreparedStatement pr = con.prepareStatement(\"INSERT into \" + table1 + \"(v,c,nv,i,d,r,bi,b) Values(?,?,?,?,?,?,?,?)\");\r\n\t\t\tPreparedStatement pr2= con.prepareStatement(\"INSERT into \" + table2 + \"(c2) Values(?)\");\r\n\t\t\tfor(int i=150; i>-10; i--){\r\n\t\t\t\tpr.setString( 1, String.valueOf(i));\r\n\t\t\t\tpr.setString( 2, String.valueOf(i));\r\n\t\t\t\tpr.setString( 3, String.valueOf( (char)i ));\r\n\t\t\t\tpr.setInt   ( 4, i );\r\n\t\t\t\tpr.setDouble( 5, i );\r\n\t\t\t\tpr.setFloat ( 6, i );\r\n\t\t\t\tpr.setInt   ( 7, i );\r\n\t\t\t\tpr.setBoolean( 8, i == 0 );\r\n\t\t\t\tpr.execute();\r\n\t\t\t\tpr2.setString( 1, String.valueOf(i));\r\n\t\t\t\tpr2.execute();\r\n\t\t\t\tvalueCount++;\r\n\t\t\t}\r\n\t\t\tpr.setObject( 1, null, Types.VARCHAR);\r\n\t\t\tpr.setObject( 2, null, Types.VARCHAR);\r\n\t\t\tpr.setObject( 3, null, Types.VARCHAR);\r\n\t\t\tpr.setObject( 4, null, Types.VARCHAR);\r\n\t\t\tpr.setObject( 5, null, Types.VARCHAR);\r\n\t\t\tpr.setObject( 6, null, Types.VARCHAR);\r\n\t\t\tpr.setObject( 7, null, Types.VARCHAR);\r\n\t\t\tpr.setObject( 8, null, Types.VARCHAR);\r\n\t\t\tpr.execute();\r\n\t\t\tpr2.setObject( 1, null, Types.VARCHAR);\r\n\t\t\tpr2.execute();\r\n\t\t\tpr2.setString( 1, \"\");\r\n\t\t\tpr2.execute();\r\n\r\n\t\t\tpr.close();\r\n\r\n\t\t\tpr = con.prepareStatement(\"INSERT into \" + table3 + \"(vc, vb) Values(?,?)\");\r\n\t\t\tpr.setString( 1, table3);\r\n\t\t\tpr.setBytes( 2, table3.getBytes());\r\n\t\t\tpr.execute();\r\n\t\t\tpr.setString( 1, \"\");\r\n\t\t\tpr.setBytes( 2, new byte[0]);\r\n\t\t\tpr.execute();\r\n\t\t\tpr.setString( 1, null);\r\n\t\t\tpr.setBytes( 2, null);\r\n\t\t\tpr.execute();\r\n\t\t\t\r\n\t\t\tinit = true;\r\n\t\t}catch(Throwable e){\r\n\t\t\te.printStackTrace();\r\n\t\t}\r\n\t}\r\n\t\r\n\t\r\n\tpublic void testOrderBy_char() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tString oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by c\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = rs.getString(\"c\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"c\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tString newValue = rs.getString(\"c\");\r\n\t\t\tassertTrue( oldValue + \"<\" + newValue, oldValue.compareTo( newValue ) < 0 );\r\n\t\t\toldValue = newValue;\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\trs.close();\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void testOrderBy_varchar() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tString oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by v\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tString newValue = rs.getString(\"v\");\r\n\t\t\tassertTrue( oldValue + \"<\" + newValue, oldValue.compareTo( newValue ) < 0 );\r\n\t\t\toldValue = newValue;\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void testOrderBy_varchar_asc() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tString oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by v ASC\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tString newValue = rs.getString(\"v\");\r\n\t\t\tassertTrue( oldValue.compareTo( newValue ) < 0 );\r\n\t\t\toldValue = newValue;\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\trs.close();\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void testOrderBy_varchar_desc() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tString oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by v desc\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(oldValue != null && rs.next()){\r\n\t\t\tString newValue = rs.getString(\"v\");\r\n\t\t\tif(newValue != null){\r\n\t\t\t\tassertTrue( oldValue.compareTo( newValue ) > 0 );\r\n\t\t\t\tcount++;\r\n\t\t\t}\r\n\t\t\toldValue = newValue;\r\n\t\t}\r\n\t\tassertNull(oldValue);\r\n\t\tassertFalse( rs.next() );\r\n\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\t\r\n\tpublic void testOrderBy_varchar_DescAsc() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tString oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by v desc, i asc\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(oldValue != null && rs.next()){\r\n\t\t\tString newValue = rs.getString(\"v\");\r\n\t\t\tif(newValue != null){\r\n\t\t\t\tassertTrue( oldValue.compareTo( newValue ) > 0 );\r\n\t\t\t\tcount++;\r\n\t\t\t}\r\n\t\t\toldValue = newValue;\r\n\t\t}\r\n\t\tassertNull(oldValue);\r\n\t\tassertFalse( rs.next() );\r\n\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\t\r\n\tpublic void testOrderBy_varchar_GroupBy() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tString oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT first(v) cc FROM \" + table1 + \" Group By i ORDER  by first(V)\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = rs.getString(\"cc\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"cc\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tassertTrue( oldValue.compareTo( rs.getString(\"cc\") ) < 0 );\r\n\t\t\toldValue = rs.getString(\"cc\");\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void testOrderBy_varchar_Join() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tString oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" t1 Inner join \"+table2+\" t2 on t1.c=t2.c2  ORDER  by v\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tassertTrue( oldValue.compareTo( rs.getString(\"v\") ) < 0 );\r\n\t\t\toldValue = rs.getString(\"v\");\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void testOrderBy_nvarchar() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tString oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by nv\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = rs.getString(\"nv\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"nv\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tassertTrue( String.CASE_INSENSITIVE_ORDER.compare( oldValue, rs.getString(\"nv\") ) <= 0 );\r\n\t\t\toldValue = rs.getString(\"nv\");\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void testOrderBy_int() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tInteger oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by i\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = (Integer)rs.getObject(\"i\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = (Integer)rs.getObject(\"i\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tassertTrue( oldValue.compareTo( (Integer)rs.getObject(\"i\") ) < 0 );\r\n\t\t\toldValue = (Integer)rs.getObject(\"i\");\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void test_function() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tint oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by abs(i)\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\tassertNull(rs.getObject(\"i\"));\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = Math.abs( rs.getInt(\"i\") );\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tint newValue = Math.abs( rs.getInt(\"i\") );\r\n\t\t\tassertTrue( oldValue <= newValue );\r\n\t\t\toldValue = newValue;\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void test_functionAscDesc() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tint oldValue;\r\n\t\tint oldValue2;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by abs(i) Asc, i desc\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\tassertNull(rs.getObject(\"i\"));\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = Math.abs( rs.getInt(\"i\") );\r\n\t\toldValue2 = rs.getInt(\"i\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tint newValue2 = rs.getInt(\"i\");\r\n\t\t\tint newValue = Math.abs( newValue2 );\r\n\t\t\tassertTrue( oldValue <= newValue );\r\n\t\t\tif(oldValue == newValue){\r\n\t\t\t\tassertTrue( oldValue2 > newValue2 );\r\n\t\t\t}\r\n\t\t\toldValue = newValue;\r\n\t\t\toldValue2 = newValue2;\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void testOrderBy_int_asc() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tInteger oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by i Asc\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = (Integer)rs.getObject(\"i\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = (Integer)rs.getObject(\"i\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tassertTrue( oldValue.compareTo( (Integer)rs.getObject(\"i\") ) < 0 );\r\n\t\t\toldValue = (Integer)rs.getObject(\"i\");\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void testOrderBy_int_desc() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tInteger oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by i Desc\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = (Integer)rs.getObject(\"i\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(oldValue != null && rs.next()){\r\n\t\t\tInteger newValue = (Integer)rs.getObject(\"i\");\r\n\t\t\tif(newValue != null){\r\n\t\t\t\tassertTrue( oldValue.compareTo( newValue ) > 0 );\r\n\t\t\t\tcount++;\r\n\t\t\t}\r\n\t\t\toldValue = newValue;\r\n\t\t}\r\n\t\tassertNull(oldValue);\r\n\t\tassertFalse( rs.next() );\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void testOrderBy_double() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tDouble oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by d\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = (Double)rs.getObject(\"d\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = (Double)rs.getObject(\"d\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tassertTrue( oldValue.compareTo( (Double)rs.getObject(\"d\") ) < 0 );\r\n\t\t\toldValue = (Double)rs.getObject(\"d\");\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void testOrderBy_real() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tFloat oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by r\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = (Float)rs.getObject(\"r\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = (Float)rs.getObject(\"r\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tassertTrue( oldValue.compareTo( (Float)rs.getObject(\"r\") ) < 0 );\r\n\t\t\toldValue = (Float)rs.getObject(\"r\");\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void test_bigint() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tLong oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by bi\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = (Long)rs.getObject(\"bi\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = (Long)rs.getObject(\"bi\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tassertTrue( oldValue.compareTo( (Long)rs.getObject(\"bi\") ) < 0 );\r\n\t\t\toldValue = (Long)rs.getObject(\"bi\");\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void test_bigint_withDoublicateValues() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tLong oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT bi/2 bi_2 FROM \" + table1 + \" ORDER  by (bi/2)\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = (Long)rs.getObject(\"bi_2\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = (Long)rs.getObject(\"bi_2\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tLong newValue = (Long)rs.getObject(\"bi_2\");\r\n\t\t\tassertTrue( oldValue + \"<=\"+newValue, oldValue.compareTo( newValue ) <= 0 );\r\n\t\t\toldValue = newValue;\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void test_boolean() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tboolean oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by b\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = rs.getBoolean(\"b\");\r\n\t\tassertFalse(oldValue);\r\n\t\tassertTrue(rs.wasNull());\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getBoolean(\"b\");\r\n\t\tassertFalse(oldValue);\t\t\r\n\t\tassertFalse(rs.wasNull());\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(!oldValue && rs.next()){\r\n\t\t\toldValue = rs.getBoolean(\"b\");\r\n\t\t\tassertFalse(rs.wasNull());\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\twhile(oldValue && rs.next()){\r\n\t\t\toldValue = rs.getBoolean(\"b\");\r\n\t\t\tassertFalse(rs.wasNull());\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertFalse(rs.next());\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void testVarcharEmpty() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table3 + \" ORDER  by vc\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\t\t\r\n\t\tassertNull( rs.getObject(\"vc\") );\r\n\r\n\t\tassertTrue( rs.next() );\r\n\t\tassertEquals( \"\", rs.getObject(\"vc\") );\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\tassertEquals( table3, rs.getObject(\"vc\") );\r\n\t\t\r\n\t\tassertFalse( rs.next() );\r\n\t}\r\n\t\r\n\r\n\tpublic void testVarbinaryEmpty() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table3 + \" ORDER  by vb\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\t\t\r\n\t\tassertNull( rs.getObject(\"vb\") );\r\n\r\n\t\tassertTrue( rs.next() );\r\n\t\tassertEqualsObject( \"\", new byte[0], rs.getObject(\"vb\"), false );\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\tassertEqualsObject( \"\", table3.getBytes(), rs.getObject(\"vb\"), false );\r\n\t\t\r\n\t\tassertFalse( rs.next() );\r\n\t}\r\n\r\n\r\n\tpublic void test2Columns() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs = null;\r\n\t\tString oldValue;\r\n\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1+\",\"+table2+\" ORDER  by v, c2\");\r\n\r\n\t\tassertTrue( rs.next() );\r\n\t\tassertNull( rs.getObject(\"v\") );\r\n\t\tassertNull( rs.getObject(\"c2\") );\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"c2\");\r\n\r\n\t\tint count = 1;\r\n\t\twhile(rs.next() && rs.getString(\"v\") == null){\r\n\t\t\tString newValue = rs.getString(\"c2\");\r\n\t\t\tassertTrue( oldValue.compareTo( newValue ) < 0 );\r\n\t\t\toldValue = newValue;\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount+1, count );\r\n\t\t\r\n\t\tboolean isNext = true;\r\n\t\twhile(isNext){\r\n\t\t\tString vValue = rs.getString(\"v\");\r\n\t\t\tassertNull( rs.getObject(\"c2\") );\r\n\t\t\r\n\t\t\tassertTrue( rs.next() );\r\n\t\t\toldValue = rs.getString(\"c2\");\r\n\t\t\tassertEquals( vValue, rs.getString(\"v\") );\r\n\r\n\t\t\tisNext = rs.next();\r\n\t\t\tcount = 1;\r\n\t\t\twhile(isNext && vValue.equals(rs.getString(\"v\"))){\r\n\t\t\t\tString newValue = rs.getString(\"c2\");\r\n\t\t\t\tassertTrue( oldValue.compareTo( newValue ) < 0 );\r\n\t\t\t\toldValue = newValue;\r\n\t\t\t\tcount++;\r\n\t\t\t\tisNext = rs.next();\r\n\t\t\t}\r\n\t\t\tassertEquals( valueCount+1, count );\r\n\t\t}\r\n\t}\r\n\r\n\t\r\n\r\n\tpublic void testOrderBy_Scollable() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);\r\n\t\tResultSet rs;\r\n\t\tint count;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by v\");\r\n\t\t\r\n\t\t//jetzt irgendwo in die Mitte scrollen\r\n\t\trs.next();\r\n\t\trs.next();\r\n\t\trs.previous(); //dann soll der Zeiger nicht am Ende des bereits gefetchten stehen\r\n\t\t\r\n\t\trs.last();\r\n\t\tcount = 0;\r\n\t\twhile(rs.previous()) count++;\t\t\r\n\t\tassertEquals( valueCount, count );\r\n\r\n\t\trs.beforeFirst();\r\n\t\tcount = -1;\r\n\t\twhile(rs.next()) count++;\t\t\r\n\t\tassertEquals( valueCount, count );\r\n\r\n\t\trs.beforeFirst();\r\n\t\tcount = -1;\r\n\t\twhile(rs.next()) count++;\t\t\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\r\n\t\r\n\tpublic void testOrderBy_ScollableDesc() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);\r\n\t\tResultSet rs;\r\n\t\tint count;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by i desc, d\");\r\n\t\t\r\n\t\t//jetzt irgendwo in die Mitte scrollen\r\n\t\trs.next();\r\n\t\trs.next();\r\n\t\trs.previous(); //dann soll der Zeiger nicht am Ende des bereits gefetchten stehen\r\n\t\t\r\n\t\trs.last();\r\n\t\tcount = 0;\r\n\t\twhile(rs.previous()) count++;\t\t\r\n\t\tassertEquals( valueCount, count );\r\n\r\n\t\trs.beforeFirst();\r\n\t\tcount = -1;\r\n\t\twhile(rs.next()) count++;\t\t\r\n\t\tassertEquals( valueCount, count );\r\n\r\n\t\trs.beforeFirst();\r\n\t\tcount = -1;\r\n\t\twhile(rs.next()) count++;\t\t\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\r\n\t\r\n\tpublic void testOrderBy_Scollable2() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);\r\n\t\tResultSet rs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by v\");\r\n\r\n\t\t\r\n\t\tint colCount = rs.getMetaData().getColumnCount();\r\n\t\tArrayList result = new ArrayList();\r\n\t\twhile(rs.next()){\r\n\t\t\tObject[] row = new Object[colCount];\r\n\t\t\tfor(int i=0; i<colCount; i++){\r\n\t\t\t\trow[i] = rs.getObject(i+1);\r\n\t\t\t}\r\n\t\t\tresult.add(row);\r\n\t\t}\r\n\t\t\r\n\t\tint rowCount = result.size();\r\n\t\twhile(rs.previous()){\r\n\t\t\tObject[] row = (Object[])result.get(--rowCount);\r\n\t\t\tfor(int i=0; i<colCount; i++){\r\n\t\t\t\tassertEquals( \"Difference in row:\"+rowCount, row[i], rs.getObject(i+1));\r\n\t\t\t}\r\n\t\t}\r\n\t\tassertEquals( \"RowCount different between next and previous:\"+rowCount, 0, rowCount);\r\n\t}\r\n\r\n\t\r\n\tpublic void testUnion() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tString oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT v, 5 as Const FROM \" + table1 + \" Union All Select vc, 6 From \" + table3 + \" ORDER by v\");\r\n\t\t\r\n\t\tassertRSMetaData(rs, new String[]{\"v\", \"Const\"}, new int[]{Types.VARCHAR, Types.INTEGER});\r\n\t\t\r\n\t\tassertTrue( rs.next() );\t\t\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\tassertNull(oldValue);\r\n\t\t\r\n\t\tassertTrue( rs.next() );\t\t\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\tassertNull(oldValue);\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\t\r\n\t\tint count = 3;\r\n\t\twhile(rs.next()){\r\n\t\t\tString newValue = rs.getString(\"v\");\r\n\t\t\tassertTrue( oldValue.compareTo( newValue ) < 0 );\r\n\t\t\toldValue = newValue;\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount+4, count );\r\n\t}\r\n\r\n\r\n}\r\n"},{"path":"/src/smallsql/junit/TestThreads.java","source":"/*\r\n * Created on 13.07.2008\r\n */\r\npackage smallsql.junit;\r\n\r\nimport java.sql.*;\r\nimport java.util.ArrayList;\r\n\r\n/**\r\n * Test some thread problems.\r\n * \r\n * @author Volker Berlin\r\n */\r\npublic class TestThreads extends BasicTestCase{\r\n\r\n    volatile Throwable throwable;\r\n\r\n\r\n    /**\r\n     * Test the concurrently read of a table\r\n     * \r\n     * @throws Throwable\r\n     *             if an thread problem occur\r\n     */\r\n    public void testConcurrentRead() throws Throwable{\r\n        ArrayList threadList = new ArrayList();\r\n        throwable = null;\r\n\r\n        // Any table from another test that include rows.\r\n        final String sql = \"Select * From table_OrderBy1\";\r\n\r\n        // calculate the row count of this table\r\n        final Connection con = AllTests.getConnection();\r\n        Statement st = con.createStatement();\r\n        ResultSet rs = st.executeQuery(\"Select * From table_OrderBy1\");\r\n        int count = 0;\r\n        while(rs.next()){\r\n            count++;\r\n        }\r\n        final int rowCount = count;\r\n\r\n        // start threads that check the row count\r\n        for(int i = 0; i < 200; i++){\r\n            Thread thread = new Thread(new Runnable(){\r\n\r\n                public void run(){\r\n                    try{\r\n                        assertRowCount(rowCount, sql);\r\n                    }catch(Throwable ex){\r\n                        throwable = ex;\r\n                    }\r\n                }\r\n\r\n            });\r\n            threadList.add(thread);\r\n            thread.start();\r\n        }\r\n\r\n        // wait until all threads are finish\r\n        for(int i = 0; i < threadList.size(); i++){\r\n            Thread thread = (Thread)threadList.get(i);\r\n            thread.join(5000);\r\n        }\r\n\r\n        // throw the exception if one occur\r\n        if(throwable != null){\r\n            throw throwable;\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Create a table with a single row. In different threads on the same connection a int value will be increment.\r\n     * \r\n     * @throws Throwable\r\n     *             if an thread problem occur\r\n     */\r\n    public void testConcurrentThreadWrite() throws Throwable{\r\n        ArrayList threadList = new ArrayList();\r\n        throwable = null;\r\n        final Connection con = AllTests.getConnection();\r\n        Statement st = con.createStatement();\r\n        try{\r\n            st.execute(\"CREATE TABLE ConcurrentWrite( value int)\");\r\n            st.execute(\"INSERT INTO ConcurrentWrite(value) Values(0)\");\r\n\r\n            // start threads that check the row count\r\n            for(int i = 0; i < 200; i++){\r\n                Thread thread = new Thread(new Runnable(){\r\n\r\n                    public void run(){\r\n                        try{\r\n                            Statement st2 = con.createStatement();\r\n                            int count = st2.executeUpdate(\"UPDATE ConcurrentWrite SET value = value + 1\");\r\n                            assertEquals(\"Update Count\", 1, count);\r\n                        }catch(Throwable ex){\r\n                            throwable = ex;\r\n                        }\r\n                    }\r\n\r\n                });\r\n                threadList.add(thread);\r\n                thread.start();\r\n            }\r\n\r\n            // wait until all threads are finish\r\n            for(int i = 0; i < threadList.size(); i++){\r\n                Thread thread = (Thread)threadList.get(i);\r\n                thread.join(5000);\r\n            }\r\n\r\n            // throw the exception if one occur\r\n            if(throwable != null){\r\n                throw throwable;\r\n            }\r\n\r\n            assertEqualsRsValue(new Integer(200), \"SELECT value FROM ConcurrentWrite\");\r\n        }finally{\r\n            dropTable(con, \"ConcurrentWrite\");\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Create a table with a single row. In different connections a int value will be increment.\r\n     * \r\n     * @throws Throwable\r\n     *             if an thread problem occur\r\n     */\r\n    public void testConcurrentConnectionWrite() throws Throwable{\r\n        ArrayList threadList = new ArrayList();\r\n        throwable = null;\r\n        Connection con = AllTests.getConnection();\r\n        Statement st = con.createStatement();\r\n        try{\r\n            st.execute(\"CREATE TABLE ConcurrentWrite( value int)\");\r\n            st.execute(\"INSERT INTO ConcurrentWrite(value) Values(0)\");\r\n\r\n            // start threads that check the row count\r\n            for(int i = 0; i < 200; i++){\r\n                Thread thread = new Thread(new Runnable(){\r\n\r\n                    public void run(){\r\n                        try{\r\n                            Connection con2 = AllTests.createConnection();\r\n                            Statement st2 = con2.createStatement();\r\n                            int count = st2.executeUpdate(\"UPDATE ConcurrentWrite SET value = value + 1\");\r\n                            assertEquals(\"Update Count\", 1, count);\r\n                            con2.close();\r\n                        }catch(Throwable ex){\r\n                            throwable = ex;\r\n                        }\r\n                    }\r\n\r\n                });\r\n                threadList.add(thread);\r\n                thread.start();\r\n            }\r\n\r\n            // wait until all threads are finish\r\n            for(int i = 0; i < threadList.size(); i++){\r\n                Thread thread = (Thread)threadList.get(i);\r\n                thread.join(5000);\r\n            }\r\n\r\n            // throw the exception if one occur\r\n            if(throwable != null){\r\n                throw throwable;\r\n            }\r\n\r\n            assertEqualsRsValue(new Integer(200), \"SELECT value FROM ConcurrentWrite\");\r\n        }finally{\r\n            dropTable(con, \"ConcurrentWrite\");\r\n        }\r\n    }\r\n\r\n}\r\n"},{"path":"/src/smallsql/junit/TestOrderBy.java","source":"/* =============================================================\r\n * SmallSQL : a free Java DBMS library for the Java(tm) platform\r\n * =============================================================\r\n *\r\n * (C) Copyright 2004-2006, by Volker Berlin.\r\n *\r\n * Project Info:  http://www.smallsql.de/\r\n *\r\n * This library is free software; you can redistribute it and/or modify it \r\n * under the terms of the GNU Lesser General Public License as published by \r\n * the Free Software Foundation; either version 2.1 of the License, or \r\n * (at your option) any later version.\r\n *\r\n * This library is distributed in the hope that it will be useful, but \r\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \r\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public \r\n * License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, \r\n * USA.  \r\n *\r\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc. \r\n * in the United States and other countries.]\r\n *\r\n * ---------------\r\n * TestOrderBy.java\r\n * ---------------\r\n * Author: Volker Berlin\r\n * \r\n */\r\npackage smallsql.junit;\r\n\r\nimport java.sql.*;\r\nimport java.util.ArrayList;\r\n\r\n/**\r\n * @author Administrator\r\n *\r\n * To change the template for this generated type comment go to\r\n * Window - Preferences - Java - Code Generation - Code and Comments\r\n */\r\npublic class TestOrderBy extends BasicTestCase {\r\n\r\n\tstatic private boolean init;\r\n\tprivate static final String table1 = \"table_OrderBy1\";\r\n\tprivate static final String table2 = \"table_OrderBy2\";\r\n\tprivate static final String table3 = \"table_OrderBy3\";\r\n\tstatic private int valueCount;\r\n\t\r\n\tpublic void init(){\r\n\t\tif(init) return;\r\n\t\ttry{\r\n\t\t\tConnection con = AllTests.getConnection();\r\n\t\t\tdropTable( con, table1 );\r\n\t\t\tdropTable( con, table2 );\r\n\t\t\tdropTable( con, table3 );\r\n\t\t\tStatement st = con.createStatement();\r\n\t\t\tst.execute(\"create table \" + table1 + \"(v varchar(30), c char(30), nv nvarchar(30),i int, d float, r real, bi bigint, b boolean)\");\r\n\t\t\tst.execute(\"create table \" + table2 + \"(c2 char(30))\");\r\n\t\t\tst.execute(\"create table \" + table3 + \"(vc varchar(30), vb varbinary(30))\");\r\n\t\t\tst.close();\r\n\t\t\t\r\n\t\t\tPreparedStatement pr = con.prepareStatement(\"INSERT into \" + table1 + \"(v,c,nv,i,d,r,bi,b) Values(?,?,?,?,?,?,?,?)\");\r\n\t\t\tPreparedStatement pr2= con.prepareStatement(\"INSERT into \" + table2 + \"(c2) Values(?)\");\r\n\t\t\tfor(int i=150; i>-10; i--){\r\n\t\t\t\tpr.setString( 1, String.valueOf(i));\r\n\t\t\t\tpr.setString( 2, String.valueOf(i));\r\n\t\t\t\tpr.setString( 3, String.valueOf( (char)i ));\r\n\t\t\t\tpr.setInt   ( 4, i );\r\n\t\t\t\tpr.setDouble( 5, i );\r\n\t\t\t\tpr.setFloat ( 6, i );\r\n\t\t\t\tpr.setInt   ( 7, i );\r\n\t\t\t\tpr.setBoolean( 8, i == 0 );\r\n\t\t\t\tpr.execute();\r\n\t\t\t\tpr2.setString( 1, String.valueOf(i));\r\n\t\t\t\tpr2.execute();\r\n\t\t\t\tvalueCount++;\r\n\t\t\t}\r\n\t\t\tpr.setObject( 1, null, Types.VARCHAR);\r\n\t\t\tpr.setObject( 2, null, Types.VARCHAR);\r\n\t\t\tpr.setObject( 3, null, Types.VARCHAR);\r\n\t\t\tpr.setObject( 4, null, Types.VARCHAR);\r\n\t\t\tpr.setObject( 5, null, Types.VARCHAR);\r\n\t\t\tpr.setObject( 6, null, Types.VARCHAR);\r\n\t\t\tpr.setObject( 7, null, Types.VARCHAR);\r\n\t\t\tpr.setObject( 8, null, Types.VARCHAR);\r\n\t\t\tpr.execute();\r\n\t\t\tpr2.setObject( 1, null, Types.VARCHAR);\r\n\t\t\tpr2.execute();\r\n\t\t\tpr2.setString( 1, \"\");\r\n\t\t\tpr2.execute();\r\n\r\n\t\t\tpr.close();\r\n\r\n\t\t\tpr = con.prepareStatement(\"INSERT into \" + table3 + \"(vc, vb) Values(?,?)\");\r\n\t\t\tpr.setString( 1, table3);\r\n\t\t\tpr.setBytes( 2, table3.getBytes());\r\n\t\t\tpr.execute();\r\n\t\t\tpr.setString( 1, \"\");\r\n\t\t\tpr.setBytes( 2, new byte[0]);\r\n\t\t\tpr.execute();\r\n\t\t\tpr.setString( 1, null);\r\n\t\t\tpr.setBytes( 2, null);\r\n\t\t\tpr.execute();\r\n\t\t\t\r\n\t\t\tinit = true;\r\n\t\t}catch(Throwable e){\r\n\t\t\te.printStackTrace();\r\n\t\t}\r\n\t}\r\n\t\r\n\t\r\n\tpublic void testOrderBy_char() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tString oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by c\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = rs.getString(\"c\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"c\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tString newValue = rs.getString(\"c\");\r\n\t\t\tassertTrue( oldValue + \"<\" + newValue, oldValue.compareTo( newValue ) < 0 );\r\n\t\t\toldValue = newValue;\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\trs.close();\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void testOrderBy_varchar() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tString oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by v\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tString newValue = rs.getString(\"v\");\r\n\t\t\tassertTrue( oldValue + \"<\" + newValue, oldValue.compareTo( newValue ) < 0 );\r\n\t\t\toldValue = newValue;\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void testOrderBy_varchar_asc() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tString oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by v ASC\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tString newValue = rs.getString(\"v\");\r\n\t\t\tassertTrue( oldValue.compareTo( newValue ) < 0 );\r\n\t\t\toldValue = newValue;\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\trs.close();\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void testOrderBy_varchar_desc() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tString oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by v desc\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(oldValue != null && rs.next()){\r\n\t\t\tString newValue = rs.getString(\"v\");\r\n\t\t\tif(newValue != null){\r\n\t\t\t\tassertTrue( oldValue.compareTo( newValue ) > 0 );\r\n\t\t\t\tcount++;\r\n\t\t\t}\r\n\t\t\toldValue = newValue;\r\n\t\t}\r\n\t\tassertNull(oldValue);\r\n\t\tassertFalse( rs.next() );\r\n\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\t\r\n\tpublic void testOrderBy_varchar_DescAsc() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tString oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by v desc, i asc\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(oldValue != null && rs.next()){\r\n\t\t\tString newValue = rs.getString(\"v\");\r\n\t\t\tif(newValue != null){\r\n\t\t\t\tassertTrue( oldValue.compareTo( newValue ) > 0 );\r\n\t\t\t\tcount++;\r\n\t\t\t}\r\n\t\t\toldValue = newValue;\r\n\t\t}\r\n\t\tassertNull(oldValue);\r\n\t\tassertFalse( rs.next() );\r\n\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\t\r\n\tpublic void testOrderBy_varchar_GroupBy() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tString oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT first(v) cc FROM \" + table1 + \" Group By i ORDER  by first(V)\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = rs.getString(\"cc\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"cc\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tassertTrue( oldValue.compareTo( rs.getString(\"cc\") ) < 0 );\r\n\t\t\toldValue = rs.getString(\"cc\");\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void testOrderBy_varchar_Join() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tString oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" t1 Inner join \"+table2+\" t2 on t1.c=t2.c2  ORDER  by v\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tassertTrue( oldValue.compareTo( rs.getString(\"v\") ) < 0 );\r\n\t\t\toldValue = rs.getString(\"v\");\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void testOrderBy_nvarchar() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tString oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by nv\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = rs.getString(\"nv\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"nv\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tassertTrue( String.CASE_INSENSITIVE_ORDER.compare( oldValue, rs.getString(\"nv\") ) <= 0 );\r\n\t\t\toldValue = rs.getString(\"nv\");\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void testOrderBy_int() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tInteger oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by i\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = (Integer)rs.getObject(\"i\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = (Integer)rs.getObject(\"i\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tassertTrue( oldValue.compareTo( (Integer)rs.getObject(\"i\") ) < 0 );\r\n\t\t\toldValue = (Integer)rs.getObject(\"i\");\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void test_function() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tint oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by abs(i)\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\tassertNull(rs.getObject(\"i\"));\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = Math.abs( rs.getInt(\"i\") );\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tint newValue = Math.abs( rs.getInt(\"i\") );\r\n\t\t\tassertTrue( oldValue <= newValue );\r\n\t\t\toldValue = newValue;\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void test_functionAscDesc() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tint oldValue;\r\n\t\tint oldValue2;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by abs(i) Asc, i desc\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\tassertNull(rs.getObject(\"i\"));\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = Math.abs( rs.getInt(\"i\") );\r\n\t\toldValue2 = rs.getInt(\"i\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tint newValue2 = rs.getInt(\"i\");\r\n\t\t\tint newValue = Math.abs( newValue2 );\r\n\t\t\tassertTrue( oldValue <= newValue );\r\n\t\t\tif(oldValue == newValue){\r\n\t\t\t\tassertTrue( oldValue2 > newValue2 );\r\n\t\t\t}\r\n\t\t\toldValue = newValue;\r\n\t\t\toldValue2 = newValue2;\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void testOrderBy_int_asc() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tInteger oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by i Asc\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = (Integer)rs.getObject(\"i\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = (Integer)rs.getObject(\"i\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tassertTrue( oldValue.compareTo( (Integer)rs.getObject(\"i\") ) < 0 );\r\n\t\t\toldValue = (Integer)rs.getObject(\"i\");\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void testOrderBy_int_desc() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tInteger oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by i Desc\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = (Integer)rs.getObject(\"i\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(oldValue != null && rs.next()){\r\n\t\t\tInteger newValue = (Integer)rs.getObject(\"i\");\r\n\t\t\tif(newValue != null){\r\n\t\t\t\tassertTrue( oldValue.compareTo( newValue ) > 0 );\r\n\t\t\t\tcount++;\r\n\t\t\t}\r\n\t\t\toldValue = newValue;\r\n\t\t}\r\n\t\tassertNull(oldValue);\r\n\t\tassertFalse( rs.next() );\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void testOrderBy_double() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tDouble oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by d\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = (Double)rs.getObject(\"d\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = (Double)rs.getObject(\"d\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tassertTrue( oldValue.compareTo( (Double)rs.getObject(\"d\") ) < 0 );\r\n\t\t\toldValue = (Double)rs.getObject(\"d\");\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void testOrderBy_real() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tFloat oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by r\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = (Float)rs.getObject(\"r\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = (Float)rs.getObject(\"r\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tassertTrue( oldValue.compareTo( (Float)rs.getObject(\"r\") ) < 0 );\r\n\t\t\toldValue = (Float)rs.getObject(\"r\");\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void test_bigint() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tLong oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by bi\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = (Long)rs.getObject(\"bi\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = (Long)rs.getObject(\"bi\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tassertTrue( oldValue.compareTo( (Long)rs.getObject(\"bi\") ) < 0 );\r\n\t\t\toldValue = (Long)rs.getObject(\"bi\");\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void test_bigint_withDoublicateValues() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tLong oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT bi/2 bi_2 FROM \" + table1 + \" ORDER  by (bi/2)\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = (Long)rs.getObject(\"bi_2\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = (Long)rs.getObject(\"bi_2\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tLong newValue = (Long)rs.getObject(\"bi_2\");\r\n\t\t\tassertTrue( oldValue + \"<=\"+newValue, oldValue.compareTo( newValue ) <= 0 );\r\n\t\t\toldValue = newValue;\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void test_boolean() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tboolean oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by b\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = rs.getBoolean(\"b\");\r\n\t\tassertFalse(oldValue);\r\n\t\tassertTrue(rs.wasNull());\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getBoolean(\"b\");\r\n\t\tassertFalse(oldValue);\t\t\r\n\t\tassertFalse(rs.wasNull());\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(!oldValue && rs.next()){\r\n\t\t\toldValue = rs.getBoolean(\"b\");\r\n\t\t\tassertFalse(rs.wasNull());\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\twhile(oldValue && rs.next()){\r\n\t\t\toldValue = rs.getBoolean(\"b\");\r\n\t\t\tassertFalse(rs.wasNull());\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertFalse(rs.next());\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void testVarcharEmpty() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table3 + \" ORDER  by vc\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\t\t\r\n\t\tassertNull( rs.getObject(\"vc\") );\r\n\r\n\t\tassertTrue( rs.next() );\r\n\t\tassertEquals( \"\", rs.getObject(\"vc\") );\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\tassertEquals( table3, rs.getObject(\"vc\") );\r\n\t\t\r\n\t\tassertFalse( rs.next() );\r\n\t}\r\n\t\r\n\r\n\tpublic void testVarbinaryEmpty() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table3 + \" ORDER  by vb\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\t\t\r\n\t\tassertNull( rs.getObject(\"vb\") );\r\n\r\n\t\tassertTrue( rs.next() );\r\n\t\tassertEqualsObject( \"\", new byte[0], rs.getObject(\"vb\"), false );\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\tassertEqualsObject( \"\", table3.getBytes(), rs.getObject(\"vb\"), false );\r\n\t\t\r\n\t\tassertFalse( rs.next() );\r\n\t}\r\n\r\n\r\n\tpublic void test2Columns() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs = null;\r\n\t\tString oldValue;\r\n\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1+\",\"+table2+\" ORDER  by v, c2\");\r\n\r\n\t\tassertTrue( rs.next() );\r\n\t\tassertNull( rs.getObject(\"v\") );\r\n\t\tassertNull( rs.getObject(\"c2\") );\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"c2\");\r\n\r\n\t\tint count = 1;\r\n\t\twhile(rs.next() && rs.getString(\"v\") == null){\r\n\t\t\tString newValue = rs.getString(\"c2\");\r\n\t\t\tassertTrue( oldValue.compareTo( newValue ) < 0 );\r\n\t\t\toldValue = newValue;\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount+1, count );\r\n\t\t\r\n\t\tboolean isNext = true;\r\n\t\twhile(isNext){\r\n\t\t\tString vValue = rs.getString(\"v\");\r\n\t\t\tassertNull( rs.getObject(\"c2\") );\r\n\t\t\r\n\t\t\tassertTrue( rs.next() );\r\n\t\t\toldValue = rs.getString(\"c2\");\r\n\t\t\tassertEquals( vValue, rs.getString(\"v\") );\r\n\r\n\t\t\tisNext = rs.next();\r\n\t\t\tcount = 1;\r\n\t\t\twhile(isNext && vValue.equals(rs.getString(\"v\"))){\r\n\t\t\t\tString newValue = rs.getString(\"c2\");\r\n\t\t\t\tassertTrue( oldValue.compareTo( newValue ) < 0 );\r\n\t\t\t\toldValue = newValue;\r\n\t\t\t\tcount++;\r\n\t\t\t\tisNext = rs.next();\r\n\t\t\t}\r\n\t\t\tassertEquals( valueCount+1, count );\r\n\t\t}\r\n\t}\r\n\r\n\t\r\n\r\n\tpublic void testOrderBy_Scollable() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);\r\n\t\tResultSet rs;\r\n\t\tint count;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by v\");\r\n\t\t\r\n\t\t//jetzt irgendwo in die Mitte scrollen\r\n\t\trs.next();\r\n\t\trs.next();\r\n\t\trs.previous(); //dann soll der Zeiger nicht am Ende des bereits gefetchten stehen\r\n\t\t\r\n\t\trs.last();\r\n\t\tcount = 0;\r\n\t\twhile(rs.previous()) count++;\t\t\r\n\t\tassertEquals( valueCount, count );\r\n\r\n\t\trs.beforeFirst();\r\n\t\tcount = -1;\r\n\t\twhile(rs.next()) count++;\t\t\r\n\t\tassertEquals( valueCount, count );\r\n\r\n\t\trs.beforeFirst();\r\n\t\tcount = -1;\r\n\t\twhile(rs.next()) count++;\t\t\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\r\n\t\r\n\tpublic void testOrderBy_ScollableDesc() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);\r\n\t\tResultSet rs;\r\n\t\tint count;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by i desc, d\");\r\n\t\t\r\n\t\t//jetzt irgendwo in die Mitte scrollen\r\n\t\trs.next();\r\n\t\trs.next();\r\n\t\trs.previous(); //dann soll der Zeiger nicht am Ende des bereits gefetchten stehen\r\n\t\t\r\n\t\trs.last();\r\n\t\tcount = 0;\r\n\t\twhile(rs.previous()) count++;\t\t\r\n\t\tassertEquals( valueCount, count );\r\n\r\n\t\trs.beforeFirst();\r\n\t\tcount = -1;\r\n\t\twhile(rs.next()) count++;\t\t\r\n\t\tassertEquals( valueCount, count );\r\n\r\n\t\trs.beforeFirst();\r\n\t\tcount = -1;\r\n\t\twhile(rs.next()) count++;\t\t\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\r\n\t\r\n\tpublic void testOrderBy_Scollable2() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);\r\n\t\tResultSet rs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by v\");\r\n\r\n\t\t\r\n\t\tint colCount = rs.getMetaData().getColumnCount();\r\n\t\tArrayList result = new ArrayList();\r\n\t\twhile(rs.next()){\r\n\t\t\tObject[] row = new Object[colCount];\r\n\t\t\tfor(int i=0; i<colCount; i++){\r\n\t\t\t\trow[i] = rs.getObject(i+1);\r\n\t\t\t}\r\n\t\t\tresult.add(row);\r\n\t\t}\r\n\t\t\r\n\t\tint rowCount = result.size();\r\n\t\twhile(rs.previous()){\r\n\t\t\tObject[] row = (Object[])result.get(--rowCount);\r\n\t\t\tfor(int i=0; i<colCount; i++){\r\n\t\t\t\tassertEquals( \"Difference in row:\"+rowCount, row[i], rs.getObject(i+1));\r\n\t\t\t}\r\n\t\t}\r\n\t\tassertEquals( \"RowCount different between next and previous:\"+rowCount, 0, rowCount);\r\n\t}\r\n\r\n\t\r\n\tpublic void testUnion() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tString oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT v, 5 as Const FROM \" + table1 + \" Union All Select vc, 6 From \" + table3 + \" ORDER by v\");\r\n\t\t\r\n\t\tassertRSMetaData(rs, new String[]{\"v\", \"Const\"}, new int[]{Types.VARCHAR, Types.INTEGER});\r\n\t\t\r\n\t\tassertTrue( rs.next() );\t\t\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\tassertNull(oldValue);\r\n\t\t\r\n\t\tassertTrue( rs.next() );\t\t\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\tassertNull(oldValue);\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\t\r\n\t\tint count = 3;\r\n\t\twhile(rs.next()){\r\n\t\t\tString newValue = rs.getString(\"v\");\r\n\t\t\tassertTrue( oldValue.compareTo( newValue ) < 0 );\r\n\t\t\toldValue = newValue;\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount+4, count );\r\n\t}\r\n\r\n\r\n}\r\n"},{"path":"/src/smallsql/database/TableView.java","source":"/* =============================================================\r\n * SmallSQL : a free Java DBMS library for the Java(tm) platform\r\n * =============================================================\r\n *\r\n * (C) Copyright 2004-2011, by Volker Berlin.\r\n *\r\n * Project Info:  http://www.smallsql.de/\r\n *\r\n * This library is free software; you can redistribute it and/or modify it \r\n * under the terms of the GNU Lesser General Public License as published by \r\n * the Free Software Foundation; either version 2.1 of the License, or \r\n * (at your option) any later version.\r\n *\r\n * This library is distributed in the hope that it will be useful, but \r\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \r\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public \r\n * License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, \r\n * USA.  \r\n *\r\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc. \r\n * in the United States and other countries.]\r\n *\r\n * ---------------\r\n * TableView.java\r\n * ---------------\r\n * Author: Volker Berlin\r\n * \r\n * Created on 05.06.2004\r\n */\r\npackage smallsql.database;\r\n\r\nimport java.io.*;\r\nimport java.nio.ByteBuffer;\r\nimport java.nio.channels.FileChannel;\r\nimport java.sql.*;\r\n\r\nimport smallsql.database.language.Language;\r\n\r\n\r\n/**\r\n * @author Volker Berlin\r\n */\r\nabstract class TableView {\r\n\r\n\tstatic final int MAGIC_TABLE = 'S' << 24 | 'Q' << 16 | 'L' << 8 | 'T';\r\n\tstatic final int MAGIC_VIEW  = 'S' << 24 | 'Q' << 16 | 'L' << 8 | 'V';\r\n\tstatic final int TABLE_VIEW_VERSION = 2;\r\n\tstatic final int TABLE_VIEW_OLD_VERSION = 1;\r\n\t\r\n\tfinal String name;\r\n\tfinal Columns columns;\r\n\r\n\t/** \r\n\t * Mark the last change on the structure of the Table or View.\r\n\t * If this value change then PreparedStatements need to recompile.\r\n\t */\r\n\tprivate long timestamp = System.currentTimeMillis();\r\n\t\r\n\tstatic final int LOCK_NONE   = 0; // read on READ_COMMITED and READ_UNCOMMITED\r\n\tstatic final int LOCK_INSERT = 1; // prevent only LOCK_TAB\r\n\tstatic final int LOCK_READ   = 2; // occur on read and prevent a write of data, it can occur more as one LOCK_READ per page\r\n\tstatic final int LOCK_WRITE  = 3; // occur on write and prevent every other access to the data, it is only one LOCK_WRITE per page possible\r\n\tstatic final int LOCK_TAB    = 4; // lock the total table\r\n\r\n\r\n\tTableView(String name, Columns columns){\r\n\t\tthis.name = name;\r\n\t\tthis.columns = columns;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Load a Table or View object. \r\n\t */\r\n\tstatic TableView load(SSConnection con, Database database, String name) throws SQLException{\r\n\t    FileChannel raFile = null;\r\n\t\ttry{\r\n\t\t\tString fileName = Utils.createTableViewFileName( database, name );\r\n\t\t\tFile file = new File( fileName );\r\n\t\t\tif(!file.exists())\r\n\t\t\t\tthrow SmallSQLException.create(Language.TABLE_OR_VIEW_MISSING, name);\r\n\t\t\traFile = Utils.openRaFile( file, database.isReadOnly() );\r\n\t\t\tByteBuffer buffer = ByteBuffer.allocate(8);\r\n\t\t\traFile.read(buffer);\r\n\t\t\tbuffer.position(0);\r\n\t\t\tint magic   = buffer.getInt();\r\n\t\t\tint version = buffer.getInt();\r\n\t\t\tswitch(magic){\r\n\t\t\t\tcase MAGIC_TABLE:\r\n\t\t\t\tcase MAGIC_VIEW:\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tthrow SmallSQLException.create(Language.TABLE_OR_VIEW_FILE_INVALID, fileName);\r\n\t\t\t}\r\n\t\t\tif(version > TABLE_VIEW_VERSION)\r\n\t\t\t\tthrow SmallSQLException.create(Language.FILE_TOONEW, new Object[] { new Integer(version), fileName });\r\n\t\t\tif(version < TABLE_VIEW_OLD_VERSION)\r\n\t\t\t\tthrow SmallSQLException.create(Language.FILE_TOOOLD, new Object[] { new Integer(version), fileName });\r\n\t\t\tif(magic == MAGIC_TABLE)\r\n\t\t\t\treturn new Table( database, con, name, raFile, raFile.position(), version);\r\n\t\t\t\treturn new View ( con, name, raFile, raFile.position());\r\n\t\t}catch(Throwable e){\r\n\t\t\tif(raFile != null)\r\n\t\t\t\ttry{\r\n\t\t\t\t\traFile.close();\r\n\t\t\t\t}catch(Exception e2){\r\n\t\t\t\t\tDriverManager.println(e2.toString());\r\n\t\t\t\t}\r\n\t\t\tthrow SmallSQLException.createFromException(e);\r\n\t\t}\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * Get a file object for the current table or view. This is independent\r\n\t * if it exists or not.\r\n\t * @param database The database that the table or view include\r\n\t * @return a file handle, never null\r\n\t */\r\n\tFile getFile(Database database){\r\n\t\treturn new File( Utils.createTableViewFileName( database, name ) );\r\n\t}\r\n\t\r\n\r\n\t/**\r\n\t * Create an empty table or view file that only include the signature.\r\n\t * @param database The database that the table or view should include.\r\n\t * @return A file handle\r\n\t * @throws Exception if any error occur like\r\n\t * <li>file exist already\r\n\t * <li>SecurityException\r\n\t */\r\n\tFileChannel createFile(SSConnection con, Database database) throws Exception{\r\n\t    if( database.isReadOnly() ){\r\n\t        throw SmallSQLException.create(Language.DB_READONLY);\r\n\t    }\r\n\t\tFile file = getFile( database );\r\n\t\tboolean ok = file.createNewFile();\r\n\t\tif(!ok) throw SmallSQLException.create(Language.TABLE_EXISTENT, name);\r\n\t\tFileChannel raFile = Utils.openRaFile( file, database.isReadOnly() );\r\n\t\tcon.add(new CreateFile(file, raFile, con, database));\r\n\t\twriteMagic(raFile);\r\n\t\treturn raFile;\r\n\t}\r\n\t\r\n\tabstract void writeMagic(FileChannel raFile) throws Exception;\r\n\r\n\t\r\n\tString getName(){\r\n\t\treturn name;\r\n\t}\r\n    \r\n\r\n\tlong getTimestamp(){\r\n\t\treturn timestamp;\r\n\t}\r\n\t\r\n\r\n\t/**\r\n\t * Returns the index of a column name. The first column has the index 0.\r\n\t */\r\n\tfinal int findColumnIdx(String columnName){\r\n\t\t// FIXME switch to a tree search on performance reason\r\n\t\tfor(int i=0; i<columns.size(); i++){\r\n\t\t\tif( columns.get(i).getName().equalsIgnoreCase(columnName) ) return i;\r\n\t\t}\r\n\t\treturn -1;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Returns the Column of a column name.\r\n\t */\r\n\tfinal Column findColumn(String columnName){\r\n\t\tfor(int i=0; i<columns.size(); i++){\r\n\t\t\tColumn column = columns.get(i);\r\n\t\t\tif( column.getName().equalsIgnoreCase(columnName) ) return column;\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n\r\n\t\r\n\t/**\r\n\t * Close it and free all resources.\r\n\t */\r\n\tvoid close() throws Exception{/* in this abstract class is nothing to free */}\r\n\r\n}\r\n\r\n\r\n"},{"path":"/src/smallsql/database/ExpressionFunctionTruncate.java","source":"/* =============================================================\r\n * SmallSQL : a free Java DBMS library for the Java(tm) platform\r\n * =============================================================\r\n *\r\n * (C) Copyright 2004-2006, by Volker Berlin.\r\n *\r\n * Project Info:  http://www.smallsql.de/\r\n *\r\n * This library is free software; you can redistribute it and/or modify it \r\n * under the terms of the GNU Lesser General Public License as published by \r\n * the Free Software Foundation; either version 2.1 of the License, or \r\n * (at your option) any later version.\r\n *\r\n * This library is distributed in the hope that it will be useful, but \r\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \r\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public \r\n * License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, \r\n * USA.  \r\n *\r\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc. \r\n * in the United States and other countries.]\r\n *\r\n * ---------------\r\n * ExpressionFunctiontruncate.java\r\n * ---------------\r\n * Author: Volker Berlin\r\n * \r\n */\r\npackage smallsql.database;\r\n\r\n\r\nfinal class ExpressionFunctionTruncate extends ExpressionFunctionReturnP1Number {\r\n\r\n    final int getFunction(){ return SQLTokenizer.TRUNCATE; }\r\n\r\n    boolean isNull() throws Exception{\r\n        return param1.isNull() || param2.isNull();\r\n    }\r\n\t\r\n\r\n    final double getDouble() throws Exception{\r\n\t\tif(isNull()) return 0;\r\n\t\tfinal int places = param2.getInt();\r\n\t\tdouble value = param1.getDouble();\r\n\t\tlong factor = 1;\r\n\t\tif(places > 0){\r\n\t\t\tfor(int i=0; i<places; i++){\r\n\t\t\t\tfactor *= 10;\r\n\t\t\t}\r\n\t\t\tvalue *= factor;\r\n\t\t}else{\r\n\t\t\tfor(int i=0; i>places; i--){\r\n\t\t\t\tfactor *= 10;\r\n\t\t\t}\r\n\t\t\tvalue /= factor;\r\n\t\t}\r\n        value -= value % 1; //modulo also work with values larger long\r\n\t\tif(places > 0){\r\n\t\t\tvalue /= factor;\r\n\t\t}else{\r\n\t\t\tvalue *= factor;\r\n\t\t}\r\n\t\treturn value;\r\n    }\r\n\t\r\n\r\n}"},{"path":"/src/smallsql/database/IndexScrollStatus.java","source":"/* =============================================================\r\n * SmallSQL : a free Java DBMS library for the Java(tm) platform\r\n * =============================================================\r\n *\r\n * (C) Copyright 2004-2007, by Volker Berlin.\r\n *\r\n * Project Info:  http://www.smallsql.de/\r\n *\r\n * This library is free software; you can redistribute it and/or modify it \r\n * under the terms of the GNU Lesser General Public License as published by \r\n * the Free Software Foundation; either version 2.1 of the License, or \r\n * (at your option) any later version.\r\n *\r\n * This library is distributed in the hope that it will be useful, but \r\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \r\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public \r\n * License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, \r\n * USA.  \r\n *\r\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc. \r\n * in the United States and other countries.]\r\n *\r\n * ---------------\r\n * IndexScrollStatus.java\r\n * ---------------\r\n * Author: Volker Berlin\r\n * \r\n * Created on 18.04.2005\r\n */\r\npackage smallsql.database;\r\n\r\n/**\r\n * This class save the status of the scrolling through a Index. This is like a Cursor.\r\n */\r\nclass IndexScrollStatus {\r\n\tprivate final IndexNode rootPage;\r\n\tprivate final Expressions expressions; // is used for the description of ASC and DESC\r\n\r\n\tprivate final java.util.Stack nodeStack = new java.util.Stack(); //TODO performance Stack durch nicht synchronisierte Klasse ersetzten\r\n\t/** Used for getRowOffset() as context cash between 2 calls */\r\n\tprivate LongTreeList longList;\r\n\tprivate LongTreeListEnum longListEnum = new LongTreeListEnum();\r\n\r\n\r\n\tIndexScrollStatus(IndexNode rootPage, Expressions expressions){\t\r\n\t\tthis.rootPage\t= rootPage;\r\n\t\tthis.expressions= expressions;\r\n\t\treset();\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * Reset this index to start a new scan of it with nextRowoffset()\r\n\t */\r\n\tfinal void reset(){\r\n\t\tnodeStack.clear();\r\n\t\tboolean asc = (expressions.get(0).getAlias() != SQLTokenizer.DESC_STR);\r\n\t\tnodeStack.push( new IndexNodeScrollStatus(rootPage, asc, true, 0) );\r\n\t}\r\n\r\n\t\r\n\t/**\r\n\t * Return the next rowOffset of this index. You need to call reset() before the first use. \r\n\t * @param next if true the next rowOffset else the previous rowOffset\r\n\t */\r\n\tfinal long getRowOffset( boolean scroll){\r\n\t\tif(longList != null){\r\n\t\t\tlong rowOffset = scroll ? \r\n\t\t\t\t\t\t\t\tlongList.getNext(longListEnum) : \r\n\t\t\t\t\t\t\t\tlongList.getPrevious(longListEnum);\r\n\t\t\tif(rowOffset < 0){\r\n\t\t\t\t// No more entries on this node\r\n\t\t\t\tlongList = null;\r\n\t\t\t}else{\r\n\t\t\t\treturn rowOffset;\r\n\t\t\t}\r\n\t\t}\r\n\t\twhile(true){\r\n\t\t\tIndexNodeScrollStatus status = (IndexNodeScrollStatus)nodeStack.peek();\r\n\t\t\tint level = status.level;\r\n\t\t\tif(!status.asc ^ scroll){\r\n\t\t\t\t//ASC order\r\n\t\t\t\tint idx = ++status.idx;\r\n\t\t\t\tif(idx == -1){\r\n\t\t\t\t\tif(status.nodeValue != null){\r\n\t\t\t\t\t\tif(status.nodeValue instanceof IndexNode){\r\n\t\t\t\t\t\t\tlevel++;\r\n\t\t\t\t\t\t\tnodeStack.push(\r\n\t\t\t\t\t\t\t\tnew IndexNodeScrollStatus( \t(IndexNode)status.nodeValue, \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(expressions.get(level).getAlias() != SQLTokenizer.DESC_STR), \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tscroll, level));\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}else\r\n\t\t\t\t\t\t\treturn getReturnValue(status.nodeValue);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//There is no RowOffset in this node\r\n\t\t\t\t\tidx = ++status.idx;\r\n\t\t\t\t}\r\n\t\t\t\tif(idx >= status.nodes.length){\r\n\t\t\t\t\t//No more nodes in this level\r\n\t\t\t\t\tif(nodeStack.size() > 1){\r\n\t\t\t\t\t\tnodeStack.pop();\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\t//No more RowOffsets in this Index\r\n                        status.idx = status.nodes.length; //to prevent problems with scroll back after multiple calls after the end.\r\n\t\t\t\t\t\treturn -1;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tIndexNode node = status.nodes[idx];\r\n\t\t\t\tnodeStack.push( new IndexNodeScrollStatus(node, status.asc, scroll, level) );\r\n\t\t\t}else{\r\n\t\t\t\t//DESC order\r\n\t\t\t\tint idx = --status.idx;\r\n\t\t\t\tif(idx == -1){\r\n\t\t\t\t\tif(status.nodeValue != null){\r\n\t\t\t\t\t\tif(status.nodeValue instanceof IndexNode){\r\n\t\t\t\t\t\t\tlevel++;\r\n\t\t\t\t\t\t\tnodeStack.push(\r\n\t\t\t\t\t\t\t\tnew IndexNodeScrollStatus( \t(IndexNode)status.nodeValue, \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(expressions.get(level).getAlias() != SQLTokenizer.DESC_STR), \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tscroll, level));\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}else\r\n\t\t\t\t\t\t\treturn getReturnValue(status.nodeValue);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//There is no RowOffset in this node\r\n\t\t\t\t}\r\n\t\t\t\tif(idx < 0){\r\n\t\t\t\t\t//No more nodes in this level\r\n\t\t\t\t\tif(nodeStack.size() > 1){\r\n\t\t\t\t\t\tnodeStack.pop();\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\t//No more RowOffsets in this Index\r\n\t\t\t\t\t\treturn -1;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tIndexNode node = status.nodes[idx];\r\n\t\t\t\tnodeStack.push( new IndexNodeScrollStatus(node, status.asc, scroll, level) );\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\t\r\n\r\n\t/**\r\n\t * Move the index after the last position. The next call nextRowOffset() returns a -1\r\n\t *\r\n\t */\r\n\tfinal void afterLast(){\r\n\t\tlongList = null;\r\n\t\tnodeStack.setSize(1);\r\n\t\t((IndexNodeScrollStatus)nodeStack.peek()).afterLast();\r\n\t}\r\n\t\r\n    \r\n    /**\r\n     * Check if the index is after the last position.\r\n     */\r\n    /*final boolean isAfterLast(){\r\n        if(longList != null || nodeStack.size() != 1){\r\n            return false;\r\n        }\r\n        return ((IndexNodeScrollStatus)nodeStack.peek()).isAfterLast();\r\n    }*/\r\n    \r\n\t\r\n\tprivate final long getReturnValue( Object value){\r\n\t\tif(rootPage.getUnique()){\r\n\t\t\treturn ((Long)value).longValue();\r\n\t\t}else{\r\n\t\t\tlongList = (LongTreeList)value;\r\n\t\t\tlongListEnum.reset();\r\n\t\t\treturn longList.getNext(longListEnum); // there be should one value as minimum\r\n\t\t}\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n\t\t\r\n\r\n}\r\n"},{"path":"/src/smallsql/database/Index.java","source":"/* =============================================================\r\n * SmallSQL : a free Java DBMS library for the Java(tm) platform\r\n * =============================================================\r\n *\r\n * (C) Copyright 2004-2007, by Volker Berlin.\r\n *\r\n * Project Info:  http://www.smallsql.de/\r\n *\r\n * This library is free software; you can redistribute it and/or modify it \r\n * under the terms of the GNU Lesser General Public License as published by \r\n * the Free Software Foundation; either version 2.1 of the License, or \r\n * (at your option) any later version.\r\n *\r\n * This library is distributed in the hope that it will be useful, but \r\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \r\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public \r\n * License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, \r\n * USA.  \r\n *\r\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc. \r\n * in the United States and other countries.]\r\n *\r\n * ---------------\r\n * Index.java\r\n * ---------------\r\n * Author: Volker Berlin\r\n * \r\n */\r\npackage smallsql.database;\r\n\r\nimport java.sql.SQLException;\r\nimport java.util.ArrayList;\r\n\r\n\r\n/**\r\n * To index data there need to solve the follow problems\r\n * - change the values that need to save in the index to a value with sort order that is compatible\r\n *   with the index algorithm.\r\n * - multiple column index need to support. There should no identical save with combinations of values.\r\n * - The data type for column should be constant.\r\n * - the data need to save fast.\r\n * - the size of the index should be small (also with a small count of values)\r\n * - It should use for unique index and nor unique. The unique index can save only one rowOffset.\r\n *   The non unique can save multiple rowOffsets in a LongTreeList.\r\n * - Problem ORDER BY with Joins? There are more as one rowOffset per row.\r\n * \r\n * \r\n * Algorithm:\r\n * - convert the values that the binary order is equals to the value order. We need to handle\r\n *   sign, floating numbers, case insensitive, different binary length (MutableNumeric).\r\n * - create a 256 byte large mask for the first byte.\r\n * - create a 256 byte large status mask\r\n * - create a 256 large Object array\r\n * \r\n * \r\n * @author Volker Berlin\r\n *\r\n */\r\nclass Index{\r\n\r\n\tfinal IndexNode rootPage;\r\n\t\r\n\t/**\r\n\t * Create an Index in the memory. An Index is like a sorted list.\r\n\t * @param unique true if there are no duplicated values allow.\r\n\t */\r\n\tIndex(boolean unique){\r\n\t\trootPage = new IndexNode(unique, (char)-1);\r\n\t}\r\n\t\r\n    \r\n    Index(IndexNode rootPage){\r\n        this.rootPage = rootPage;\r\n    }\r\n    \r\n    \r\n\tIndexScrollStatus createScrollStatus(Expressions expressions){\r\n\t\treturn new IndexScrollStatus(rootPage, expressions);\r\n\t}\r\n\t\r\n\t/**\r\n     * Returns a Long (unique) or a LongTreeList with rowOffsets. If the value in expressions does not exist then it\r\n     * return a null.\r\n     * \r\n     * @param expressions\r\n     *            The value that are search in the Index.\r\n     * @param searchNullValues\r\n     *            expressions with NULL values should return a result.\r\n     * @param nodeList\r\n     *            optional, can be null. The search path in the index tree.\r\n     */\r\n\tfinal Object findRows(Expressions expressions, boolean searchNullValues, ArrayList nodeList) throws Exception{\r\n        IndexNode page = rootPage;\r\n        int count = expressions.size();\r\n        for(int i = 0; i < count; i++){\r\n            page = findRows(page, expressions.get(i), searchNullValues, nodeList);\r\n            if(page == null)\r\n                return null;\r\n            if(i + 1 == count)\r\n                return page.getValue();\r\n            else\r\n                page = (IndexNode)page.getValue();\r\n        }\r\n        throw new Error();\r\n    }\r\n\t\r\n\t\r\n\t/**\r\n     * Returns a Long (unique) or a LongTreeList with rowOffsets. If the value in expressions does not exist then it\r\n     * return a null.\r\n     * \r\n     * @param expressions\r\n     *            The value that are search in the Index.\r\n     * @param searchNullValues\r\n     *            a expression with NULL values should return a result.\r\n     * @param nodeList\r\n     *            optional, can be null. The search path in the index tree.\r\n     */\r\n    final Object findRows(Expression[] expressions, boolean searchNullValues, ArrayList nodeList) throws Exception{\r\n        IndexNode page = rootPage;\r\n        int count = expressions.length;\r\n        for(int i = 0; i < count; i++){\r\n            page = findRows(page, expressions[i], searchNullValues, nodeList);\r\n            if(page == null)\r\n                return null;\r\n            if(i + 1 == count)\r\n                return page.getValue();\r\n            else\r\n                page = (IndexNode)page.getValue();\r\n        }\r\n        throw new Error();\r\n    }\r\n\t\r\n\t\r\n\t/**\r\n     * Return the last IndexNode for the expression. If the value in expressions does not exist then it return a null.\r\n     * \r\n     * @param page\r\n     *            the start point of the search. If it the first expression of a list then it is the rootPage\r\n     * @param expr\r\n     *            the searching expression\r\n     * @param searchNullValues\r\n     *            a expression with NULL values should return a result.\r\n     * @param nodeList\r\n     *            optional, can be null. The search path in the index tree.\r\n     * @return the mapping IndexNode or null.\r\n     */\r\n\tfinal private IndexNode findRows(IndexNode page, Expression expr, boolean searchNullValues, ArrayList nodeList) throws Exception{\r\n\t\t\tif(expr.isNull()){\r\n                if(!searchNullValues){\r\n                    return null;\r\n                }\r\n\t\t\t\tpage = findNull(page);\r\n\t\t\t}else{\r\n\t\t\t\tswitch(expr.getDataType()){\r\n\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\tpage = find( page, floatToBinarySortOrder( expr.getFloat()), 2, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\t\tpage = find( page, doubleToBinarySortOrder( expr.getDouble()), 4, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\t\tpage = find( page, expr.getInt(), 1, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\t\tpage = find( page, shortToBinarySortOrder( expr.getInt()), 1, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\tpage = find( page, intToBinarySortOrder( expr.getInt()), 2, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\tcase SQLTokenizer.SMALLMONEY:\r\n\t\t\t\t\t\tpage = find( page, longToBinarySortOrder( expr.getLong()), 4, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.NVARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.LONGNVARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\t\t\t\tpage = find( page, stringToBinarySortOrder( expr.getString(), false ), nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.NCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\t\tpage = find( page, stringToBinarySortOrder( expr.getString(), true ), nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.VARBINARY:\r\n\t\t\t\t\tcase SQLTokenizer.BINARY:\r\n\t\t\t\t\tcase SQLTokenizer.LONGVARBINARY:\r\n\t\t\t\t\tcase SQLTokenizer.BLOB:\r\n\t\t\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\t\t\tpage = find( page, bytesToBinarySortOrder( expr.getBytes()), nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.BIT:\r\n\t\t\t\t\tcase SQLTokenizer.BOOLEAN:\r\n\t\t\t\t\t\tpage = find( page, expr.getBoolean() ? 2 : 1, 1, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\tcase SQLTokenizer.DECIMAL:\t\t\t\t\t\t\r\n\t\t\t\t\t\tpage = find( page, numericToBinarySortOrder( expr.getNumeric() ), nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault: \r\n\t\t\t\t\t\t//TODO more data types\r\n\t\t\t\t\t\tthrow new Error(String.valueOf(expr.getDataType()));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn page;\r\n\t}\r\n\r\n\t\r\n\t/**\r\n\t * Add a value to the index.\r\n\t * @param rowOffset Is the value that is save in the index. It is typical a row number or a rowOffset.\r\n\t * @param expressions This is the list of ORDER BY columns and describe the position in the index.\r\n\t */\r\n\tfinal void addValues( long rowOffset, Expressions expressions ) throws Exception{\r\n\t\tIndexNode page = this.rootPage;\r\n\t\tint count = expressions.size();\r\n\t\tfor(int i=0; i<count; i++){\r\n\t\t\tExpression expr = expressions.get(i);\r\n\t\t\tboolean isLastValues = (i == count-1);\r\n\t\t\tif(expr.isNull()){\r\n\t\t\t\tpage = addNull(page, rowOffset, isLastValues);\r\n\t\t\t}else{\r\n\t\t\t\tswitch(expr.getDataType()){\r\n\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, floatToBinarySortOrder( expr.getFloat()), isLastValues, 2 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, doubleToBinarySortOrder( expr.getDouble()), isLastValues, 4 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, expr.getInt(), isLastValues, 1 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, shortToBinarySortOrder( expr.getInt()), isLastValues, 1 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, intToBinarySortOrder( expr.getInt()), isLastValues, 2 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\tcase SQLTokenizer.SMALLMONEY:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, longToBinarySortOrder( expr.getLong()), isLastValues, 4 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.NVARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.LONGNVARCHAR:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, stringToBinarySortOrder( expr.getString(), false ), isLastValues );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.NCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, stringToBinarySortOrder( expr.getString(), true ), isLastValues );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.VARBINARY:\r\n\t\t\t\t\tcase SQLTokenizer.BINARY:\r\n\t\t\t\t\tcase SQLTokenizer.LONGVARBINARY:\r\n\t\t\t\t\tcase SQLTokenizer.BLOB:\r\n\t\t\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, bytesToBinarySortOrder( expr.getBytes()), isLastValues );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.BIT:\r\n\t\t\t\t\tcase SQLTokenizer.BOOLEAN:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, expr.getBoolean() ? 2 : 1, isLastValues, 1 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, numericToBinarySortOrder( expr.getNumeric()), isLastValues );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault: \r\n\t\t\t\t\t\t//TODO more data types\r\n\t\t\t\t\t\tthrow new Error(String.valueOf(expr.getDataType()));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\t\t\r\n\t}\r\n\t\r\n\t\r\n\tfinal void removeValue( long rowOffset, Expressions expressions ) throws Exception{\r\n\t\tArrayList nodeList = new ArrayList();\r\n\t\tObject obj = findRows(expressions, true, nodeList);\r\n\t\tif(!rootPage.getUnique()){\r\n\t\t\tLongTreeList list = (LongTreeList)obj;\r\n\t\t\tlist.remove(rowOffset);\r\n\t\t\tif(list.getSize() > 0) return;\r\n\t\t}\r\n\t\tIndexNode node = (IndexNode)nodeList.get(nodeList.size()-1);\r\n\t\tnode.clearValue();\r\n\t\tfor(int i = nodeList.size()-2; i >= 0; i--){\r\n\t\t\tif(!node.isEmpty())\r\n\t\t\t\tbreak;\r\n\t\t\tIndexNode parent = (IndexNode)nodeList.get(i);\r\n\t\t\tparent.removeNode( node.getDigit() );\r\n\t\t\tnode = parent;\r\n\t\t}\r\n\t}\r\n\t\r\n\t\r\n\tfinal private IndexNode findNull(IndexNode page){\r\n\t\treturn page.getChildNode( (char)0 );\r\n\t}\r\n\t\r\n\r\n\tfinal private IndexNode addNull(IndexNode page, long rowOffset, boolean isLastValue) throws SQLException{\r\n\t\tif(isLastValue){\r\n\t\t\tpage.addNode( (char)0, rowOffset );\r\n\t\t\treturn null;\r\n\t\t}else\r\n\t\t\treturn page.addRoot((char)0);\r\n\t}\r\n\r\n\t\r\n\tfinal private IndexNode find(IndexNode node, long key, int digitCount, ArrayList nodeList){\r\n\t\tfor(int i=digitCount-1; i>=0; i--){\r\n\t\t\tchar digit = (char)(key >> (i<<4));\r\n\t\t\tnode = node.getChildNode(digit);\r\n\t\t\t\r\n\t\t\tif(node == null) return null;\r\n\t\t\tif(nodeList != null) nodeList.add(node);\r\n\r\n\t\t\tif(equals(node.getRemainderValue(), key, i)){\r\n\t\t\t\treturn node;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn node;\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * The key has a binary sort order. This means the most significant byte is in the high byte.\r\n\t * @param digitCount The count of 16Bit digits.\r\n\t */\r\n\tfinal private IndexNode add(IndexNode node, long rowOffset, long key, boolean isLastValue, int digitCount) throws SQLException{\r\n\t\tfor(int i=digitCount-1; i>=0; i--){\r\n\t\t\tchar digit = (char)(key >> (i<<4));\r\n\t\t\tif(i == 0){\r\n\t\t\t\tif(isLastValue){\r\n\t\t\t\t\tnode.addNode( digit, rowOffset );\r\n\t\t\t\t\treturn null;\r\n\t\t\t\t}\r\n\t\t\t\treturn node.addRoot(digit);\r\n\t\t\t}\r\n\t\t\tnode = node.addNode(digit);\r\n\t\t\tif(node.isEmpty()){\r\n\t\t\t\tif(isLastValue){\r\n\t\t\t\t\tnode.addRemainderKey( rowOffset, key, i );\r\n\t\t\t\t\treturn null;\r\n\t\t\t\t}\r\n\t\t\t\treturn node.addRootValue( key, i);\r\n\t\t\t}else\r\n\t\t\tif(equals(node.getRemainderValue(), key, i)){\r\n\t\t\t\tif(isLastValue){\r\n\t\t\t\t\tnode.saveValue( rowOffset);\r\n\t\t\t\t\treturn null;\r\n\t\t\t\t}\r\n\t\t\t\treturn node.addRoot();\r\n\t\t\t}\t\t\r\n\t\t}\r\n\t\tthrow new Error();\r\n\t}\r\n\t\r\n\t\r\n\tfinal private IndexNode find(IndexNode node, char[] key, ArrayList nodeList){\r\n\t\tint length = key.length;\r\n\t\tint i=-1;\r\n\t\twhile(true){\r\n\t\t\t// the first digit include 0-null; 1-empty; 2 another value\r\n\t\t\tchar digit = (i<0) ? (length == 0 ? (char)1 : 2)\r\n\t\t\t\t\t\t\t  : (key[i]);\r\n\t\t\tnode = node.getChildNode(digit);\r\n\r\n\t\t\tif(node == null) return null;\r\n\t\t\tif(nodeList != null) nodeList.add(node);\r\n\t\t\tif(++i == length){\r\n\t\t\t\treturn node;\r\n\t\t\t}\r\n\r\n\t\t\tif(equals(node.getRemainderValue(), key, i)){\r\n\t\t\t\treturn node;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * Add a byte array to the Index.\r\n\t */\r\n\tfinal private IndexNode add(IndexNode node, long rowOffset, char[] key, boolean isLast) throws SQLException{\r\n\t\tint length = key.length;\r\n\t\tint i=-1;\r\n\t\twhile(true){\r\n\t\t\t// the first digit include 0-null; 1-empty; 2 another value\r\n\t\t\tchar digit = (i<0) ? (length == 0 ? (char)1 : 2)\r\n\t\t\t\t\t\t\t  : (key[i]);\r\n\t\t\tif(++i == length){\r\n\t\t\t\tif(isLast){\r\n\t\t\t\t\tnode.addNode( digit, rowOffset );\r\n\t\t\t\t\treturn null;\r\n\t\t\t\t}\r\n\t\t\t\treturn node.addRoot(digit);\r\n\t\t\t}\r\n\t\t\tnode = node.addNode(digit);\r\n\t\t\tif(node.isEmpty()){\r\n\t\t\t\tif(isLast){\r\n\t\t\t\t\tnode.addRemainderKey( rowOffset, key, i );\r\n\t\t\t\t\treturn null;\r\n\t\t\t\t}\r\n\t\t\t\treturn node.addRootValue( key, i );\r\n\t\t\t}else\r\n\t\t\tif(equals(node.getRemainderValue(), key, i)){\r\n\t\t\t\tif(isLast){\r\n\t\t\t\t\tnode.saveValue(rowOffset);\r\n\t\t\t\t\treturn null;\r\n\t\t\t\t}\r\n\t\t\t\treturn node.addRoot();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * Remove all entries\r\n\t */\r\n\tfinal void clear(){\r\n\t\trootPage.clear();\r\n\t}\r\n\t/*================================================================\r\n\t * Normalize functions\r\n\t * convert the value to a binary with identical sort order \r\n\t * like the original values. \r\n\t ================================================================*/\r\n\t\r\n\t\r\n\tfinal static private int floatToBinarySortOrder(float value){\r\n\t\tint intValue = Float.floatToIntBits(value);\r\n\t\treturn (intValue<0) ?\r\n\t\t\t~intValue :\r\n\t\t\tintValue ^ 0x80000000;\t\t\t\r\n\t}\r\n\t\r\n\tfinal static private long doubleToBinarySortOrder(double value){\r\n\t\tlong intValue = Double.doubleToLongBits(value);\r\n\t\treturn (intValue<0) ?\r\n\t\t\t~intValue :\r\n\t\t\tintValue ^ 0x8000000000000000L;\t\t\t\r\n\t}\r\n\t\r\n\tfinal static private int shortToBinarySortOrder(int value){\r\n\t\treturn value ^ 0x8000;\r\n\t}\r\n\t\r\n\tfinal static private int intToBinarySortOrder(int value){\r\n\t\treturn value ^ 0x80000000;\r\n\t}\r\n\t\r\n\tfinal static private long longToBinarySortOrder(long value){\r\n\t\treturn value ^ 0x8000000000000000L;\r\n\t}\r\n\t\r\n\t\r\n\tfinal static private char[] stringToBinarySortOrder(String value, boolean needTrim){\r\n\t\tint length = value.length();\r\n\t\tif(needTrim){\r\n\t\t\twhile(length > 0 && value.charAt(length-1) == ' ') length--;\r\n\t\t}\r\n\t\tchar[] puffer = new char[length];\r\n\t\tfor(int i=0; i<length; i++){\r\n\t\t\tpuffer[i] = Character.toLowerCase(Character.toUpperCase( value.charAt(i) ));\r\n\t\t}\r\n\t\treturn puffer;\r\n\t}\r\n\t\r\n\t\r\n\tfinal static private char[] bytesToBinarySortOrder(byte[] value){\r\n\t\tint length = value.length;\r\n\t\tchar[] puffer = new char[length];\r\n\t\tfor(int i=0; i<length; i++){\r\n\t\t\tpuffer[i] = (char)(value[i] & 0xFF);\r\n\t\t}\r\n\t\treturn puffer;\r\n\t}\r\n\t\r\n\t\r\n\tfinal static private char[] numericToBinarySortOrder(MutableNumeric numeric){\r\n\t\tint[] value = numeric.getInternalValue();\r\n\t\tint count = 1;\r\n\t\tint i;\r\n\t\tfor(i=0; i<value.length; i++){\r\n\t\t\tif(value[i] != 0){\r\n\t\t\t\tcount = 2*(value.length - i)+1;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tchar[] puffer = new char[count];\r\n\t\tpuffer[0] = (char)count;\r\n\t\tfor(int c=1; c<count;){\r\n\t\t\tpuffer[c++] = (char)(value[i] >> 16);\r\n\t\t\tpuffer[c++] = (char)value[i++];\r\n\t\t}\r\n\t\treturn puffer;\r\n\t}\r\n\t\r\n\t\r\n\t/*================================================================\r\n\t * \r\n\t * Functions  for reading the index.\r\n\t *\r\n\t ================================================================*/\r\n\t\r\n\t\r\n\t\r\n\tprivate final boolean equals(char[] src1, char[] src2, int offset2){\r\n\t\tif(src1 == null) return false;\r\n\t\tint length = src1.length;\r\n\t\tif(length != src2.length - offset2) return false;\r\n\t\tfor(int i=0; i<length; i++){\r\n\t\t\tif(src1[i] != src2[i+offset2]) return false;\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\r\n\tprivate final boolean equals(char[] src1, long src2, int charCount){\r\n\t\tif(src1 == null) return false;\r\n\t\tint length = src1.length;\r\n\t\tif(length != charCount) return false;\r\n\t\tfor(int i=0, d = charCount-1; i<length; i++){\r\n\t\t\tif(src1[i] != (char)((src2 >> (d-- << 4)))) return false;\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n}\r\n"},{"path":"/src/smallsql/database/SSCallableStatement.java","source":"/* =============================================================\r\n * SmallSQL : a free Java DBMS library for the Java(tm) platform\r\n * =============================================================\r\n *\r\n * (C) Copyright 2004-2007, by Volker Berlin.\r\n *\r\n * Project Info:  http://www.smallsql.de/\r\n *\r\n * This library is free software; you can redistribute it and/or modify it \r\n * under the terms of the GNU Lesser General Public License as published by \r\n * the Free Software Foundation; either version 2.1 of the License, or \r\n * (at your option) any later version.\r\n *\r\n * This library is distributed in the hope that it will be useful, but \r\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \r\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public \r\n * License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, \r\n * USA.  \r\n *\r\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc. \r\n * in the United States and other countries.]\r\n *\r\n * ---------------\r\n * SSCallableStatament.java\r\n * ---------------\r\n * Author: Volker Berlin\r\n * \r\n */\r\npackage smallsql.database;\r\n\r\nimport java.sql.*;\r\nimport java.math.*;\r\nimport java.util.Map;\r\nimport java.util.Calendar;\r\nimport java.net.URL;\r\nimport java.io.*;\r\nimport smallsql.database.language.Language;\r\n\r\npublic class SSCallableStatement extends SSPreparedStatement implements CallableStatement {\r\n\r\n    private boolean wasNull;\r\n\r\n    SSCallableStatement( SSConnection con, String sql ) throws SQLException {\r\n        super( con, sql );\r\n    }\r\n\r\n    SSCallableStatement( SSConnection con, String sql, int rsType, int rsConcurrency ) throws SQLException {\r\n        super( con, sql, rsType, rsConcurrency );\r\n    }\r\n\r\n    private Expression getValue(int i) throws SQLException{\r\n        /**@todo: Implement this java.sql.CallableStatement method*/\r\n        throw new java.lang.UnsupportedOperationException(\"Method getValue() not yet implemented.\");\r\n    }\r\n\r\n    private int findParameter( String parameterName ){\r\n        /**@todo: Implement this java.sql.CallableStatement method*/\r\n        throw new java.lang.UnsupportedOperationException(\"Method findParameter() not yet implemented.\");\r\n    }\r\n/*==============================================================================\r\n\r\n    Public Interface\r\n\r\n==============================================================================*/\r\n    public void registerOutParameter(int i, int sqlType) throws SQLException {\r\n        /**@todo: Implement this java.sql.CallableStatement method*/\r\n        throw new java.lang.UnsupportedOperationException(\"Method registerOutParameter() not yet implemented.\");\r\n    }\r\n    public void registerOutParameter(int i, int sqlType, int scale) throws SQLException {\r\n        /**@todo: Implement this java.sql.CallableStatement method*/\r\n        throw new java.lang.UnsupportedOperationException(\"Method registerOutParameter() not yet implemented.\");\r\n    }\r\n    \r\n    \r\n    public boolean wasNull(){\r\n        return wasNull;\r\n    }\r\n    \r\n    \r\n    public String getString(int i) throws SQLException {\r\n        try{\r\n            String obj = getValue(i).getString();\r\n            wasNull = obj == null;\r\n            return obj;\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }\r\n    public boolean getBoolean(int i) throws SQLException {\r\n        try{\r\n            Expression expr = getValue(i);\r\n            wasNull = expr.isNull();\r\n            return expr.getBoolean();\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }\r\n    public byte getByte(int i) throws SQLException {\r\n        return (byte)getInt( i );\r\n    }\r\n    public short getShort(int i) throws SQLException {\r\n        return (byte)getInt( i );\r\n    }\r\n    public int getInt(int i) throws SQLException {\r\n        try{\r\n            Expression expr = getValue(i);\r\n            wasNull = expr.isNull();\r\n            return expr.getInt();\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }\r\n    public long getLong(int i) throws SQLException {\r\n        try{\r\n            Expression expr = getValue(i);\r\n            wasNull = expr.isNull();\r\n            return expr.getLong();\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }\r\n    public float getFloat(int i) throws SQLException {\r\n        try{\r\n            Expression expr = getValue(i);\r\n            wasNull = expr.isNull();\r\n            return expr.getFloat();\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }\r\n    public double getDouble(int i) throws SQLException {\r\n        try{\r\n            Expression expr = getValue(i);\r\n            wasNull = expr.isNull();\r\n            return expr.getLong();\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }\r\n    public BigDecimal getBigDecimal(int i, int scale) throws SQLException {\r\n        try{\r\n            MutableNumeric obj = getValue(i).getNumeric();\r\n            wasNull = obj == null;\r\n            if(wasNull) return null;\r\n            return obj.toBigDecimal(scale);\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }\r\n    public byte[] getBytes(int i) throws SQLException {\r\n        try{\r\n            byte[] obj = getValue(i).getBytes();\r\n            wasNull = obj == null;\r\n            return obj;\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }\r\n    public Date getDate(int i) throws SQLException {\r\n        try{\r\n\t\t\tExpression expr = getValue(i);\r\n            wasNull = expr.isNull();\r\n\t\t\tif(wasNull) return null;\r\n\t\t\treturn DateTime.getDate( expr.getLong() );\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }\r\n    public Time getTime(int i) throws SQLException {\r\n        try{\r\n\t\t\tExpression expr = getValue(i);\r\n            wasNull = expr.isNull();\r\n\t\t\tif(wasNull) return null;\r\n\t\t\treturn DateTime.getTime( expr.getLong() );\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }\r\n    public Timestamp getTimestamp(int i) throws SQLException {\r\n        try{\r\n            Expression expr = getValue(i);\r\n            wasNull = expr.isNull();\r\n            if(wasNull) return null;\r\n            return DateTime.getTimestamp( expr.getLong() );\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }\r\n    public Object getObject(int i) throws SQLException {\r\n        try{\r\n            Object obj = getValue(i).getObject();\r\n            wasNull = obj == null;\r\n            return obj;\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }\r\n    public BigDecimal getBigDecimal(int i) throws SQLException {\r\n        try{\r\n            MutableNumeric obj = getValue(i).getNumeric();\r\n            wasNull = obj == null;\r\n            if(wasNull) return null;\r\n            return obj.toBigDecimal();\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }\r\n    public Object getObject(int i, Map map) throws SQLException {\r\n        /**@todo: Implement this java.sql.CallableStatement method*/\r\n        throw SmallSQLException.create(Language.UNSUPPORTED_OPERATION, \"Method getObject() not yet implemented.\");\r\n    }\r\n    public Ref getRef(int i) throws SQLException {\r\n        /**@todo: Implement this java.sql.CallableStatement method*/\r\n        throw SmallSQLException.create(Language.UNSUPPORTED_OPERATION, \"Method getRef() not yet implemented.\");\r\n    }\r\n    public Blob getBlob(int i) throws SQLException {\r\n        /**@todo: Implement this java.sql.CallableStatement method*/\r\n        throw SmallSQLException.create(Language.UNSUPPORTED_OPERATION, \"Method getBlob() not yet implemented.\");\r\n    }\r\n    public Clob getClob(int i) throws SQLException {\r\n        /**@todo: Implement this java.sql.CallableStatement method*/\r\n        throw SmallSQLException.create(Language.UNSUPPORTED_OPERATION, \"Method getClob() not yet implemented.\");\r\n    }\r\n    public Array getArray(int i) throws SQLException {\r\n        /**@todo: Implement this java.sql.CallableStatement method*/\r\n        throw SmallSQLException.create(Language.UNSUPPORTED_OPERATION, \"Method getArray() not yet implemented.\");\r\n    }\r\n    public Date getDate(int i, Calendar cal) throws SQLException {\r\n        /**@todo: Implement this java.sql.CallableStatement method*/\r\n        throw SmallSQLException.create(Language.UNSUPPORTED_OPERATION, \"Method getDate() not yet implemented.\");\r\n    }\r\n    public Time getTime(int i, Calendar cal) throws SQLException {\r\n        /**@todo: Implement this java.sql.CallableStatement method*/\r\n        throw SmallSQLException.create(Language.UNSUPPORTED_OPERATION, \"Method getTime() not yet implemented.\");\r\n    }\r\n    public Timestamp getTimestamp(int i, Calendar cal) throws SQLException {\r\n        /**@todo: Implement this java.sql.CallableStatement method*/\r\n        throw SmallSQLException.create(Language.UNSUPPORTED_OPERATION, \"Method getTimestamp() not yet implemented.\");\r\n    }\r\n    public void registerOutParameter(int i, int sqlType, String typeName) throws SQLException {\r\n        /**@todo: Implement this java.sql.CallableStatement method*/\r\n        throw SmallSQLException.create(Language.UNSUPPORTED_OPERATION, \"Method registerOutParameter() not yet implemented.\");\r\n    }\r\n    public void registerOutParameter(String parameterName, int sqlType) throws SQLException {\r\n        registerOutParameter( findParameter( parameterName ), sqlType );\r\n    }\r\n    public void registerOutParameter(String parameterName, int sqlType, int scale) throws SQLException {\r\n        registerOutParameter( findParameter( parameterName ), sqlType, scale );\r\n    }\r\n    public void registerOutParameter(String parameterName, int sqlType, String typeName) throws SQLException {\r\n        registerOutParameter( findParameter( parameterName ), sqlType, typeName );\r\n    }\r\n    public URL getURL(int parameterIndex) throws SQLException {\r\n        /**@todo: Implement this java.sql.CallableStatement method*/\r\n        throw SmallSQLException.create(Language.UNSUPPORTED_OPERATION, \"Method getURL() not yet implemented.\");\r\n    }\r\n    public void setURL(String parameterName, URL x) throws SQLException {\r\n        setURL( findParameter( parameterName ), x );\r\n    }\r\n    public void setNull(String parameterName, int sqlType) throws SQLException {\r\n        setNull( findParameter( parameterName ), sqlType );\r\n    }\r\n    public void setBoolean(String parameterName, boolean x) throws SQLException {\r\n        setBoolean( findParameter( parameterName ), x );\r\n    }\r\n    public void setByte(String parameterName, byte x) throws SQLException {\r\n        setByte( findParameter( parameterName ), x );\r\n    }\r\n    public void setShort(String parameterName, short x) throws SQLException {\r\n        setShort( findParameter( parameterName ), x );\r\n    }\r\n    public void setInt(String parameterName, int x) throws SQLException {\r\n        setInt( findParameter( parameterName ), x );\r\n    }\r\n    public void setLong(String parameterName, long x) throws SQLException {\r\n        setLong( findParameter( parameterName ), x );\r\n    }\r\n    public void setFloat(String parameterName, float x) throws SQLException {\r\n        setFloat( findParameter( parameterName ), x );\r\n    }\r\n    public void setDouble(String parameterName, double x) throws SQLException {\r\n        setDouble( findParameter( parameterName ), x );\r\n    }\r\n    public void setBigDecimal(String parameterName, BigDecimal x) throws SQLException {\r\n        setBigDecimal( findParameter( parameterName ), x );\r\n    }\r\n    public void setString(String parameterName, String x) throws SQLException {\r\n        setString( findParameter( parameterName ), x );\r\n    }\r\n    public void setBytes(String parameterName, byte[] x) throws SQLException {\r\n        setBytes( findParameter( parameterName ), x );\r\n    }\r\n    public void setDate(String parameterName, Date x) throws SQLException {\r\n        setDate( findParameter( parameterName ), x );\r\n    }\r\n    public void setTime(String parameterName, Time x) throws SQLException {\r\n        setTime( findParameter( parameterName ), x );\r\n    }\r\n    public void setTimestamp(String parameterName, Timestamp x) throws SQLException {\r\n        setTimestamp( findParameter( parameterName ), x );\r\n    }\r\n    public void setAsciiStream(String parameterName, InputStream x, int length) throws SQLException {\r\n        setAsciiStream( findParameter( parameterName ), x, length );\r\n    }\r\n    public void setBinaryStream(String parameterName, InputStream x, int length) throws SQLException {\r\n        setBinaryStream( findParameter( parameterName ), x, length );\r\n    }\r\n    public void setObject(String parameterName, Object x, int sqlType, int scale) throws SQLException {\r\n        setObject( findParameter( parameterName ), x, sqlType, scale );\r\n    }\r\n    public void setObject(String parameterName, Object x, int sqlType) throws SQLException {\r\n        setObject( findParameter( parameterName ), x, sqlType );\r\n    }\r\n    public void setObject(String parameterName, Object x) throws SQLException {\r\n        setObject( findParameter( parameterName ), x );\r\n    }\r\n    public void setCharacterStream(String parameterName, Reader x, int length) throws SQLException {\r\n        setCharacterStream( findParameter( parameterName ), x, length );\r\n    }\r\n    public void setDate(String parameterName, Date x, Calendar cal) throws SQLException {\r\n        setDate( findParameter( parameterName ), x, cal );\r\n    }\r\n    public void setTime(String parameterName, Time x, Calendar cal) throws SQLException {\r\n        setTime( findParameter( parameterName ), x, cal );\r\n    }\r\n    public void setTimestamp(String parameterName, Timestamp x, Calendar cal) throws SQLException {\r\n        setTimestamp( findParameter( parameterName ), x, cal );\r\n    }\r\n    public void setNull(String parameterName, int sqlType, String typeName) throws SQLException {\r\n        setNull( findParameter( parameterName ), sqlType, typeName );\r\n    }\r\n    public String getString(String parameterName) throws SQLException {\r\n        return getString( findParameter( parameterName ) );\r\n    }\r\n    public boolean getBoolean(String parameterName) throws SQLException {\r\n        return getBoolean( findParameter( parameterName ) );\r\n    }\r\n    public byte getByte(String parameterName) throws SQLException {\r\n        return getByte( findParameter( parameterName ) );\r\n    }\r\n    public short getShort(String parameterName) throws SQLException {\r\n        return getShort( findParameter( parameterName ) );\r\n    }\r\n    public int getInt(String parameterName) throws SQLException {\r\n        return getInt( findParameter( parameterName ) );\r\n    }\r\n    public long getLong(String parameterName) throws SQLException {\r\n        return getLong( findParameter( parameterName ) );\r\n    }\r\n    public float getFloat(String parameterName) throws SQLException {\r\n        return getFloat( findParameter( parameterName ) );\r\n    }\r\n    public double getDouble(String parameterName) throws SQLException {\r\n        return getDouble( findParameter( parameterName ) );\r\n    }\r\n    public byte[] getBytes(String parameterName) throws SQLException {\r\n        return getBytes( findParameter( parameterName ) );\r\n    }\r\n    public Date getDate(String parameterName) throws SQLException {\r\n        return getDate( findParameter( parameterName ) );\r\n    }\r\n    public Time getTime(String parameterName) throws SQLException {\r\n        return getTime( findParameter( parameterName ) );\r\n    }\r\n    public Timestamp getTimestamp(String parameterName) throws SQLException {\r\n        return getTimestamp( findParameter( parameterName ) );\r\n    }\r\n    public Object getObject(String parameterName) throws SQLException {\r\n        return getObject( findParameter( parameterName ) );\r\n    }\r\n    public BigDecimal getBigDecimal(String parameterName) throws SQLException {\r\n        return getBigDecimal( findParameter( parameterName ) );\r\n    }\r\n    public Object getObject(String parameterName, Map map) throws SQLException {\r\n        return getObject( findParameter( parameterName ), map );\r\n    }\r\n    public Ref getRef(String parameterName) throws SQLException {\r\n        return getRef( findParameter( parameterName ) );\r\n    }\r\n    public Blob getBlob(String parameterName) throws SQLException {\r\n        return getBlob( findParameter( parameterName ) );\r\n    }\r\n    public Clob getClob(String parameterName) throws SQLException {\r\n        return getClob( findParameter( parameterName ) );\r\n    }\r\n    public Array getArray(String parameterName) throws SQLException {\r\n        return getArray( findParameter( parameterName ) );\r\n    }\r\n    public Date getDate(String parameterName, Calendar cal) throws SQLException {\r\n        return getDate( findParameter( parameterName ), cal );\r\n    }\r\n    public Time getTime(String parameterName, Calendar cal) throws SQLException {\r\n        return getTime( findParameter( parameterName ), cal );\r\n    }\r\n    public Timestamp getTimestamp(String parameterName, Calendar cal) throws SQLException {\r\n        return getTimestamp( findParameter( parameterName ), cal );\r\n    }\r\n    public URL getURL(String parameterName) throws SQLException {\r\n        return getURL( findParameter( parameterName ) );\r\n    }\r\n}"},{"path":"/src/smallsql/database/SQLParser.java","source":"/* =============================================================\r\n * SmallSQL : a free Java DBMS library for the Java(tm) platform\r\n * =============================================================\r\n *\r\n * (C) Copyright 2004-2007, by Volker Berlin.\r\n *\r\n * Project Info:  http://www.smallsql.de/\r\n *\r\n * This library is free software; you can redistribute it and/or modify it \r\n * under the terms of the GNU Lesser General Public License as published by \r\n * the Free Software Foundation; either version 2.1 of the License, or \r\n * (at your option) any later version.\r\n *\r\n * This library is distributed in the hope that it will be useful, but \r\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \r\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public \r\n * License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, \r\n * USA.  \r\n *\r\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc. \r\n * in the United States and other countries.]\r\n *\r\n * ---------------\r\n * SQLParser.java\r\n * ---------------\r\n * Author: Volker Berlin\r\n * \r\n */\r\npackage smallsql.database;\r\n\r\nimport java.util.List;\r\nimport java.sql.*;\r\nimport smallsql.database.language.Language;\r\n\r\nfinal class SQLParser {\r\n\r\n\tSSConnection con;\r\n\tprivate char[] sql;\r\n    private List tokens;\r\n    private int tokenIdx;\r\n\r\n    Command parse(SSConnection con, String sqlString) throws SQLException{\r\n    \tthis.con = con;\r\n        Command cmd = parse( sqlString.toCharArray() );\r\n        SQLToken token = nextToken();\r\n        if(token != null){\r\n        \tthrow createSyntaxError(token, Language.STXADD_ADDITIONAL_TOK);\r\n        }\r\n        return cmd;\r\n    }\r\n    \r\n    final private Command parse(char[] sql) throws SQLException{\r\n        this.sql = sql;\r\n        this.tokens = SQLTokenizer.parseSQL( sql );\r\n        tokenIdx = 0;\r\n\r\n        SQLToken token = nextToken(COMMANDS);\r\n        switch (token.value){\r\n            case SQLTokenizer.SELECT:\r\n                    return select();\r\n            case SQLTokenizer.DELETE:\r\n                    return delete();\r\n            case SQLTokenizer.INSERT:\r\n                    return insert();\r\n            case SQLTokenizer.UPDATE:\r\n                    return update();\r\n            case SQLTokenizer.CREATE:\r\n                    return create();\r\n            case SQLTokenizer.DROP:\r\n                    return drop();\r\n            case SQLTokenizer.ALTER:\r\n                    return alter();\r\n            case SQLTokenizer.SET:\r\n                    return set();\r\n\t\t\tcase SQLTokenizer.USE:\r\n\t\t\t\t\ttoken = nextToken(MISSING_EXPRESSION);\r\n\t\t\t\t\tString name = token.getName( sql );\r\n\t\t\t\t\tcheckValidIdentifier( name, token );\r\n\t\t\t\t\tCommandSet set = new CommandSet( con.log, SQLTokenizer.USE);\r\n\t\t\t\t\tset.name = name;\r\n\t\t\t\t\treturn set;\r\n            case SQLTokenizer.EXECUTE:\r\n                    return execute();\r\n            case SQLTokenizer.TRUNCATE:\r\n            \t\treturn truncate();\r\n            default:\r\n                    throw new Error();\r\n        }\r\n    }\r\n    \r\n    \r\n    Expression parseExpression(String expr) throws SQLException{\r\n\t\tthis.sql = expr.toCharArray();\r\n\t\tthis.tokens = SQLTokenizer.parseSQL( sql );\r\n\t\ttokenIdx = 0;\r\n    \treturn expression( null, 0);\r\n    }\r\n\r\n    /**\r\n\t * Create a syntax error message, using a custom message.\r\n\t * \r\n\t * @param token\r\n\t *            token object; if not null, generates a SYNTAX_BASE_OFS,\r\n\t *            otherwise a SYNTAX_BASE_END.\r\n\t * @param addMessage\r\n\t *            additional message object to append.\r\n\t */\r\n    private SQLException createSyntaxError(SQLToken token, String addMessageCode) {\r\n    \tString message = getErrorString(token, addMessageCode, null);\r\n    \treturn SmallSQLException.create(Language.CUSTOM_MESSAGE, message);\r\n    }\r\n    \r\n    /**\r\n\t * Create a syntax error message, using a message with a parameter.\r\n\t * \r\n\t * @param token\r\n\t *            token object; if not null, generates a SYNTAX_BASE_OFS,\r\n\t *            otherwise a SYNTAX_BASE_END.\r\n\t * @param addMessageCode\r\n\t *            additional message[Code] to append.\r\n\t * @param param0\r\n\t *            parameter.\r\n\t */\r\n    private SQLException createSyntaxError(SQLToken token, String addMessageCode, \r\n    \t\tObject param0) {\r\n    \tString message = getErrorString(token, addMessageCode, param0);\r\n    \treturn SmallSQLException.create(Language.CUSTOM_MESSAGE, message);\r\n    }\r\n    \r\n    /**\r\n\t * Create an \"Additional keyword required\" syntax error.\r\n\t * \r\n\t * @param token\r\n\t *            token object.\r\n\t * @param validValues\r\n\t *            valid values.\r\n\t * @return Exception.\r\n\t */\r\n    private SQLException createSyntaxError(SQLToken token, int[] validValues){\r\n    \tString msgStr = SmallSQLException.translateMsg(\r\n    \t\t\tLanguage.STXADD_KEYS_REQUIRED, new Object[] { });\r\n    \t\r\n    \tStringBuffer msgBuf = new StringBuffer( msgStr );\r\n\r\n        for(int i=0; i<validValues.length; i++){\r\n            String name = SQLTokenizer.getKeyWord(validValues[i]);\r\n            if(name == null) name = String.valueOf( (char)validValues[i] );\r\n            msgBuf.append( name );\r\n            if (i < validValues.length - 2)\r\n                msgBuf.append( \", \");\r\n            else\r\n            if ( i == validValues.length - 2 )\r\n                msgBuf.append( \" or \");\r\n        }\r\n\r\n    \tString message = getErrorString(\r\n    \t\t\ttoken, Language.CUSTOM_MESSAGE, msgBuf);\r\n    \treturn SmallSQLException.create(Language.CUSTOM_MESSAGE, message);\r\n    }\r\n\r\n    /**\r\n\t * Create the complete error string (begin + middle + end).\r\n\t * \r\n\t * @param token\r\n\t *            token object.\r\n\t * @param middleMsgCode\r\n\t *            middle message[code].\r\n\t * @param middleMsgParam\r\n\t *            middle message[code] parameter.\r\n\t * @return complete error message string.\r\n\t */\r\n    private String getErrorString(SQLToken token, String middleMsgCode, \r\n    \t\tObject middleMsgParam) {\r\n    \tStringBuffer buffer = new StringBuffer(1024);\r\n\r\n    \t/* begin */\r\n    \t\r\n        if(token != null){\r\n        \tObject[] params = { String.valueOf(token.offset),\r\n        \t\t\t\t\t\tString.valueOf(sql, token.offset, token.length) };\r\n        \tString begin = SmallSQLException.translateMsg(Language.SYNTAX_BASE_OFS, params);\r\n        \tbuffer.append(begin);\r\n        }\r\n        else{\r\n        \tString begin = SmallSQLException.translateMsg(\r\n        \t\t\tLanguage.SYNTAX_BASE_END, new Object[] { });\r\n        \tbuffer.append(begin);\r\n        }\r\n    \t\r\n    \t/* middle */\r\n    \t\r\n    \tString middle = SmallSQLException.translateMsg(\r\n    \t\t\tmiddleMsgCode, new Object[] { middleMsgParam });\r\n    \t\r\n    \tbuffer.append(middle);\r\n    \t\r\n    \t/* end */\r\n    \t\r\n        int valOffset = (token != null) ? token.offset : sql.length;\r\n        int valBegin = Math.max( 0, valOffset-40);\r\n        int valEnd   = Math.min( valOffset+20, sql.length );\r\n        String lineSeparator = System.getProperty( \"line.separator\" );\r\n        buffer.append( lineSeparator );\r\n        buffer.append( sql, valBegin, valEnd-valBegin);\r\n        buffer.append( lineSeparator );\r\n        for(; valBegin<valOffset; valBegin++) buffer.append(' ');\r\n        buffer.append('^');\r\n    \t\r\n    \treturn buffer.toString();    \t\r\n    }\r\n    \r\n    private void checkValidIdentifier(String name, SQLToken token) throws SQLException{\r\n        if(token.value == SQLTokenizer.ASTERISK) return;\r\n        if(token.value != SQLTokenizer.VALUE &&\r\n\t\t   token.value != SQLTokenizer.IDENTIFIER &&\r\n           token.value < 200){\r\n            throw createSyntaxError( token, Language.STXADD_IDENT_EXPECT);\r\n        }\r\n        if(name.length() == 0) {\r\n            throw createSyntaxError( token, Language.STXADD_IDENT_EMPTY, name);\r\n        }\r\n        char firstChar = name.charAt(0);\r\n\t\tif(firstChar != '#' && firstChar < '@') {\r\n\t\t\tthrow createSyntaxError( token, Language.STXADD_IDENT_WRONG, name );\r\n\t\t}\r\n    }\r\n    \r\n\t/**\r\n     * Returns a valid identifier from this token.\r\n     * @param token the token of the identifier\r\n     * @return the string with the name\r\n     * @throws SQLException if the identifier is invalid\r\n     */\r\n    private String getIdentifier(SQLToken token) throws SQLException{\r\n    \tString name = token.getName(sql);\r\n    \tcheckValidIdentifier( name, token );\r\n    \treturn name;\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Returns a valid identifier from the next token from token stack.\r\n     * @return the string with the name\r\n     * @throws SQLException if the identifier is invalid\r\n     */\r\n    private String nextIdentifier() throws SQLException{\r\n    \treturn getIdentifier( nextToken( MISSING_IDENTIFIER ) );\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Check if the identifier is a 2 part name with a point in the middle like FIRST.SECOND\r\n     * @param name the name of the first part\r\n     * @return the second part if exist else returns the first part\r\n     * @throws SQLException \r\n     */\r\n    private String nextIdentiferPart(String name) throws SQLException{\r\n        SQLToken token = nextToken();\r\n        //check if the object name include a database name\r\n        if(token != null && token.value == SQLTokenizer.POINT){\r\n            return nextIdentifier();\r\n        }else{\r\n            previousToken();\r\n        }\r\n        return name;\r\n    }\r\n    \r\n    \r\n    final private boolean isKeyword(SQLToken token){\r\n    \tif(token == null) return false;\r\n    \tswitch(token.value){\r\n    \t\tcase SQLTokenizer.SELECT:\r\n    \t\tcase SQLTokenizer.INSERT:\r\n    \t\tcase SQLTokenizer.UPDATE:\r\n    \t\tcase SQLTokenizer.UNION:\r\n    \t\tcase SQLTokenizer.FROM:\r\n    \t\tcase SQLTokenizer.WHERE:\r\n    \t\tcase SQLTokenizer.GROUP:\r\n    \t\tcase SQLTokenizer.HAVING:\r\n\t\t\tcase SQLTokenizer.ORDER:\r\n    \t\tcase SQLTokenizer.COMMA:\r\n\t\t\tcase SQLTokenizer.SET:\r\n            case SQLTokenizer.JOIN:\r\n            case SQLTokenizer.LIMIT:\r\n    \t\t\treturn true;\r\n    \t}\r\n    \treturn false;\r\n    }\r\n    \r\n\t/** \r\n\t * Return the last token that the method nextToken has return\r\n\t */\r\n\tprivate SQLToken lastToken(){\r\n\t\tif(tokenIdx > tokens.size()){\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\treturn (SQLToken)tokens.get( tokenIdx-1 );\r\n\t}\r\n    private void previousToken(){\r\n        tokenIdx--;\r\n    }\r\n\r\n    private SQLToken nextToken(){\r\n        if(tokenIdx >= tokens.size()){\r\n            tokenIdx++; // must be ever increment that the method previousToken() is working\r\n            return null;\r\n        }\r\n        return (SQLToken)tokens.get( tokenIdx++ );\r\n    }\r\n\r\n    private SQLToken nextToken( int[] validValues) throws SQLException{\r\n        SQLToken token = nextToken();\r\n        if(token == null) throw createSyntaxError( token, validValues);\r\n        if(validValues == MISSING_EXPRESSION){\r\n            return token; // an expression can be contained in every token.\r\n        }\r\n        if(validValues == MISSING_IDENTIFIER){\r\n            // the follow token are not valid identifier\r\n            switch(token.value){\r\n                case SQLTokenizer.PARENTHESIS_L:\r\n                case SQLTokenizer.PARENTHESIS_R:\r\n                case SQLTokenizer.COMMA:\r\n                    throw createSyntaxError( token, validValues);\r\n            }\r\n            return token;\r\n        }\r\n        for(int i=validValues.length-1; i>=0; i--){\r\n            if(token.value == validValues[i]) return token;\r\n        }\r\n        throw createSyntaxError( token, validValues);\r\n    }\r\n    \r\n\r\n    /**\r\n     * A single SELECT of a UNION or only a simple single SELECT.\r\n     * @return\r\n     * @throws SQLException\r\n     */\r\n    private CommandSelect singleSelect() throws SQLException{\r\n        CommandSelect selCmd = new CommandSelect(con.log);\r\n\t\tSQLToken token;\r\n        // scan for prefix like DISTINCT, ALL and the TOP clause; sample: SELECT TOP 15 ...\r\nSwitch: while(true){\r\n\t\t\ttoken = nextToken(MISSING_EXPRESSION);\r\n\t\t\tswitch(token.value){\r\n\t\t\t\tcase SQLTokenizer.TOP:\r\n\t\t\t\t\ttoken = nextToken(MISSING_EXPRESSION);\r\n\t\t\t\t\ttry{\r\n\t\t\t\t\t\tint maxRows = Integer.parseInt(token.getName(sql));\r\n\t\t\t\t\t\tselCmd.setMaxRows(maxRows);\r\n\t\t\t\t\t}catch(NumberFormatException e){\r\n\t\t\t\t\t\tthrow createSyntaxError(token, Language.STXADD_NOT_NUMBER, token.getName(sql));\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.ALL:\r\n\t\t\t\t\tselCmd.setDistinct(false);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.DISTINCT:\r\n\t\t\t\t\tselCmd.setDistinct(true);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tpreviousToken();\r\n\t\t\t\t\tbreak Switch;\r\n\t\t\t}\r\n\t\t}\r\n\r\n        while(true){\r\n            Expression column = expression(selCmd, 0);\r\n            selCmd.addColumnExpression( column );\r\n\r\n            token = nextToken();\r\n            if(token == null) return selCmd; // SELECT without FROM\r\n\r\n            boolean as = false;\r\n            if(token.value == SQLTokenizer.AS){\r\n                token = nextToken(MISSING_EXPRESSION);\r\n                as = true;\r\n            }\r\n\r\n            if(as || (!isKeyword(token))){\r\n            \tString alias = getIdentifier( token);\r\n                column.setAlias( alias );\r\n                token = nextToken();\r\n                if(token == null) return selCmd; // SELECT without FROM\r\n            }\r\n\r\n            switch(token.value){\r\n                case SQLTokenizer.COMMA:\r\n                        if(column == null) throw createSyntaxError( token, MISSING_EXPRESSION );\r\n                        column = null;\r\n                        break;\r\n                case SQLTokenizer.FROM:\r\n                        if(column == null) throw createSyntaxError( token, MISSING_EXPRESSION );\r\n                        column = null;\r\n                        from(selCmd);\r\n                        return selCmd;\r\n\r\n                default:\r\n                        if(!isKeyword(token))\r\n                \t\t\tthrow createSyntaxError( token, new int[]{SQLTokenizer.COMMA, SQLTokenizer.FROM} );\r\n                        previousToken();\r\n                        return selCmd;\r\n            }\r\n        }\r\n    }\r\n    \r\n    \r\n    final private CommandSelect select() throws SQLException{\r\n\t\tCommandSelect selCmd = singleSelect();\r\n\t\tSQLToken token = nextToken();\r\n\t\t   \t\t\r\n    \tUnionAll union = null; \r\n\t\r\n\t\twhile(token != null && token.value == SQLTokenizer.UNION){\r\n\t\t\tif(union == null){\r\n\t\t\t\tunion = new UnionAll();\r\n\t\t\t\tunion.addDataSource(new ViewResult( con, selCmd ));\r\n\t\t\t\tselCmd = new CommandSelect(con.log);\r\n\t\t\t\tselCmd.setSource( union );\r\n\t\t\t\tDataSources from = new DataSources();\r\n\t\t\t\tfrom.add(union);\r\n\t\t\t\tselCmd.setTables( from );\r\n\t\t\t\tselCmd.addColumnExpression( new ExpressionName(\"*\") );\r\n\t\t\t}\r\n\t\t\tnextToken(MISSING_ALL);\r\n\t\t\tnextToken(MISSING_SELECT);\r\n\t\t\tunion.addDataSource( new ViewResult( con, singleSelect() ) );\r\n\t\t\ttoken = nextToken();\r\n\t\t}\r\n\t\tif(token != null && token.value == SQLTokenizer.ORDER){\r\n\t\t\torder( selCmd );\r\n\t\t\ttoken = nextToken();\r\n\t\t}\r\n\t\tif(token != null && token.value == SQLTokenizer.LIMIT){\r\n            limit( selCmd );\r\n            token = nextToken();\r\n        }\r\n        previousToken();\r\n\t\treturn selCmd;\r\n    }\r\n\r\n\r\n    private Command delete() throws SQLException{\r\n    \tCommandDelete cmd = new CommandDelete(con.log);\r\n    \tnextToken(MISSING_FROM);\r\n    \tfrom(cmd);\r\n\t\tSQLToken token = nextToken();\r\n\t\tif(token != null){\r\n\t\t\tif(token.value != SQLTokenizer.WHERE)\r\n\t\t\t\tthrow this.createSyntaxError(token, MISSING_WHERE);\r\n\t\t\twhere(cmd);\r\n\t\t}\r\n\t\treturn cmd;\r\n    }\r\n\r\n\r\n\tprivate Command truncate() throws SQLException{\r\n\t\tCommandDelete cmd = new CommandDelete(con.log);\r\n\t\tnextToken(MISSING_TABLE);\r\n\t\tfrom(cmd);\r\n\t\treturn cmd;\r\n\t}\r\n\r\n\r\n    private Command insert() throws SQLException{\r\n        SQLToken token = nextToken( MISSING_INTO );\r\n        CommandInsert cmd = new CommandInsert( con.log, nextIdentifier() );\r\n\r\n\t\tint parthesisCount = 0;\r\n\r\n\t\ttoken = nextToken(MISSING_PARENTHESIS_VALUES_SELECT);\r\n        if(token.value == SQLTokenizer.PARENTHESIS_L){\r\n        \ttoken = nextToken(MISSING_EXPRESSION);\r\n        \tif(token.value == SQLTokenizer.SELECT){\r\n\t\t\t\tparthesisCount++;\r\n\t\t\t\tcmd.noColumns = true;\r\n        \t}else{\r\n\t\t\t\tpreviousToken();\r\n\t            Expressions list = expressionParenthesisList(cmd);\r\n\t            for(int i=0; i<list.size(); i++){\r\n\t                cmd.addColumnExpression( list.get( i ) );\r\n\t            }\r\n\t            token = nextToken(MISSING_PARENTHESIS_VALUES_SELECT);\r\n        \t}\r\n        }else cmd.noColumns = true;\r\n        \r\nSwitch: while(true)\r\n        switch(token.value){\r\n        \tcase SQLTokenizer.VALUES:{\r\n\t            token = nextToken(MISSING_PARENTHESIS_L);\r\n\t            cmd.addValues( expressionParenthesisList(cmd) );\r\n\t            return cmd;\r\n\t        }\r\n        \tcase SQLTokenizer.SELECT:\r\n        \t\tcmd.addValues( select() );\r\n        \t\twhile(parthesisCount-- > 0){\r\n        \t\t\tnextToken(MISSING_PARENTHESIS_R);\r\n        \t\t}\r\n        \t\treturn cmd;\r\n        \tcase SQLTokenizer.PARENTHESIS_L:\r\n        \t\ttoken = nextToken(MISSING_PARENTHESIS_VALUES_SELECT);\r\n        \t\tparthesisCount++;\r\n        \t\tcontinue Switch;\r\n        \tdefault:\r\n        \t\tthrow new Error();\r\n        }\r\n    }\r\n\r\n\r\n    private Command update() throws SQLException{\r\n\t\tCommandUpdate cmd = new CommandUpdate(con.log);\r\n\t\t// read table name\r\n\t\tDataSources tables = new DataSources();\r\n\t\tcmd.setTables( tables );\r\n\t\tcmd.setSource( rowSource( cmd, tables, 0 ) );\r\n\t\t\r\n\t\tSQLToken token = nextToken(MISSING_SET);\r\n\t\twhile(true){\r\n\t\t\ttoken = nextToken();\r\n\t\t\tExpression dest = expressionSingle( cmd, token);\r\n\t\t\tif(dest.getType() != Expression.NAME) throw createSyntaxError( token, MISSING_IDENTIFIER );\r\n\t\t\tnextToken(MISSING_EQUALS);\r\n\t\t\tExpression src = expression(cmd, 0);\r\n\t\t\tcmd.addSetting( dest, src);\r\n\t\t\ttoken = nextToken();\r\n\t\t\tif(token == null) break;\r\n\t\t\tswitch(token.value){\r\n\t\t\t\tcase SQLTokenizer.WHERE:\r\n\t\t\t\t\twhere(cmd);\r\n\t\t\t\t\treturn cmd;\t\t\t\t\r\n\t\t\t\tcase SQLTokenizer.COMMA:\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\tdefault: throw createSyntaxError( token, MISSING_WHERE_COMMA );\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn cmd;\r\n    }\r\n\r\n\r\n    private Command create() throws SQLException{\r\n        while(true){\r\n            SQLToken token = nextToken(COMMANDS_CREATE);\r\n            switch(token.value){\r\n                case SQLTokenizer.DATABASE:\r\n                    return createDatabase();\r\n                case SQLTokenizer.TABLE:\r\n                    return createTable();\r\n                case SQLTokenizer.VIEW:\r\n                    return createView();\r\n                case SQLTokenizer.INDEX:\r\n                    return createIndex(false);\r\n                case SQLTokenizer.PROCEDURE:\r\n                    return createProcedure();\r\n                case SQLTokenizer.UNIQUE:\r\n                    do{\r\n                        token = nextToken(COMMANDS_CREATE_UNIQUE);\r\n                    }while(token.value == SQLTokenizer.INDEX);\r\n                    return createIndex(true);\r\n                case SQLTokenizer.NONCLUSTERED:\r\n                case SQLTokenizer.CLUSTERED:\r\n                    continue;\r\n                default:\r\n                    throw createSyntaxError( token, COMMANDS_CREATE );\r\n            }\r\n        }\r\n    }\r\n\t\r\n\r\n    private CommandCreateDatabase createDatabase() throws SQLException{\r\n        SQLToken token = nextToken();\r\n        if(token == null) throw createSyntaxError( token, MISSING_EXPRESSION );\r\n        return new CommandCreateDatabase( con.log, token.getName(sql));\r\n    }\r\n\t\r\n    \r\n    private CommandTable createTable() throws SQLException{\r\n        String catalog;\r\n        String tableName = catalog = nextIdentifier();\r\n        tableName = nextIdentiferPart(tableName);\r\n        if(tableName == catalog) catalog = null;\r\n        CommandTable cmdCreate = new CommandTable( con.log, catalog, tableName, SQLTokenizer.CREATE );\r\n        SQLToken token = nextToken( MISSING_PARENTHESIS_L );\r\n\r\n        nextCol:\r\n        while(true){\r\n            token = nextToken( MISSING_EXPRESSION );\r\n\t\t\t\r\n\t\t\tString constraintName;\r\n            if(token.value == SQLTokenizer.CONSTRAINT){\r\n            \t// reading a CONSTRAINT with name\r\n\t\t    \tconstraintName = nextIdentifier();\r\n\t\t\t\ttoken = nextToken( MISSING_KEYTYPE );\r\n            }else{\r\n\t\t\t\tconstraintName = null;\r\n            }\r\n\t\t\tswitch(token.value){\r\n\t\t\t\tcase SQLTokenizer.PRIMARY:\r\n\t\t\t\tcase SQLTokenizer.UNIQUE:\r\n\t\t\t\tcase SQLTokenizer.FOREIGN:\r\n\t\t\t\t\tIndexDescription index = index(cmdCreate, token.value, tableName, constraintName, null);\r\n                    if(token.value == SQLTokenizer.FOREIGN){\r\n                        nextToken( MISSING_REFERENCES );\r\n                        String pk = nextIdentifier();\r\n                        Expressions expressions = new Expressions();\r\n                        Strings columns = new Strings();\r\n                        expressionDefList( cmdCreate, expressions, columns );\r\n                        IndexDescription pkIndex = new IndexDescription( null, pk, SQLTokenizer.UNIQUE, expressions, columns);\r\n                        ForeignKey foreignKey = new ForeignKey(pk, pkIndex, tableName, index);\r\n                        cmdCreate.addForeingnKey(foreignKey);\r\n                    }else{\r\n                        cmdCreate.addIndex( index );\r\n                    }\r\n\t\r\n\t\t\t\t\ttoken = nextToken( MISSING_COMMA_PARENTHESIS );\r\n\t\t\t\t\tswitch(token.value){\r\n\t\t\t\t\t\tcase SQLTokenizer.PARENTHESIS_R:\r\n\t\t\t\t\t\t\treturn cmdCreate;\r\n\t\t\t\t\t\tcase SQLTokenizer.COMMA:\r\n\t\t\t\t\t\t\tcontinue nextCol;\r\n\t\t\t\t\t}\r\n            }\r\n            // the token is a column name\r\n\t\t\ttoken = addColumn( token, cmdCreate );\r\n            if(token == null){\r\n                throw createSyntaxError(token, MISSING_COMMA_PARENTHESIS);\r\n            }\r\n            switch(token.value){\r\n                case SQLTokenizer.PARENTHESIS_R:\r\n                    return cmdCreate;\r\n                case SQLTokenizer.COMMA:\r\n                    continue nextCol;\r\n                default:\r\n                    throw createSyntaxError(token, MISSING_COMMA_PARENTHESIS);\r\n            }\r\n        }\r\n    }\r\n    \r\n\t\r\n    /**\r\n     * Parse a Column and add it to the Command. If the column is unique or primary\r\n     * then an index is added.\r\n     * @param token the SQLToken with the column name\r\n     * @return the token of the delimiter\r\n     */\r\n    private SQLToken addColumn(SQLToken token, CommandTable cmdCreate) throws SQLException{\r\n        String colName = getIdentifier( token );\r\n        Column col = datatype(false);\r\n        col.setName( colName );\r\n\r\n\t\ttoken = nextToken();\r\n        boolean nullableWasSet = false;\r\n        boolean defaultWasSet = col.isAutoIncrement(); // with data type COUNTER already this value is set\r\n        while(true){\r\n            if(token == null){\r\n                cmdCreate.addColumn( col );\r\n                return null;\r\n            }\r\n            switch(token.value){\r\n                case SQLTokenizer.PARENTHESIS_R:\r\n                case SQLTokenizer.COMMA:\r\n                    cmdCreate.addColumn( col );\r\n                    return token;\r\n                case SQLTokenizer.DEFAULT:\r\n                    if(defaultWasSet) throw createSyntaxError( token, MISSING_COMMA_PARENTHESIS );\r\n\t\t\t\t\tint offset = token.offset + token.length;\r\n                    token = nextToken();\r\n                    if(token != null) offset = token.offset;\r\n\t\t\t\t\tpreviousToken();                    \r\n\t\t\t\t\tExpression expr = expression(cmdCreate, 0);\r\n\t\t\t\t\tSQLToken last = lastToken();\r\n\t\t\t\t\tint length = last.offset + last.length - offset;\r\n\t\t\t\t\tString def = new String( sql, offset, length );\r\n                    col.setDefaultValue( expr, def );\r\n                    defaultWasSet = true;\r\n                    break;\r\n                case SQLTokenizer.IDENTITY:\r\n                    if(defaultWasSet) throw createSyntaxError( token, MISSING_COMMA_PARENTHESIS );\r\n                    col.setAutoIncrement(true);\r\n                    defaultWasSet = true;\r\n                    break;\r\n                case SQLTokenizer.NULL:\r\n                    if(nullableWasSet) throw createSyntaxError( token, MISSING_COMMA_PARENTHESIS );\r\n                    //col.setNullable(true); is already default\r\n                    nullableWasSet = true;\r\n                    break;\r\n                case SQLTokenizer.NOT:\r\n                    if(nullableWasSet) throw createSyntaxError( token, MISSING_COMMA_PARENTHESIS );\r\n                    token = nextToken( MISSING_NULL );\r\n                    col.setNullable(false);\r\n                    nullableWasSet = true;\r\n                    break;\r\n\t\t\t\tcase SQLTokenizer.PRIMARY:\r\n\t\t\t\tcase SQLTokenizer.UNIQUE:\r\n\t\t\t\t\tIndexDescription index = index(cmdCreate, token.value, cmdCreate.name, null, colName);\r\n\t\t\t\t\tcmdCreate.addIndex( index );\r\n\t\t\t\t\tbreak;\r\n                default:\r\n                    throw createSyntaxError(token, MISSING_OPTIONS_DATATYPE);\r\n            }\r\n            token = nextToken();\r\n        }\r\n    }\r\n    \r\n\r\n\t/**\r\n\t * Parse construct like:<br>\r\n\t * <li>PRIMARY KEY (col1)\r\n\t * <li>UNIQUE (col1, col2)\r\n\t * <li>FOREIGN KEY REFERENCES ref_table(col1)\r\n\t * @param cmd\r\n\t * @param constraintType one of SQLTokenizer.PRIMARY, SQLTokenizer.UNIQUE or SQLTokenizer.FOREIGN.\r\n\t * @param if it a constrain of the current column else null\r\n\t * @return a new IndexDescription\r\n\t */\r\n\tprivate IndexDescription index(Command cmd, int constraintType, String tableName, String contrainName, String columnName) throws SQLException{\r\n\t\tif(constraintType != SQLTokenizer.UNIQUE) nextToken( MISSING_KEY );\r\n\t\tSQLToken token = nextToken();\r\n        if(token != null){\r\n    \t\tswitch(token.value){\r\n    \t\t\tcase SQLTokenizer.CLUSTERED:\r\n    \t\t\tcase SQLTokenizer.NONCLUSTERED:\r\n    \t\t\t\t// ignoring, this tokens form MS SQL Server are ignored\r\n    \t\t\t\tbreak;\r\n                default:\r\n                    previousToken();\r\n    \t\t}\r\n        }else{\r\n            previousToken();\r\n        }\r\n\t\tStrings columns = new Strings();\r\n\t\tExpressions expressions = new Expressions();\r\n\t\tif(columnName != null){\r\n\t\t\t//Constraint for a single column together with the column definition\r\n\t\t\tcolumns.add(columnName);\r\n\t\t\texpressions.add(new ExpressionName(columnName));\r\n\t\t}else{\r\n\t\t\t//Constraint as addition definition\r\n            expressionDefList( cmd, expressions, columns );\r\n\t\t}\r\n\t\treturn new IndexDescription( contrainName, tableName, constraintType, expressions, columns);\r\n\t}\r\n\r\n\r\n    /**\r\n     * Read a DataTpe description. This is used for CREATE TABLE and CONVERT function. \r\n     * @param isEscape true then the data types start with \"SQL_\". This is used for the Escape Syntax.\r\n     */\r\n    private Column datatype(boolean isEscape) throws SQLException{\r\n\t\tSQLToken token;\r\n\t\tint dataType;\r\n\t\tif(isEscape){\r\n\t\t\ttoken = nextToken( MISSING_SQL_DATATYPE );\r\n\t\t\tswitch(token.value){\r\n\t\t\t\tcase SQLTokenizer.SQL_BIGINT: \t\t\tdataType = SQLTokenizer.BIGINT;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_BINARY:\t\t\tdataType = SQLTokenizer.BINARY; \tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_BIT:\t\t\t\tdataType = SQLTokenizer.BIT;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_CHAR:\t\t\t\tdataType = SQLTokenizer.CHAR;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_DATE:\t\t\t\tdataType = SQLTokenizer.DATE;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_DECIMAL:\t\t\tdataType = SQLTokenizer.DECIMAL;\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_DOUBLE:\t\t\tdataType = SQLTokenizer.DOUBLE;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_FLOAT:\t\t\tdataType = SQLTokenizer.FLOAT;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_INTEGER:\t\t\tdataType = SQLTokenizer.INT;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_LONGVARBINARY:\tdataType = SQLTokenizer.LONGVARBINARY;break;\r\n\t\t\t\tcase SQLTokenizer.SQL_LONGVARCHAR:\t\tdataType = SQLTokenizer.LONGVARCHAR;break;\r\n\t\t\t\tcase SQLTokenizer.SQL_REAL:\t\t\t\tdataType = SQLTokenizer.REAL;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_SMALLINT:\t\t\tdataType = SQLTokenizer.SMALLINT;\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_TIME:\t\t\t\tdataType = SQLTokenizer.TIME;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_TIMESTAMP:\t\tdataType = SQLTokenizer.TIMESTAMP;\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_TINYINT:\t\t\tdataType = SQLTokenizer.TINYINT;\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_VARBINARY:\t\tdataType = SQLTokenizer.VARBINARY;\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_VARCHAR:\t\t\tdataType = SQLTokenizer.VARCHAR;\tbreak;\r\n\t\t\t\tdefault: throw new Error();\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\ttoken = nextToken( MISSING_DATATYPE );\r\n\t\t\tdataType = token.value;\r\n\t\t}\r\n\t\tColumn col = new Column();\r\n\r\n\t\t// two-part  data type\r\n\t\tif(dataType == SQLTokenizer.LONG){\r\n\t\t\ttoken = nextToken();\r\n\t\t\tif(token != null && token.value == SQLTokenizer.RAW){\r\n\t\t\t\tdataType = SQLTokenizer.LONGVARBINARY;\r\n\t\t\t}else{\r\n\t\t\t\tdataType = SQLTokenizer.LONGVARCHAR;\r\n\t\t\t\tpreviousToken();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tswitch(dataType){\r\n\t\t\tcase SQLTokenizer.RAW:\r\n\t\t\t\tdataType = SQLTokenizer.VARBINARY;\r\n\t\t\t\t// no break;\r\n\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\tcase SQLTokenizer.NCHAR:\r\n\t\t\tcase SQLTokenizer.NVARCHAR:\r\n\t\t\tcase SQLTokenizer.BINARY:\r\n\t\t\tcase SQLTokenizer.VARBINARY:\r\n\t\t\t{\r\n\t\t\t\t// detect the maximum column size\r\n                token = nextToken();\r\n\t\t\t\tint displaySize;\r\n\t\t\t\tif(token == null || token.value != SQLTokenizer.PARENTHESIS_L){\r\n\t\t\t\t\tdisplaySize = 30;\r\n                    previousToken();\r\n\t\t\t\t}else{\r\n\t\t\t\t\ttoken = nextToken( MISSING_EXPRESSION );\r\n\t\t\t\t\ttry{\r\n\t\t\t\t\t\tdisplaySize = Integer.parseInt(token.getName(sql) );\r\n\t\t\t\t\t}catch(Exception e){\r\n\t\t\t\t\t\tthrow createSyntaxError(token, MISSING_NUMBERVALUE );\r\n\t\t\t\t\t}\r\n\t\t\t\t\tnextToken( MISSING_PARENTHESIS_R );\r\n\t\t\t\t}\r\n\t\t\t\tcol.setPrecision( displaySize );\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tcase SQLTokenizer.SYSNAME:\r\n\t\t\t\tcol.setPrecision(255);\r\n\t\t\t\tdataType = SQLTokenizer.VARCHAR;\r\n\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.COUNTER:\r\n\t\t\t\tcol.setAutoIncrement(true);\r\n\t\t\t\tdataType = SQLTokenizer.INT;\r\n\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\tcase SQLTokenizer.DECIMAL:\r\n                token = nextToken();\r\n\t\t\t\tif(token != null && token.value == SQLTokenizer.PARENTHESIS_L){\r\n\t\t\t\t\t// read the precision of the data type\r\n\t\t\t\t\ttoken = nextToken( MISSING_EXPRESSION );\r\n\t\t\t\t\tint value;\r\n\t\t\t\t\ttry{\r\n\t\t\t\t\t\tvalue = Integer.parseInt(token.getName(sql) );\r\n\t\t\t\t\t}catch(Exception e){\r\n\t\t\t\t\t\tthrow createSyntaxError(token, MISSING_NUMBERVALUE );\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcol.setPrecision(value);\r\n\t\t\t\t\ttoken = nextToken( MISSING_COMMA_PARENTHESIS );\r\n\t\t\t\t\tif(token.value == SQLTokenizer.COMMA){\r\n\t\t\t\t\t\t// read the scale of the data type\r\n\t\t\t\t\t\ttoken = nextToken( MISSING_EXPRESSION );\r\n\t\t\t\t\t\ttry{\r\n\t\t\t\t\t\t\tvalue = Integer.parseInt(token.getName(sql) );\r\n\t\t\t\t\t\t}catch(Exception e){\r\n\t\t\t\t\t\t\tthrow createSyntaxError(token, MISSING_NUMBERVALUE );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tcol.setScale(value);\r\n\t\t\t\t\t\tnextToken( MISSING_PARENTHESIS_R );\r\n\t\t\t\t\t}\r\n\t\t\t\t}else{\r\n\t\t\t\t\tcol.setPrecision(18); //default Precision for decimal and numeric\r\n                    previousToken();\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t\tcol.setDataType( dataType );\r\n\t\treturn col;\r\n    }\r\n    \r\n    private CommandCreateView createView() throws SQLException{\r\n    \tString viewName = nextIdentifier();\r\n\r\n\t\tnextToken(MISSING_AS);\r\n\t\tSQLToken token = nextToken(MISSING_SELECT);\r\n\t\tCommandCreateView cmd = new CommandCreateView( con.log, viewName );\r\n\t\t\r\n\t\tcmd.sql = new String(sql, token.offset, sql.length-token.offset );\r\n\t\tselect(); //Parse to check for valid\r\n        return cmd;\r\n    }\r\n\r\n\r\n    private CommandTable createIndex(boolean unique) throws SQLException{\r\n        String indexName = nextIdentifier();\r\n        nextToken(MISSING_ON);\r\n        String catalog;\r\n        String tableName = catalog = nextIdentifier();\r\n        tableName = nextIdentiferPart(tableName);\r\n        if(tableName == catalog) catalog = null;\r\n        CommandTable cmd = new CommandTable( con.log, catalog, tableName, SQLTokenizer.INDEX );\r\n        Expressions expressions = new Expressions();\r\n        Strings columns = new Strings();\r\n        expressionDefList( cmd, expressions, columns );\r\n        IndexDescription indexDesc = new IndexDescription( \r\n                indexName, \r\n                tableName, \r\n                unique ? SQLTokenizer.UNIQUE : SQLTokenizer.INDEX, \r\n                        expressions, \r\n                        columns);\r\n        //TODO Create Index\r\n\t\tObject[] param = { \"Create Index\" };\r\n        throw SmallSQLException.create(Language.UNSUPPORTED_OPERATION, param);\r\n    }\r\n\r\n    private CommandCreateDatabase createProcedure() throws SQLException{\r\n        //TODO Create Procedure\r\n\t\tObject[] param = { \"Create Procedure\" };\r\n    \tthrow SmallSQLException.create(Language.UNSUPPORTED_OPERATION, param);\r\n    }\r\n\r\n    private Command drop() throws SQLException{\r\n        SQLToken tokenType = nextToken(COMMANDS_DROP);\r\n        \r\n\t\tString catalog;\r\n\t\tString name = catalog = nextIdentifier();\r\n        name = nextIdentiferPart( name );\r\n        if(name == catalog) catalog = null;\r\n\r\n        switch(tokenType.value){\r\n            case SQLTokenizer.DATABASE:\r\n            case SQLTokenizer.TABLE:\r\n            case SQLTokenizer.VIEW:\r\n            case SQLTokenizer.INDEX:\r\n            case SQLTokenizer.PROCEDURE:\r\n            \treturn new CommandDrop( con.log, catalog, name, tokenType.value);\r\n            default:\r\n                throw createSyntaxError( tokenType, COMMANDS_DROP );\r\n        }\r\n    }\r\n\r\n\r\n    private Command alter() throws SQLException{\r\n    \tSQLToken tokenType = nextToken(COMMANDS_ALTER);\r\n\t\tString catalog;\r\n\t\tString tableName = catalog = nextIdentifier();\r\n        switch(tokenType.value){\r\n        case SQLTokenizer.TABLE:\r\n        case SQLTokenizer.VIEW:\r\n        case SQLTokenizer.INDEX:\r\n        case SQLTokenizer.PROCEDURE:\r\n            tableName = nextIdentiferPart(tableName);\r\n            if(tableName == catalog) catalog = null;\r\n        }\r\n        switch(tokenType.value){\r\n    \t//case SQLTokenizer.DATABASE:\r\n        case SQLTokenizer.TABLE:\r\n            return alterTable( catalog, tableName );\r\n        //case SQLTokenizer.VIEW:\r\n        //case SQLTokenizer.INDEX:\r\n        //case SQLTokenizer.PROCEDURE:\r\n        default:\r\n    \t\tObject[] param = { \"ALTER \" + tokenType.getName( sql ) };\r\n        \tthrow SmallSQLException.create(Language.UNSUPPORTED_OPERATION, param);\r\n        }\r\n    }\r\n    \r\n    \r\n    Command alterTable( String catalog, String name ) throws SQLException{\r\n    \tSQLToken tokenType = nextToken(MISSING_ADD_ALTER_DROP);\r\n        CommandTable cmd = new CommandTable( con.log, catalog, name, tokenType.value );\r\n    \tswitch(tokenType.value){\r\n    \tcase SQLTokenizer.ADD:\r\n    \t\tSQLToken token;\r\n    \t\tdo{\r\n    \t\t\ttoken = nextToken( MISSING_IDENTIFIER );\r\n    \t\t\ttoken = addColumn( token, cmd );\r\n    \t\t}while(token != null && token.value == SQLTokenizer.COMMA );\r\n\r\n    \t\treturn cmd;\r\n    \tdefault:\r\n    \t\tObject[] param = { \"ALTER TABLE \" + tokenType.getName( sql ) };\r\n            throw SmallSQLException.create(Language.UNSUPPORTED_OPERATION, param);\r\n    \t}\r\n    }\r\n    \r\n\r\n    private CommandSet set() throws SQLException{\r\n        SQLToken token = nextToken( COMMANDS_SET );\r\n        switch(token.value){\r\n            case SQLTokenizer.TRANSACTION:\r\n                return setTransaction();\r\n            default:\r\n                throw new Error();\r\n        }\r\n    }\r\n\r\n    private CommandSet setTransaction() throws SQLException{\r\n        SQLToken token = nextToken( MISSING_ISOLATION );\r\n        token = nextToken( MISSING_LEVEL );\r\n        token = nextToken( COMMANDS_TRANS_LEVEL );\r\n        CommandSet cmd = new CommandSet( con.log, SQLTokenizer.LEVEL );\r\n        switch(token.value){\r\n            case SQLTokenizer.READ:\r\n                token = nextToken( MISSING_COMM_UNCOMM );\r\n                switch(token.value){\r\n                    case SQLTokenizer.COMMITTED:\r\n                        cmd.isolationLevel = Connection.TRANSACTION_READ_COMMITTED;\r\n                        break;\r\n                    case SQLTokenizer.UNCOMMITTED:\r\n                        cmd.isolationLevel = Connection.TRANSACTION_READ_UNCOMMITTED;\r\n                        break;\r\n                    default:\r\n                        throw new Error();\r\n                }\r\n                return cmd;\r\n            case SQLTokenizer.REPEATABLE:\r\n                token = nextToken( MISSING_READ );\r\n                cmd.isolationLevel = Connection.TRANSACTION_REPEATABLE_READ;\r\n                return cmd;\r\n            case SQLTokenizer.SERIALIZABLE:\r\n                cmd.isolationLevel = Connection.TRANSACTION_SERIALIZABLE;\r\n                return cmd;\r\n            default:\r\n                throw new Error();\r\n        }\r\n\r\n\r\n    }\r\n\r\n    private Command execute() throws SQLException{\r\n        //TODO Execute\r\n        throw SmallSQLException.create(Language.UNSUPPORTED_OPERATION, \"Execute\");\r\n    }\r\n\r\n    /**\r\n     * Read a Expression list in parenthesis like of VALUES() or functions. \r\n     * The left parenthesis is already consumed.\r\n     * \r\n     * @param cmd is needed to add parameters \"?\" with addParameter() \r\n     * @see #expressionDefList\r\n     */ \r\n    private Expressions expressionParenthesisList(Command cmd) throws SQLException{\r\n\t\tExpressions list = new Expressions();\r\n\t\t{\r\n\t\t\tSQLToken token = nextToken();\r\n\t\t\tif(token != null && token.value == SQLTokenizer.PARENTHESIS_R){\r\n\t\t\t\t// empty list like functions without parameters\r\n\t\t\t\treturn list;\r\n\t\t\t}\r\n\t\t\tpreviousToken();\r\n\t\t}\r\n        while(true){\r\n            list.add( expression(cmd, 0) );\r\n            SQLToken token = nextToken(MISSING_COMMA_PARENTHESIS);\r\n            switch(token.value){\r\n                case SQLTokenizer.PARENTHESIS_R:\r\n                    return list;\r\n                case SQLTokenizer.COMMA:\r\n                    continue;\r\n                default:\r\n                    throw new Error();\r\n            }\r\n        }\r\n    }\r\n\r\n    \r\n    /**\r\n     * Read a list of expressions. The list is limit from specific SQL keywords like SELECT, GROUP BY, ORDER BY\r\n     */\r\n    private Expressions expressionTokenList(Command cmd, int listType) throws SQLException{\r\n\t\tExpressions list = new Expressions();\r\n        while(true){\r\n        \tExpression expr = expression(cmd, 0);\r\n            list.add( expr );\r\n            SQLToken token = nextToken();\r\n            \r\n\t\t\tif(listType == SQLTokenizer.ORDER && token != null){\r\n\t\t\t\tswitch(token.value){\r\n\t\t\t\t\tcase SQLTokenizer.DESC:\r\n\t\t\t\t\t\texpr.setAlias(SQLTokenizer.DESC_STR);\r\n\t\t\t\t\t\t//no break;\r\n\t\t\t\t\tcase SQLTokenizer.ASC:\r\n\t\t\t\t\t\ttoken = nextToken();\r\n\t\t\t\t}\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(token == null) {\r\n\t\t\t\tpreviousToken();\r\n\t\t\t\treturn list;\r\n\t\t\t}\r\n\r\n\t\t\tswitch(token.value){\r\n                case SQLTokenizer.COMMA:\r\n                    continue;\r\n                default:\r\n\t\t\t\t\tif(isKeyword(token) ){\r\n\t\t\t\t\t\tpreviousToken();\r\n\t\t\t\t\t\treturn list;\r\n\t\t\t\t\t}\r\n                    throw createSyntaxError( token, MISSING_TOKEN_LIST);\r\n            }\r\n        }\r\n    }\r\n    \r\n    \r\n    private void expressionDefList(Command cmd, Expressions expressions, Strings columns) throws SQLException{\r\n        SQLToken token = nextToken();\r\n        if(token.value != SQLTokenizer.PARENTHESIS_L) throw createSyntaxError(token, MISSING_PARENTHESIS_L );\r\n        Loop:\r\n        while(true){\r\n            int offset = token.offset + token.length;\r\n            token = nextToken();\r\n            if(token != null) offset = token.offset;\r\n            previousToken();  \r\n            \r\n            expressions.add( expression(cmd, 0) );\r\n            SQLToken last = lastToken();\r\n            int length = last.offset + last.length - offset;\r\n            columns.add( new String( sql, offset, length ) );\r\n\r\n            token = nextToken(MISSING_COMMA_PARENTHESIS);\r\n            switch(token.value){\r\n                case SQLTokenizer.PARENTHESIS_R:\r\n                    break Loop;\r\n                case SQLTokenizer.COMMA:\r\n                    continue;\r\n                default:\r\n                    throw new Error();\r\n            }\r\n        }\r\n    }\r\n    \r\n\r\n\t/**\r\n\t * Read a complex expression that can be build from multiple atomic expressions.\r\n     * @param cmd is needed to add parameters \"?\" with addParameter() \r\n\t * @param previousOperationLevel the level of the left operation.\r\n\t */\r\n    private Expression expression(Command cmd, int previousOperationLevel) throws SQLException{\r\n        SQLToken token = nextToken(MISSING_EXPRESSION);\r\n        Expression leftExpr;\r\n        switch(token.value){\r\n            case SQLTokenizer.NOT:\r\n            \tleftExpr =  new ExpressionArithmetic( expression( cmd, ExpressionArithmetic.NOT      / 10), ExpressionArithmetic.NOT);\r\n            \tbreak;\r\n            case SQLTokenizer.MINUS:\r\n            \tleftExpr =  new ExpressionArithmetic( expression( cmd, ExpressionArithmetic.NEGATIVE / 10), ExpressionArithmetic.NEGATIVE);\r\n            \tbreak;\r\n            case SQLTokenizer.TILDE:\r\n            \tleftExpr =  new ExpressionArithmetic( expression( cmd, ExpressionArithmetic.BIT_NOT  / 10), ExpressionArithmetic.BIT_NOT);\r\n            \tbreak;\r\n            case SQLTokenizer.PARENTHESIS_L:\r\n                leftExpr = expression( cmd, 0);\r\n                token = nextToken(MISSING_PARENTHESIS_R);\r\n                break;\r\n            default:\r\n                leftExpr = expressionSingle( cmd, token);\r\n        }\r\n        boolean isNot = false;\r\n        while((token = nextToken()) != null){\r\n            Expression rightExpr;\r\n            int operation = ExpressionArithmetic.getOperationFromToken(token.value);\r\n            int level = operation / 10;\r\n            if(previousOperationLevel >= level){\r\n                previousToken();\r\n                return leftExpr;\r\n            }\r\n            switch(token.value){\r\n                case SQLTokenizer.PLUS:\r\n                case SQLTokenizer.MINUS:\r\n                case SQLTokenizer.ASTERISK:\r\n                case SQLTokenizer.SLACH:\r\n                case SQLTokenizer.PERCENT:\r\n                case SQLTokenizer.EQUALS:\r\n                case SQLTokenizer.LESSER:\r\n                case SQLTokenizer.LESSER_EQU:\r\n                case SQLTokenizer.GREATER:\r\n                case SQLTokenizer.GREATER_EQU:\r\n                case SQLTokenizer.UNEQUALS:\r\n                case SQLTokenizer.LIKE:\r\n                case SQLTokenizer.OR:\r\n                case SQLTokenizer.AND:\r\n                case SQLTokenizer.BIT_AND:\r\n                case SQLTokenizer.BIT_OR:\r\n                case SQLTokenizer.BIT_XOR:\r\n                    rightExpr = expression( cmd, level );\r\n                    leftExpr = new ExpressionArithmetic( leftExpr, rightExpr, operation );\r\n                    break;\r\n                case SQLTokenizer.BETWEEN:\r\n                    rightExpr = expression( cmd, ExpressionArithmetic.AND );\r\n                    nextToken( MISSING_AND );\r\n                    Expression rightExpr2 = expression( cmd, level );\r\n                    leftExpr = new ExpressionArithmetic( leftExpr, rightExpr, rightExpr2, operation );\r\n                    break;\r\n                case SQLTokenizer.IN:\r\n            \t\tnextToken(MISSING_PARENTHESIS_L);\r\n                \ttoken = nextToken(MISSING_EXPRESSION);\r\n                \tif(token.value == SQLTokenizer.SELECT){\r\n                \t\tCommandSelect cmdSel = select();\r\n\t\t\t\t\t\tleftExpr = new ExpressionInSelect( con, leftExpr, cmdSel, operation );\r\n\t\t\t\t\t\tnextToken(MISSING_PARENTHESIS_R);\r\n                \t}else{\r\n                \t\tpreviousToken();\r\n                \t\tExpressions list = expressionParenthesisList( cmd );\r\n                \t\tleftExpr = new ExpressionArithmetic( leftExpr, list, operation );\r\n                \t}\r\n                    break;\r\n                case SQLTokenizer.IS:\r\n                \ttoken = nextToken(MISSING_NOT_NULL);\r\n                \tif(token.value == SQLTokenizer.NOT){\r\n                \t\tnextToken(MISSING_NULL);\r\n\t\t\t\t\t\toperation++;\r\n                \t}\r\n                \tleftExpr = new ExpressionArithmetic( leftExpr, operation );\r\n                \tbreak;\r\n                case SQLTokenizer.NOT:\r\n                \ttoken = nextToken(MISSING_BETWEEN_IN);\r\n                \tpreviousToken();\r\n                \tisNot = true;\r\n                \tcontinue;\r\n                default:\r\n                        previousToken();\r\n                        return leftExpr;\r\n            }\r\n            if(isNot){\r\n            \tisNot = false;\r\n\t\t\t\tleftExpr =  new ExpressionArithmetic( leftExpr, ExpressionArithmetic.NOT);\r\n            }\r\n        }\r\n        previousToken();\r\n        return leftExpr;\r\n    }\r\n\r\n    /**\r\n     * This method parse a single expression like 12, 'qwert', 0x3F or a column name.\r\n     * \r\n     * @param cmd is needed to add parameters \"?\" with addParameter() \r\n     */\r\n    private Expression expressionSingle(Command cmd, SQLToken token) throws SQLException{\r\n        boolean isMinus = false;\r\n        if(token != null){\r\n            switch(token.value){\r\n                case SQLTokenizer.NULL:\r\n                        return new ExpressionValue( null, SQLTokenizer.NULL );\r\n                case SQLTokenizer.STRING:\r\n                        return new ExpressionValue( token.getName(null), SQLTokenizer.VARCHAR );\r\n                case SQLTokenizer.IDENTIFIER:\r\n                        {\r\n                        String name = getIdentifier( token );\r\n                        ExpressionName expr =  new ExpressionName( name );\r\n                        SQLToken token2 = nextToken();\r\n                        if(token2 != null && token2.value == SQLTokenizer.POINT){\r\n                            expr.setNameAfterTableAlias( nextIdentifier() );\r\n                        }else{\r\n                            previousToken();\r\n                        }\r\n                        return expr;\r\n                        }\r\n                case SQLTokenizer.TRUE:\r\n                        return new ExpressionValue( Boolean.TRUE, SQLTokenizer.BOOLEAN );\r\n                case SQLTokenizer.FALSE:\r\n                        return new ExpressionValue( Boolean.FALSE, SQLTokenizer.BOOLEAN );\r\n                case SQLTokenizer.ESCAPE_L:{\r\n                        token = nextToken(COMMANDS_ESCAPE);\r\n                        SQLToken para = nextToken(MISSING_EXPRESSION);\r\n                        Expression expr;\r\n                        switch(token.value){\r\n                            case SQLTokenizer.D: // date escape sequence\r\n                            \texpr = new ExpressionValue( DateTime.valueOf(para.getName(sql), SQLTokenizer.DATE), SQLTokenizer.DATE );\r\n                            \tbreak;\r\n                            case SQLTokenizer.T: // time escape sequence\r\n                                expr = new ExpressionValue( DateTime.valueOf(para.getName(sql), SQLTokenizer.TIME), SQLTokenizer.TIME );\r\n                            \tbreak;\r\n                            case SQLTokenizer.TS: // timestamp escape sequence\r\n                                expr = new ExpressionValue( DateTime.valueOf(para.getName(sql), SQLTokenizer.TIMESTAMP), SQLTokenizer.TIMESTAMP );\r\n                            \tbreak;\r\n                            case SQLTokenizer.FN: // function escape sequence\r\n                            \tnextToken(MISSING_PARENTHESIS_L);\r\n                            \texpr = function(cmd, para, true);\r\n                            \tbreak;\r\n                            case SQLTokenizer.CALL: // call escape sequence\r\n                                throw new java.lang.UnsupportedOperationException(\"call escape sequence\");\r\n                            default: throw new Error();\r\n                        }\r\n                        token = nextToken( ESCAPE_MISSING_CLOSE );\r\n                        return expr;\r\n                }\r\n                case SQLTokenizer.QUESTION:\r\n                        ExpressionValue param = new ExpressionValue();\r\n                        cmd.addParameter( param );\r\n                        return param;\r\n                case SQLTokenizer.CASE:\r\n                \t\treturn caseExpr(cmd);\r\n                case SQLTokenizer.MINUS:\r\n                case SQLTokenizer.PLUS:\r\n                        // sign detection\r\n                        do{\r\n                            if(token.value == SQLTokenizer.MINUS)\r\n                                    isMinus = !isMinus;\r\n                            token = nextToken();\r\n                            if(token == null) throw createSyntaxError( token, MISSING_EXPRESSION );\r\n                        }while(token.value == SQLTokenizer.MINUS || token.value == SQLTokenizer.PLUS);\r\n                        // no Break\r\n                default:\r\n                        SQLToken token2 = nextToken();\r\n                        if(token2 != null && token2.value == SQLTokenizer.PARENTHESIS_L){\r\n                            if(isMinus)\r\n                                return new ExpressionArithmetic( function( cmd, token, false ),  ExpressionArithmetic.NEGATIVE );\r\n                            return function( cmd, token, false );\r\n                        }else{\r\n                            // constant expression or identifier\r\n                            char chr1 = sql[ token.offset ];\r\n\t\t\t\t\t\t\tif(chr1 == '$'){\r\n\t\t\t\t\t\t\t\tpreviousToken();\r\n\t                            String tok = new String(sql, token.offset+1, token.length-1);\r\n                                if(isMinus) tok = \"-\" + tok;\r\n\t\t\t\t\t\t\t\treturn new ExpressionValue( new Money(Double.parseDouble(tok)), SQLTokenizer.MONEY );\r\n\t\t\t\t\t\t\t}\r\n                            String tok = new String(sql, token.offset, token.length);\r\n                            if((chr1 >= '0' && '9' >= chr1) || chr1 == '.'){\r\n                                previousToken();\r\n                                // first character is a digit\r\n                                if(token.length>1 && (sql[ token.offset +1 ] | 0x20) == 'x'){\r\n                                    // binary data as hex\r\n                                    if(isMinus) {\r\n                \t\t\t\t\t\tthrow createSyntaxError(token, Language.STXADD_OPER_MINUS);\r\n                                    }\r\n                                    return new ExpressionValue( Utils.hex2bytes( sql, token.offset+2, token.length-2), SQLTokenizer.VARBINARY );\r\n                                }\r\n                                if(isMinus) tok = \"-\" + tok;\r\n                                if(Utils.indexOf( '.', sql, token.offset, token.length ) >= 0 ||\r\n                                   Utils.indexOf( 'e', sql, token.offset, token.length ) >= 0){\r\n                                    return new ExpressionValue( new Double(tok), SQLTokenizer.DOUBLE );\r\n                                }else{\r\n                                    try{\r\n                                        return new ExpressionValue( new Integer(tok), SQLTokenizer.INT );\r\n                                    }catch(NumberFormatException e){\r\n                                        return new ExpressionValue( new Long(tok), SQLTokenizer.BIGINT );\r\n                                    }\r\n                                }\r\n                            }else{\r\n                                // identifier\r\n                                checkValidIdentifier( tok, token );\r\n                                ExpressionName expr = new ExpressionName(tok);\r\n                                if(token2 != null && token2.value == SQLTokenizer.POINT){\r\n                                    expr.setNameAfterTableAlias( nextIdentifier() );\r\n                                }else{\r\n                                    previousToken();\r\n                                }\r\n                                if(isMinus)\r\n                                    return new ExpressionArithmetic( expr,  ExpressionArithmetic.NEGATIVE );\r\n                                return expr;\r\n                            }\r\n                        }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    \r\n    \r\n    ExpressionFunctionCase caseExpr(final Command cmd) throws SQLException{\r\n\t\tExpressionFunctionCase expr = new ExpressionFunctionCase();\r\n\t\tSQLToken token = nextToken(MISSING_EXPRESSION);\r\n\t\t\r\n\t\tExpression input = null;\r\n\t\tif(token.value != SQLTokenizer.WHEN){\r\n\t\t\t// simple CASE Syntax\r\n\t\t\tpreviousToken();\r\n\t\t\tinput = expression(cmd, 0);\r\n\t\t\ttoken = nextToken(MISSING_WHEN_ELSE_END);\r\n\t\t}\t\t\t\r\n\t\t\t\r\n\t\twhile(true){\r\n\t\t\tswitch(token.value){\r\n\t\t\t\tcase SQLTokenizer.WHEN:\t\t\t\t\r\n\t\t\t\t\tExpression condition = expression(cmd, 0);\r\n\t\t\t\t\tif(input != null){\r\n\t\t\t\t\t\t// simple CASE Syntax\r\n\t\t\t\t\t\tcondition = new ExpressionArithmetic( input, condition, ExpressionArithmetic.EQUALS);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tnextToken(MISSING_THEN);\r\n\t\t\t\t\tExpression result = expression(cmd, 0);\r\n\t\t\t\t\texpr.addCase(condition, result);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.ELSE:\r\n\t\t\t\t\texpr.setElseResult(expression(cmd, 0));\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.END:\r\n\t\t\t\t\texpr.setEnd();\r\n\t\t\t\t\treturn expr;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tthrow new Error();\r\n\t\t\t}\r\n\t\t\ttoken = nextToken(MISSING_WHEN_ELSE_END);\r\n\t\t}\r\n    }\r\n    \r\n\r\n    /**\r\n     * Parse any functions. The left parenthesis is already consumed from token list.\r\n     * @param token the SQLToken of the function\r\n     * @param isEscape If the function is a FN ESCAPE sequence\r\n     */ \r\n    private Expression function( Command cmd, SQLToken token, boolean isEscape ) throws SQLException{\r\n        Expression expr;\r\n        switch(token.value){\r\n        \tcase SQLTokenizer.CONVERT:{\r\n        \t\tColumn col;\r\n        \t\tExpression style = null;\r\n        \t\tif(isEscape){\r\n        \t\t\texpr = expression( cmd, 0);\r\n\t\t\t\t\tnextToken(MISSING_COMMA);\r\n\t\t\t\t\tcol = datatype(isEscape);\r\n        \t\t}else{\r\n\t        \t\tcol = datatype(isEscape);\r\n\t        \t\tnextToken(MISSING_COMMA);\r\n\t\t\t\t\texpr = expression( cmd, 0);\r\n\t\t\t\t\ttoken = nextToken(MISSING_COMMA_PARENTHESIS);\r\n\t\t\t\t\tif(token.value == SQLTokenizer.COMMA){\r\n\t\t\t\t\t\tstyle = expression( cmd, 0);\r\n\t\t\t\t\t}else\r\n\t\t\t\t\t\tpreviousToken();\r\n        \t\t}\r\n        \t\tnextToken(MISSING_PARENTHESIS_R);\r\n        \t\treturn new ExpressionFunctionConvert( col, expr, style );\r\n        \t}\r\n        \tcase SQLTokenizer.CAST:\r\n        \t\texpr = expression( cmd, 0);\r\n        \t\tnextToken(MISSING_AS);\r\n        \t\tColumn col = datatype(false);\r\n        \t\tnextToken(MISSING_PARENTHESIS_R);\r\n        \t\treturn new ExpressionFunctionConvert( col, expr, null );\r\n\t\t\tcase SQLTokenizer.TIMESTAMPDIFF:\r\n\t\t\t\ttoken = nextToken(MISSING_INTERVALS);\r\n\t\t\t\tnextToken(MISSING_COMMA);\r\n\t\t\t\texpr = expression( cmd, 0);\r\n\t\t\t\tnextToken(MISSING_COMMA);\r\n\t\t\t\texpr = new ExpressionFunctionTimestampDiff( token.value, expr, expression( cmd, 0));\r\n\t\t\t\tnextToken(MISSING_PARENTHESIS_R);\r\n\t\t\t\treturn expr;\r\n\t\t\tcase SQLTokenizer.TIMESTAMPADD:\r\n\t\t\t\ttoken = nextToken(MISSING_INTERVALS);\r\n\t\t\t\tnextToken(MISSING_COMMA);\r\n\t\t\t\texpr = expression( cmd, 0);\r\n\t\t\t\tnextToken(MISSING_COMMA);\r\n\t\t\t\texpr = new ExpressionFunctionTimestampAdd( token.value, expr, expression( cmd, 0));\r\n\t\t\t\tnextToken(MISSING_PARENTHESIS_R);\r\n\t\t\t\treturn expr;\r\n        }\r\n\t\tExpressions paramList = expressionParenthesisList(cmd);\r\n        int paramCount = paramList.size();\r\n        Expression[] params = paramList.toArray();\r\n        boolean invalidParamCount;\r\n        switch(token.value){\r\n        // numeric functions:\r\n            case SQLTokenizer.ABS:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionAbs();\r\n                break;\r\n            case SQLTokenizer.ACOS:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionACos();\r\n                break;\r\n            case SQLTokenizer.ASIN:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionASin();\r\n                break;\r\n            case SQLTokenizer.ATAN:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionATan();\r\n                break;\r\n            case SQLTokenizer.ATAN2:\r\n                invalidParamCount = (paramCount != 2);\r\n                expr = new ExpressionFunctionATan2();\r\n                break;\r\n            case SQLTokenizer.CEILING:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionCeiling();\r\n                break;\r\n            case SQLTokenizer.COS:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionCos();\r\n                break;\r\n            case SQLTokenizer.COT:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionCot();\r\n                break;\r\n            case SQLTokenizer.DEGREES:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionDegrees();\r\n                break;\r\n            case SQLTokenizer.EXP:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionExp();\r\n                break;\r\n            case SQLTokenizer.FLOOR:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionFloor();\r\n                break;\r\n            case SQLTokenizer.LOG:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionLog();\r\n                break;\r\n            case SQLTokenizer.LOG10:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionLog10();\r\n                break;\r\n            case SQLTokenizer.MOD:\r\n                invalidParamCount = (paramCount != 2);\r\n                expr = new ExpressionFunctionMod();\r\n                break;\r\n            case SQLTokenizer.PI:\r\n                invalidParamCount = (paramCount != 0);\r\n                expr = new ExpressionFunctionPI();\r\n                break;\r\n            case SQLTokenizer.POWER:\r\n                invalidParamCount = (paramCount != 2);\r\n                expr = new ExpressionFunctionPower();\r\n                break;\r\n            case SQLTokenizer.RADIANS:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionRadians();\r\n                break;\r\n            case SQLTokenizer.RAND:\r\n                invalidParamCount =  (paramCount != 0) && (paramCount != 1);\r\n                expr = new ExpressionFunctionRand();\r\n                break;\r\n            case SQLTokenizer.ROUND:\r\n                invalidParamCount =  (paramCount != 2);\r\n                expr = new ExpressionFunctionRound();\r\n                break;\r\n            case SQLTokenizer.SIN:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionSin();\r\n                break;\r\n            case SQLTokenizer.SIGN:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionSign();\r\n                break;\r\n            case SQLTokenizer.SQRT:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionSqrt();\r\n                break;\r\n            case SQLTokenizer.TAN:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionTan();\r\n                break;\r\n            case SQLTokenizer.TRUNCATE:\r\n                invalidParamCount =  (paramCount != 2);\r\n                expr = new ExpressionFunctionTruncate();\r\n                break;\r\n         \r\n        // string functions:\r\n\t\t\tcase SQLTokenizer.ASCII:\r\n\t\t\t\tinvalidParamCount = (paramCount != 1);\r\n\t\t\t\texpr = new ExpressionFunctionAscii();\r\n\t\t\t\tbreak;\r\n            case SQLTokenizer.BITLEN:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionBitLen();\r\n                break;\r\n            case SQLTokenizer.CHARLEN:\r\n            case SQLTokenizer.CHARACTLEN:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionCharLen();\r\n                break;\r\n\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\tinvalidParamCount = (paramCount != 1);\r\n\t\t\t\texpr = new ExpressionFunctionChar();\r\n\t\t\t\tbreak;\r\n            case SQLTokenizer.CONCAT:\r\n                if(paramCount != 2){\r\n                    invalidParamCount = true;\r\n                    expr = null;//only for compiler\r\n                    break;\r\n                }\r\n                invalidParamCount = false;\r\n                expr = new ExpressionArithmetic( params[0], params[1], ExpressionArithmetic.ADD);\r\n                break;\r\n            case SQLTokenizer.DIFFERENCE:\r\n                invalidParamCount = (paramCount != 2);\r\n                expr = new ExpressionFunctionDifference();\r\n                break;\r\n            case SQLTokenizer.INSERT:\r\n                invalidParamCount = (paramCount != 4);\r\n                expr = new ExpressionFunctionInsert();\r\n                break;\r\n            case SQLTokenizer.LCASE:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionLCase();\r\n                break;\r\n            case SQLTokenizer.LEFT:\r\n                invalidParamCount = (paramCount != 2);\r\n                expr = new ExpressionFunctionLeft();\r\n                break;\r\n\t\t\tcase SQLTokenizer.LENGTH:\r\n\t\t\t\tinvalidParamCount = (paramCount != 1);\r\n\t\t\t\texpr = new ExpressionFunctionLength();\r\n\t\t\t\tbreak;\r\n            case SQLTokenizer.LOCATE:\r\n            \tinvalidParamCount = (paramCount != 2) && (paramCount != 3);\r\n            \texpr = new ExpressionFunctionLocate();\r\n            \tbreak;\r\n            case SQLTokenizer.LTRIM:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionLTrim();\r\n                break;\r\n            case SQLTokenizer.OCTETLEN:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionOctetLen();\r\n                break;\r\n            case SQLTokenizer.REPEAT:\r\n                invalidParamCount = (paramCount != 2);\r\n                expr = new ExpressionFunctionRepeat();\r\n                break;\r\n            case SQLTokenizer.REPLACE:\r\n                invalidParamCount = (paramCount != 3);\r\n                expr = new ExpressionFunctionReplace();\r\n                break;\r\n\t\t\tcase SQLTokenizer.RIGHT:\r\n\t\t\t\tinvalidParamCount = (paramCount != 2);\r\n\t\t\t\texpr = new ExpressionFunctionRight();\r\n\t\t\t\tbreak;\r\n            case SQLTokenizer.RTRIM:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionRTrim();\r\n                break;\r\n            case SQLTokenizer.SPACE:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionSpace();\r\n                break;\r\n            case SQLTokenizer.SOUNDEX:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionSoundex();\r\n                break;\r\n\t\t\tcase SQLTokenizer.SUBSTRING:\r\n\t\t\t\tinvalidParamCount = (paramCount != 3);\r\n\t\t\t\texpr = new ExpressionFunctionSubstring();\r\n\t\t\t\tbreak;\r\n            case SQLTokenizer.UCASE:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionUCase();\r\n                break;\r\n                \r\n        // date time functions\r\n            case SQLTokenizer.CURDATE:\r\n            case SQLTokenizer.CURRENTDATE:\r\n            \tinvalidParamCount = (paramCount != 0);\r\n\t\t\t\texpr = new ExpressionValue( new DateTime(DateTime.now(), SQLTokenizer.DATE), SQLTokenizer.DATE);\r\n\t\t\t\tbreak;\r\n            case SQLTokenizer.CURTIME:\r\n            \tinvalidParamCount = (paramCount != 0);\r\n\t\t\t\texpr = new ExpressionValue( new DateTime(DateTime.now(), SQLTokenizer.TIME), SQLTokenizer.TIME);\r\n\t\t\t\tbreak;\r\n            case SQLTokenizer.DAYOFMONTH:\r\n            \tinvalidParamCount = (paramCount != 1);\r\n\t\t\t\texpr = new ExpressionFunctionDayOfMonth();\r\n\t\t\t\tbreak;\r\n            case SQLTokenizer.DAYOFWEEK:\r\n            \tinvalidParamCount = (paramCount != 1);\r\n\t\t\t\texpr = new ExpressionFunctionDayOfWeek();\r\n\t\t\t\tbreak;\r\n            case SQLTokenizer.DAYOFYEAR:\r\n            \tinvalidParamCount = (paramCount != 1);\r\n\t\t\t\texpr = new ExpressionFunctionDayOfYear();\r\n\t\t\t\tbreak;\r\n            case SQLTokenizer.HOUR:\r\n            \tinvalidParamCount = (paramCount != 1);\r\n\t\t\t\texpr = new ExpressionFunctionHour();\r\n\t\t\t\tbreak;\r\n            case SQLTokenizer.MINUTE:\r\n            \tinvalidParamCount = (paramCount != 1);\r\n\t\t\t\texpr = new ExpressionFunctionMinute();\r\n\t\t\t\tbreak;\r\n            case SQLTokenizer.MONTH:\r\n            \tinvalidParamCount = (paramCount != 1);\r\n\t\t\t\texpr = new ExpressionFunctionMonth();\r\n\t\t\t\tbreak;\r\n            case SQLTokenizer.NOW:\r\n            \tinvalidParamCount = (paramCount != 0);\r\n\t\t\t\texpr = new ExpressionValue( new DateTime(DateTime.now(), SQLTokenizer.TIMESTAMP), SQLTokenizer.TIMESTAMP);\r\n\t\t\t\tbreak;\r\n            case SQLTokenizer.YEAR:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionYear();\r\n                break;\r\n            \t\r\n        // system functions:\r\n            case SQLTokenizer.IIF:\r\n        \t\tinvalidParamCount = (paramCount != 3);\r\n            \texpr = new ExpressionFunctionIIF();\r\n        \t\tbreak;\r\n        \tcase SQLTokenizer.SWITCH:\r\n        \t\tinvalidParamCount = (paramCount % 2 != 0);\r\n        \t\tExpressionFunctionCase exprCase = new ExpressionFunctionCase();\r\n        \t\tfor(int i=0; i < paramCount-1; i +=2)\r\n        \t\t\texprCase.addCase(params[i], params[i+1] );\r\n        \t\texprCase.setEnd();\r\n        \t\texpr = exprCase;\r\n        \t\tbreak;\r\n        \tcase SQLTokenizer.IFNULL:\r\n        \t\tswitch(paramCount){\r\n        \t\t\tcase 1:\r\n        \t\t\t\treturn new ExpressionArithmetic( params[0], ExpressionArithmetic.ISNULL );\r\n        \t\t\tcase 2:        \t\t\t\t\r\n        \t\t\t\tinvalidParamCount = false;\r\n        \t\t\t\texpr = new ExpressionFunctionIIF();\r\n        \t\t\t\tExpression[] newParams = new Expression[3];\r\n        \t\t\t\tnewParams[0] = new ExpressionArithmetic( params[0], ExpressionArithmetic.ISNULL );\r\n        \t\t\t\tnewParams[1] = params[1];\r\n        \t\t\t\tnewParams[2] = params[0];        \t\t\t\t\r\n        \t\t\t\tparams = newParams;\r\n        \t\t\t\tparamCount = 3;\r\n        \t\t\t\tbreak;\r\n        \t\t\tdefault:\r\n        \t\t\t\tinvalidParamCount = true;\r\n        \t\t\t\texpr = null; // only for Compiler\r\n        \t\t}\r\n        \t\tbreak;\r\n                    \r\n        // now come the aggregate functions\r\n            case SQLTokenizer.COUNT:\r\n\t\t\t\t\tinvalidParamCount = (paramCount != 1);\r\n\t\t\t\t\tif(params[0].getType() == Expression.NAME){\r\n\t\t\t\t\t\t//detect special case COUNT(*)\r\n\t\t\t\t\t\tExpressionName param = (ExpressionName)params[0];\r\n\t\t\t\t\t\tif(\"*\".equals(param.getName()) && param.getTableAlias() == null){\r\n                            //set any not NULL value as parameter\r\n\t\t\t\t\t\t\tparams[0] = new ExpressionValue(\"*\", SQLTokenizer.VARCHAR);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\texpr = new ExpressionName( Expression.COUNT );\r\n\t\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.SUM:\r\n\t\t\t\t\tinvalidParamCount = (paramCount != 1);\r\n\t\t\t\t\texpr = new ExpressionName( Expression.SUM );\r\n\t\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.MAX:\r\n\t\t\t\t\tinvalidParamCount = (paramCount != 1);\r\n\t\t\t\t\texpr = new ExpressionName( Expression.MAX );\r\n\t\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.MIN:\r\n\t\t\t\t\tinvalidParamCount = (paramCount != 1);\r\n\t\t\t\t\texpr = new ExpressionName( Expression.MIN );\r\n\t\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.FIRST:\r\n\t\t\t\t\tinvalidParamCount = (paramCount != 1);\r\n\t\t\t\t\texpr = new ExpressionName( Expression.FIRST );\r\n\t\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.LAST:\r\n\t\t\t\t\tinvalidParamCount = (paramCount != 1);\r\n\t\t\t\t\texpr = new ExpressionName( Expression.LAST );\r\n\t\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.AVG:\r\n\t\t\t\t\tif(paramCount != 1){\r\n                        invalidParamCount = true;\r\n                        expr = null;//Only for the compiler\r\n                        break;\r\n                    }\r\n\t\t\t\t\texpr = new ExpressionName( Expression.SUM );\r\n\t\t\t\t\texpr.setParams( params );\r\n\t\t\t\t\tExpression expr2 = new ExpressionName( Expression.COUNT );\r\n\t\t\t\t\texpr2.setParams( params );\r\n\t\t\t\t\texpr = new ExpressionArithmetic( expr, expr2, ExpressionArithmetic.DIV );\r\n\t\t\t\t\treturn expr;\r\n            default:\r\n            \tthrow createSyntaxError(token, Language.STXADD_FUNC_UNKNOWN);\r\n        }\r\n        if(invalidParamCount) {\r\n        \tthrow createSyntaxError(token, Language.STXADD_PARAM_INVALID_COUNT);\r\n        }\r\n        expr.setParams( params );\r\n        return expr;\r\n    }\r\n\r\n    /**\r\n     * read a table or view name in a FROM clause. If the keyword AS exists then read it also the alias\r\n     */\r\n    private RowSource tableSource( Command cmd, DataSources tables) throws SQLException{\r\n        SQLToken token = nextToken(MISSING_EXPRESSION);\r\n        switch(token.value){\r\n            case SQLTokenizer.PARENTHESIS_L: // (\r\n                    return rowSource( cmd, tables, SQLTokenizer.PARENTHESIS_R );\r\n            case SQLTokenizer.ESCAPE_L: // {\r\n                    token = nextToken(MISSING_OJ);\r\n                    return rowSource( cmd, tables, SQLTokenizer.ESCAPE_R );\r\n            case SQLTokenizer.SELECT:\r\n            \t\t// inner select\r\n            \t\tViewResult viewResult = new ViewResult( con, select() );\r\n            \t\ttables.add(viewResult);\r\n            \t\treturn viewResult;\r\n        }\r\n        String catalog = null;\r\n        String name = getIdentifier( token );\r\n\t\ttoken = nextToken();\r\n\t\t//check if the table name include a database name\r\n\t\tif(token != null && token.value == SQLTokenizer.POINT){\r\n\t\t\tcatalog = name;\r\n\t\t\tname = nextIdentifier();\r\n\t\t\ttoken = nextToken();\r\n\t\t}\r\n\t\t//TableResult table = new TableResult();\r\n\t\t//table.setName( catalog, name );\r\n\t\tTableView tableView = Database.getTableView( con, catalog, name);\r\n\t\tTableViewResult table = TableViewResult.createResult(tableView);\r\n        tables.add( table );\r\n\r\n        if(token != null && token.value == SQLTokenizer.AS){\r\n            // skip AS keyword, if exists\r\n            token = nextToken(MISSING_EXPRESSION);\r\n            table.setAlias( token.getName( sql ) );\r\n        }else{\r\n            previousToken();\r\n        }\r\n        return table;\r\n    }\r\n    \r\n\r\n    /**\r\n     * read a join in a from clause.\r\n     */\r\n    private Join join(Command cmd, DataSources tables, RowSource left, int type) throws SQLException{\r\n        RowSource right = rowSource(cmd, tables, 0);\r\n        SQLToken token = nextToken();\r\n\r\n        while(true){\r\n            if(token == null) {\r\n            \tthrow createSyntaxError(token, Language.STXADD_JOIN_INVALID);\r\n            }\r\n\r\n            switch(token.value){\r\n            \tcase SQLTokenizer.ON:\r\n\t            \tif(type == Join.RIGHT_JOIN)\r\n\t\t\t\t\t\treturn new Join( Join.LEFT_JOIN, right, left, expression( cmd, 0 ) );\r\n\t                return new Join( type, left, right, expression( cmd, 0 ) );\r\n\t            default:\r\n\t                if(!right.hasAlias()){\r\n\t                    right.setAlias( token.getName( sql ) );\r\n\t                    token = nextToken();\r\n\t                    continue;\r\n\t                }\r\n\t                throw createSyntaxError( token, MISSING_ON );\t                \r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * returns a row source. A row source is a Table, Join, View or a row function.\r\n     *\r\n     */\r\n    private RowSource rowSource(Command cmd, DataSources tables, int parenthesis) throws SQLException{\r\n        RowSource fromSource = null;\r\n        fromSource = tableSource(cmd, tables);\r\n\r\n        while(true){\r\n            SQLToken token = nextToken();\r\n            if(token == null) return fromSource;\r\n            switch(token.value){\r\n                case SQLTokenizer.ON:\r\n                    previousToken();\r\n                    return fromSource;\r\n                case SQLTokenizer.CROSS:\r\n                    nextToken(MISSING_JOIN);\r\n                    //no break\r\n                case SQLTokenizer.COMMA:\r\n                    fromSource = new Join( Join.CROSS_JOIN, fromSource, rowSource(cmd, tables, 0), null);\r\n                    break;\r\n                case SQLTokenizer.INNER:\r\n                    nextToken(MISSING_JOIN);\r\n                    //no break;\r\n                case SQLTokenizer.JOIN:\r\n                    fromSource = join( cmd, tables, fromSource, Join.INNER_JOIN );\r\n                    break;\r\n                case SQLTokenizer.LEFT:\r\n                    token = nextToken(MISSING_OUTER_JOIN);\r\n                \tif(token.value == SQLTokenizer.OUTER)\r\n                \t\ttoken = nextToken(MISSING_JOIN);\r\n                    fromSource = join( cmd, tables, fromSource, Join.LEFT_JOIN );\r\n                    break;\r\n                case SQLTokenizer.RIGHT:\r\n                \ttoken = nextToken(MISSING_OUTER_JOIN);\r\n                \tif(token.value == SQLTokenizer.OUTER)\r\n                \t\ttoken = nextToken(MISSING_JOIN);\r\n\t\t\t\t\tfromSource = join( cmd, tables, fromSource, Join.RIGHT_JOIN );\r\n\t\t\t\t\tbreak;                \t\r\n\t\t\t\tcase SQLTokenizer.FULL:\r\n\t\t\t\t\ttoken = nextToken(MISSING_OUTER_JOIN);\r\n\t\t\t\t\tif(token.value == SQLTokenizer.OUTER)\r\n\t\t\t\t\t\ttoken = nextToken(MISSING_JOIN);\r\n\t\t\t\t\tfromSource = join( cmd, tables, fromSource, Join.FULL_JOIN );\r\n\t\t\t\t\tbreak;                \t\r\n                case SQLTokenizer.PARENTHESIS_R:\r\n                case SQLTokenizer.ESCAPE_R:\r\n                    if(parenthesis == token.value) return fromSource;\r\n                    if(parenthesis == 0){\r\n                    \tpreviousToken();\r\n\t\t\t\t\t\treturn fromSource;\r\n                    }\r\n                    throw createSyntaxError( token, Language.STXADD_FROM_PAR_CLOSE );\r\n                default:\r\n                \tif(isKeyword(token)){\r\n\t\t\t\t\t\tpreviousToken();\r\n\t\t\t\t\t\treturn fromSource;\r\n                \t}\r\n                    if(!fromSource.hasAlias()){\r\n                        fromSource.setAlias( token.getName( sql ) );\r\n                        break;\r\n                    }\r\n                    throw createSyntaxError( token, new int[]{SQLTokenizer.COMMA, SQLTokenizer.GROUP, SQLTokenizer.ORDER, SQLTokenizer.HAVING} );\r\n            }\r\n        }\r\n    }\r\n\r\n    private void from(CommandSelect cmd) throws SQLException{\r\n\t\tDataSources tables = new DataSources();\r\n        cmd.setTables(tables);\r\n        cmd.setSource( rowSource( cmd, tables, 0 ) );\r\n\r\n\t\tSQLToken token;\r\n        while(null != (token = nextToken())){\r\n            switch(token.value){\r\n                case SQLTokenizer.WHERE:\r\n                    where( cmd );\r\n                    break;\r\n                case SQLTokenizer.GROUP:\r\n                    group( cmd );\r\n                    break;\r\n                case SQLTokenizer.HAVING:\r\n                    having( cmd );\r\n                    break;\r\n                default:\r\n                \tpreviousToken();\r\n                    return;\r\n            }\r\n        }\r\n    }\r\n\r\n    private void order(CommandSelect cmd) throws SQLException{\r\n        nextToken(MISSING_BY);\r\n        cmd.setOrder(expressionTokenList(cmd, SQLTokenizer.ORDER));\r\n    }\r\n    \r\n    private void limit(CommandSelect selCmd) throws SQLException{\r\n        SQLToken token = nextToken(MISSING_EXPRESSION);\r\n        try{\r\n            int maxRows = Integer.parseInt(token.getName(sql));\r\n            selCmd.setMaxRows(maxRows);\r\n        }catch(NumberFormatException e){\r\n            throw createSyntaxError(token, Language.STXADD_NOT_NUMBER, token.getName(sql));\r\n        }\r\n    }\r\n\r\n    private void group(CommandSelect cmd) throws SQLException{\r\n        nextToken(MISSING_BY);\r\n        cmd.setGroup( expressionTokenList(cmd, SQLTokenizer.GROUP) );\r\n    }\r\n\r\n    private void where(CommandSelect cmd) throws SQLException{\r\n        cmd.setWhere( expression(cmd, 0) );\r\n    }\r\n\r\n    private void having(CommandSelect cmd) throws SQLException{\r\n        cmd.setHaving( expression(cmd, 0) );\r\n    }\r\n\r\n\r\n    private static final int[] COMMANDS = {SQLTokenizer.SELECT, SQLTokenizer.DELETE, SQLTokenizer.INSERT, SQLTokenizer.UPDATE, SQLTokenizer.CREATE, SQLTokenizer.DROP, SQLTokenizer.ALTER, SQLTokenizer.SET, SQLTokenizer.USE, SQLTokenizer.EXECUTE, SQLTokenizer.TRUNCATE};\r\n    private static final int[] COMMANDS_ESCAPE = {SQLTokenizer.D, SQLTokenizer.T, SQLTokenizer.TS, SQLTokenizer.FN, SQLTokenizer.CALL};\r\n    private static final int[] COMMANDS_ALTER = {SQLTokenizer.DATABASE, SQLTokenizer.TABLE, SQLTokenizer.VIEW,  SQLTokenizer.PROCEDURE, };\r\n    private static final int[] COMMANDS_CREATE = {SQLTokenizer.DATABASE, SQLTokenizer.TABLE, SQLTokenizer.VIEW, SQLTokenizer.INDEX, SQLTokenizer.PROCEDURE, SQLTokenizer.UNIQUE, SQLTokenizer.CLUSTERED, SQLTokenizer.NONCLUSTERED};\r\n    private static final int[] COMMANDS_DROP = {SQLTokenizer.DATABASE, SQLTokenizer.TABLE, SQLTokenizer.VIEW, SQLTokenizer.INDEX, SQLTokenizer.PROCEDURE};\r\n    private static final int[] COMMANDS_SET = {SQLTokenizer.TRANSACTION};\r\n    private static final int[] COMMANDS_CREATE_UNIQUE = {SQLTokenizer.INDEX, SQLTokenizer.CLUSTERED, SQLTokenizer.NONCLUSTERED};\r\n\tprivate static final int[] MISSING_TABLE = {SQLTokenizer.TABLE};\r\n    private static final int[] ESCAPE_MISSING_CLOSE = {SQLTokenizer.ESCAPE_R};\r\n    private static final int[] MISSING_EXPRESSION = {SQLTokenizer.VALUE};\r\n    private static final int[] MISSING_IDENTIFIER = {SQLTokenizer.IDENTIFIER};\r\n    private static final int[] MISSING_BY = {SQLTokenizer.BY};\r\n    private static final int[] MISSING_PARENTHESIS_L = {SQLTokenizer.PARENTHESIS_L};\r\n    private static final int[] MISSING_PARENTHESIS_R = {SQLTokenizer.PARENTHESIS_R};\r\n    private static final int[] MISSING_DATATYPE  = {SQLTokenizer.BIT, SQLTokenizer.BOOLEAN, SQLTokenizer.BINARY, SQLTokenizer.VARBINARY, SQLTokenizer.RAW, SQLTokenizer.LONGVARBINARY, SQLTokenizer.BLOB, SQLTokenizer.TINYINT, SQLTokenizer.SMALLINT, SQLTokenizer.INT, SQLTokenizer.COUNTER, SQLTokenizer. BIGINT, SQLTokenizer.SMALLMONEY, SQLTokenizer.MONEY, SQLTokenizer.DECIMAL, SQLTokenizer.NUMERIC, SQLTokenizer.REAL, SQLTokenizer.FLOAT, SQLTokenizer.DOUBLE, SQLTokenizer.DATE, SQLTokenizer.TIME, SQLTokenizer.TIMESTAMP, SQLTokenizer.SMALLDATETIME, SQLTokenizer.CHAR, SQLTokenizer.NCHAR, SQLTokenizer.VARCHAR, SQLTokenizer.NVARCHAR, SQLTokenizer.LONG, SQLTokenizer.LONGNVARCHAR, SQLTokenizer.LONGVARCHAR, SQLTokenizer.CLOB, SQLTokenizer.NCLOB, SQLTokenizer.UNIQUEIDENTIFIER, SQLTokenizer.JAVA_OBJECT, SQLTokenizer.SYSNAME};\r\n\tprivate static final int[] MISSING_SQL_DATATYPE = { SQLTokenizer.SQL_BIGINT , SQLTokenizer.SQL_BINARY , SQLTokenizer.SQL_BIT , SQLTokenizer.SQL_CHAR , SQLTokenizer.SQL_DATE , SQLTokenizer.SQL_DECIMAL , SQLTokenizer.SQL_DOUBLE , SQLTokenizer.SQL_FLOAT , SQLTokenizer.SQL_INTEGER , SQLTokenizer.SQL_LONGVARBINARY , SQLTokenizer.SQL_LONGVARCHAR , SQLTokenizer.SQL_REAL , SQLTokenizer.SQL_SMALLINT , SQLTokenizer.SQL_TIME , SQLTokenizer.SQL_TIMESTAMP , SQLTokenizer.SQL_TINYINT , SQLTokenizer.SQL_VARBINARY , SQLTokenizer.SQL_VARCHAR };\r\n    private static final int[] MISSING_INTO = {SQLTokenizer.INTO};\r\n\tprivate static final int[] MISSING_BETWEEN_IN = {SQLTokenizer.BETWEEN, SQLTokenizer.IN};\r\n\tprivate static final int[] MISSING_NOT_NULL = {SQLTokenizer.NOT, SQLTokenizer.NULL};\r\n    private static final int[] MISSING_NULL = {SQLTokenizer.NULL};\r\n\tprivate static final int[] MISSING_COMMA = {SQLTokenizer.COMMA};\r\n    private static final int[] MISSING_COMMA_PARENTHESIS = {SQLTokenizer.COMMA, SQLTokenizer.PARENTHESIS_R};\r\n    private static final int[] MISSING_PARENTHESIS_VALUES_SELECT = {SQLTokenizer.PARENTHESIS_L, SQLTokenizer.VALUES, SQLTokenizer.SELECT};\r\n    private static final int[] MISSING_TOKEN_LIST = {SQLTokenizer.COMMA, SQLTokenizer.FROM, SQLTokenizer.GROUP, SQLTokenizer.HAVING, SQLTokenizer.ORDER};\r\n\tprivate static final int[] MISSING_FROM = {SQLTokenizer.FROM};\r\n\tprivate static final int[] MISSING_SET = {SQLTokenizer.SET};\r\n\tprivate static final int[] MISSING_EQUALS = {SQLTokenizer.EQUALS};\r\n\tprivate static final int[] MISSING_WHERE = {SQLTokenizer.WHERE};\r\n\tprivate static final int[] MISSING_WHERE_COMMA = {SQLTokenizer.WHERE, SQLTokenizer.COMMA};\r\n    private static final int[] MISSING_ISOLATION = {SQLTokenizer.ISOLATION};\r\n    private static final int[] MISSING_LEVEL = {SQLTokenizer.LEVEL};\r\n    private static final int[] COMMANDS_TRANS_LEVEL = {SQLTokenizer.READ, SQLTokenizer.REPEATABLE, SQLTokenizer.SERIALIZABLE};\r\n    private static final int[] MISSING_READ = {SQLTokenizer.READ};\r\n    private static final int[] MISSING_COMM_UNCOMM = {SQLTokenizer.COMMITTED, SQLTokenizer.UNCOMMITTED};\r\n    private static final int[] MISSING_OPTIONS_DATATYPE = { SQLTokenizer.DEFAULT, SQLTokenizer.IDENTITY, SQLTokenizer.NOT, SQLTokenizer.NULL, SQLTokenizer.PRIMARY, SQLTokenizer.UNIQUE, SQLTokenizer.COMMA, SQLTokenizer.PARENTHESIS_R};\r\n    private static final int[] MISSING_NUMBERVALUE = {SQLTokenizer.NUMBERVALUE};\r\n    private static final int[] MISSING_AND = {SQLTokenizer.AND};\r\n    private static final int[] MISSING_JOIN = {SQLTokenizer.JOIN};\r\n    private static final int[] MISSING_OUTER_JOIN = {SQLTokenizer.OUTER, SQLTokenizer.JOIN};\r\n    private static final int[] MISSING_OJ = {SQLTokenizer.OJ};\r\n    private static final int[] MISSING_ON = {SQLTokenizer.ON};\r\n\tprivate static final int[] MISSING_KEYTYPE = {SQLTokenizer.PRIMARY, SQLTokenizer.UNIQUE, SQLTokenizer.FOREIGN};\r\n\tprivate static final int[] MISSING_KEY = {SQLTokenizer.KEY};\r\n    private static final int[] MISSING_REFERENCES = {SQLTokenizer.REFERENCES};\r\n\tprivate static final int[] MISSING_AS = {SQLTokenizer.AS};\r\n\tprivate static final int[] MISSING_SELECT = {SQLTokenizer.SELECT};\r\n\tprivate static final int[] MISSING_INTERVALS = {SQLTokenizer.SQL_TSI_FRAC_SECOND, SQLTokenizer.SQL_TSI_SECOND, SQLTokenizer.SQL_TSI_MINUTE, SQLTokenizer.SQL_TSI_HOUR, SQLTokenizer.SQL_TSI_DAY, SQLTokenizer.SQL_TSI_WEEK, SQLTokenizer.SQL_TSI_MONTH, SQLTokenizer.SQL_TSI_QUARTER, SQLTokenizer.SQL_TSI_YEAR, SQLTokenizer.MILLISECOND, SQLTokenizer.SECOND, SQLTokenizer.MINUTE, SQLTokenizer.HOUR, SQLTokenizer.DAY, SQLTokenizer.WEEK, SQLTokenizer.MONTH, SQLTokenizer.QUARTER, SQLTokenizer.YEAR, SQLTokenizer.D};\r\n\tprivate static final int[] MISSING_ALL = {SQLTokenizer.ALL};\r\n\tprivate static final int[] MISSING_THEN = {SQLTokenizer.THEN};\r\n\tprivate static final int[] MISSING_WHEN_ELSE_END = {SQLTokenizer.WHEN, SQLTokenizer.ELSE, SQLTokenizer.END};\r\n\tprivate static final int[] MISSING_ADD_ALTER_DROP = {SQLTokenizer.ADD, SQLTokenizer.ALTER, SQLTokenizer.DROP};\r\n\t\r\n\t\r\n}"},{"path":"/src/smallsql/database/ExpressionFunctionConvert.java","source":"/* =============================================================\r\n * SmallSQL : a free Java DBMS library for the Java(tm) platform\r\n * =============================================================\r\n *\r\n * (C) Copyright 2004-2007, by Volker Berlin.\r\n *\r\n * Project Info:  http://www.smallsql.de/\r\n *\r\n * This library is free software; you can redistribute it and/or modify it \r\n * under the terms of the GNU Lesser General Public License as published by \r\n * the Free Software Foundation; either version 2.1 of the License, or \r\n * (at your option) any later version.\r\n *\r\n * This library is distributed in the hope that it will be useful, but \r\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \r\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public \r\n * License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, \r\n * USA.  \r\n *\r\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc. \r\n * in the United States and other countries.]\r\n *\r\n * ---------------\r\n * ExpressionFunctionConvert.java\r\n * ---------------\r\n * Author: Volker Berlin\r\n * \r\n * Created on 29.04.2004\r\n */\r\npackage smallsql.database;\r\n\r\nimport java.util.Arrays;\r\nimport smallsql.database.language.Language;\r\n\r\n/**\r\n * @author Volker Berlin\r\n */\r\npublic class ExpressionFunctionConvert extends ExpressionFunction {\r\n\r\n\tfinal private Column datatype;\r\n\t\r\n\tpublic ExpressionFunctionConvert(Column datatype, Expression value, Expression style) {\r\n\t\tsuper();\r\n\t\tthis.datatype = datatype;\r\n\t\tExpression[] params = (style == null) ? new Expression[]{value} : new Expression[]{value, style};\r\n\t\tsetParams( params );\r\n\t}\r\n\t\r\n\r\n\tint getFunction() {\r\n\t\treturn SQLTokenizer.CONVERT;\r\n\t}\r\n\t\r\n\r\n\tboolean isNull() throws Exception {\r\n\t\treturn param1.isNull();\r\n\t}\r\n\r\n\r\n\tboolean getBoolean() throws Exception {\r\n\t\treturn ExpressionValue.getBoolean( getObject(), getDataType() );\r\n\t}\r\n\r\n\t\r\n\tint getInt() throws Exception {\r\n\t\treturn ExpressionValue.getInt( getObject(), getDataType() );\r\n\t}\r\n\r\n\r\n\tlong getLong() throws Exception {\r\n\t\treturn ExpressionValue.getLong( getObject(), getDataType() );\r\n\t}\r\n\r\n\r\n\tfloat getFloat() throws Exception {\r\n\t\treturn ExpressionValue.getFloat( getObject(), getDataType() );\r\n\t}\r\n\r\n\r\n\tdouble getDouble() throws Exception {\r\n\t\treturn ExpressionValue.getDouble( getObject(), getDataType() );\r\n\t}\r\n\r\n\r\n\tlong getMoney() throws Exception {\r\n\t\treturn ExpressionValue.getMoney(getObject(), getDataType());\r\n\t}\r\n\t\r\n\r\n\tMutableNumeric getNumeric() throws Exception {\r\n\t\treturn ExpressionValue.getNumeric(getObject(), getDataType());\r\n\t}\r\n\r\n\r\n\tString getString() throws Exception {\r\n\t\tObject obj = getObject();\r\n\t\tif(obj == null) return null;\r\n\t\tswitch(datatype.getDataType()){\r\n\t\t\tcase SQLTokenizer.BIT:\r\n\t\t\t\treturn ((Boolean)obj).booleanValue() ? \"1\" : \"0\";\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n            case SQLTokenizer.LONGVARBINARY:\r\n                    return new String( (byte[])obj );\r\n\t\t}\r\n\t\treturn obj.toString();\r\n\t}\r\n\r\n\t\r\n\tObject getObject() throws Exception {\r\n\t\tif(param1.isNull()) return null;\r\n\t\tfinal int dataType = getDataType();\r\n\t\tswitch(dataType){\r\n\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\treturn convertToString();\r\n\t\t\tcase SQLTokenizer.VARCHAR:{\r\n\t\t\t\tString str = convertToString();\r\n\t\t\t\tint length = datatype.getDisplaySize();\r\n\t\t\t\tif(length > str.length())\r\n\t\t\t\t\treturn str;\r\n\t\t\t\treturn str.substring(0,length);\r\n\t\t\t}\r\n\t\t\tcase SQLTokenizer.CHAR:{\r\n\t\t\t\tString str = convertToString();\r\n\t\t\t\tint length = datatype.getDisplaySize();\r\n\t\t\t\tif(length > str.length()){\r\n\t\t\t\t\tchar[] buffer = new char[length-str.length()];\r\n\t\t\t\t\tArrays.fill(buffer, ' ');\r\n\t\t\t\t\treturn str + new String(buffer);\r\n\t\t\t\t}\r\n\t\t\t\treturn str.substring(0,length);\r\n\t\t\t}\r\n\t\t\tcase SQLTokenizer.LONGVARBINARY:\r\n\t\t\t\treturn param1.getBytes();\r\n\t\t\tcase SQLTokenizer.VARBINARY:{\r\n\t\t\t\tbyte[] bytes = param1.getBytes();\r\n\t\t\t\tint length = datatype.getPrecision();\r\n\t\t\t\tif(length < bytes.length){\r\n\t\t\t\t\tbyte[] buffer = new byte[length];\r\n\t\t\t\t\tSystem.arraycopy(bytes, 0, buffer, 0, Math.min(bytes.length,length) );\r\n\t\t\t\t\treturn buffer;\r\n\t\t\t\t}\r\n\t\t\t\treturn bytes;\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\tcase SQLTokenizer.BINARY:{\r\n\t\t\t\tbyte[] bytes = param1.getBytes();\r\n\t\t\t\tint length = datatype.getPrecision();\r\n\t\t\t\tif(length != bytes.length){\r\n\t\t\t\t\tbyte[] buffer = new byte[length];\r\n\t\t\t\t\tSystem.arraycopy(bytes, 0, buffer, 0, Math.min(bytes.length,length) );\r\n\t\t\t\t\treturn buffer;\r\n\t\t\t\t}\r\n\t\t\t\treturn bytes;\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\tcase SQLTokenizer.BOOLEAN:\r\n\t\t\tcase SQLTokenizer.BIT:\r\n\t\t\t\treturn param1.getBoolean() ? Boolean.TRUE : Boolean.FALSE;\r\n\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\treturn Utils.getInteger(param1.getInt() & 0xFF);\r\n\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\treturn Utils.getInteger((short)param1.getInt());\r\n\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\treturn Utils.getInteger(param1.getInt());\r\n\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\treturn new Long(param1.getLong());\r\n\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\treturn new Float(param1.getFloat());\r\n\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\treturn new Double(param1.getDouble());\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\treturn new DateTime( getDateTimeLong(), dataType );\r\n\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\tMutableNumeric num = param1.getNumeric();\r\n\t\t\t\tif(num != null && (dataType == SQLTokenizer.NUMERIC || dataType == SQLTokenizer.DECIMAL))\r\n\t\t\t\t\tnum.setScale(getScale());\r\n\t\t\t\treturn num;\r\n\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\tcase SQLTokenizer.SMALLMONEY:\r\n\t\t\t\treturn Money.createFromUnscaledValue(param1.getMoney());\r\n\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\tswitch(param1.getDataType()){\r\n\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\t\t\t\treturn Utils.bytes2unique( Utils.unique2bytes(param1.getString()), 0);\r\n\t\t\t\t}\r\n\t\t\t\treturn Utils.bytes2unique(param1.getBytes(), 0);\r\n\t\t}\r\n\t\tObject[] param = { SQLTokenizer.getKeyWord(dataType) };\r\n\t\tthrow SmallSQLException.create(Language.UNSUPPORTED_TYPE_CONV, param);\r\n\t}\r\n\t\r\n\t\r\n\tfinal private String convertToString() throws Exception{\r\n\t\tif(param2 != null){\r\n\t\t\tint type = param1.getDataType();\r\n\t\t\tswitch(type){\r\n\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\ttype = SQLTokenizer.TIMESTAMP;\r\n\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\treturn new DateTime( param1.getLong(), type ).toString(param2.getInt());\r\n\t\t\t\tdefault:\r\n\t\t\t\t\treturn param1.getString();\r\n\t\t\t}\r\n\t\t\t//TODO Format for MONEY, REAL and DOUBLE\r\n\t\t}else\r\n\t\t\treturn param1.getString();\r\n\t}\r\n\t\r\n\t\r\n\tfinal private long getDateTimeLong() throws Exception{\r\n\t\t//try{\r\n\t\t\tswitch(param1.getDataType()){\r\n\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\treturn DateTime.parse( param1.getString() );\r\n\t\t\t}\r\n\t\t//}catch(Exception e){/* do nothing */}\r\n\t\treturn param1.getLong();\r\n\t}\r\n\r\n\r\n\tfinal int getDataType() {\r\n\t\treturn datatype.getDataType();\r\n\t}\r\n\t\r\n\t\r\n\tfinal int getPrecision(){\r\n\t\tfinal int dataType = getDataType();\r\n\t\tswitch(dataType){\r\n\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\tcase SQLTokenizer.VARBINARY:\r\n\t\t\tcase SQLTokenizer.BINARY:\r\n\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\treturn datatype.getPrecision();\r\n\t\t\tdefault:\r\n\t\t\t\treturn super.getPrecision();\r\n\t\t}\r\n\t}\r\n\r\n\t\r\n\tfinal int getScale() {\r\n\t\treturn datatype.getScale();\r\n\t}\r\n\t\r\n\r\n}\r\n"},{"path":"/src/smallsql/database/IndexDescription.java","source":"/* =============================================================\r\n * SmallSQL : a free Java DBMS library for the Java(tm) platform\r\n * =============================================================\r\n *\r\n * (C) Copyright 2004-2011, by Volker Berlin.\r\n *\r\n * Project Info:  http://www.smallsql.de/\r\n *\r\n * This library is free software; you can redistribute it and/or modify it \r\n * under the terms of the GNU Lesser General Public License as published by \r\n * the Free Software Foundation; either version 2.1 of the License, or \r\n * (at your option) any later version.\r\n *\r\n * This library is distributed in the hope that it will be useful, but \r\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \r\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public \r\n * License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, \r\n * USA.  \r\n *\r\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc. \r\n * in the United States and other countries.]\r\n *\r\n * ---------------\r\n * IndexDescription.java\r\n * ---------------\r\n * Author: Volker Berlin\r\n * \r\n * Created on 19.04.2005\r\n */\r\npackage smallsql.database;\r\n\r\nimport java.io.File;\r\nimport java.nio.ByteBuffer;\r\nimport java.nio.channels.FileChannel;\r\nimport java.sql.DriverManager;\r\nimport java.sql.SQLException;\r\nimport smallsql.database.language.Language;\r\n\r\n\r\nfinal class IndexDescription {\r\n\r\n\tstatic final int MAGIC_INDEX = 'S' << 24 | 'Q' << 16 | 'L' << 8 | 'I';\r\n\tstatic final int INDEX_VERSION = 1;\r\n\t\r\n\tprivate final String name;\r\n\tfinal private int constraintType; //PRIMARY, UNIQUE, FOREIGIN, INDEX\r\n\tfinal private Strings columns;\r\n\tprivate int[] matrix;\r\n\tfinal private Expressions expressions;\r\n\tprivate Index index;\r\n    private FileChannel raFile;\r\n    \r\n\t\r\n\t/**\r\n\t * \r\n\t * @param constraintType one of SQLTokenizer.PRIMARY, SQLTokenizer.UNIQUE, SQLTokenizer.FOREIGN or SQLTokenizer.INDEX.\r\n\t * @param columns the Expressions that build the index. For example one or more database columns.\r\n\t */\r\n\tIndexDescription( String name, String tableName, int constraintType, Expressions expressions, Strings columns){\r\n\t\tthis.constraintType = constraintType;\r\n\t\tthis.expressions = expressions;\r\n\t\tthis.columns = columns;\r\n        this.name = createName(name, tableName);\r\n\t}\r\n    \r\n    \r\n    private static String createName( String defaultName, String tableName ){\r\n        if(defaultName == null){\r\n            defaultName = tableName + \"_\" + Long.toHexString(System.currentTimeMillis()) + Integer.toHexString(new Object().hashCode());\r\n        }\r\n        return defaultName;\r\n    }\r\n\t\r\n\t\r\n\tfinal String getName(){\r\n\t\treturn name;\r\n\t}\r\n\t\r\n\t\r\n\tfinal boolean isPrimary(){\r\n\t\treturn constraintType == SQLTokenizer.PRIMARY;\r\n\t}\r\n\t\r\n\t\r\n\tfinal boolean isUnique(){\r\n\t\treturn constraintType == SQLTokenizer.PRIMARY || constraintType == SQLTokenizer.UNIQUE;\r\n\t}\r\n\t\r\n\t\r\n\tfinal Strings getColumns(){\r\n\t\treturn columns;\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * Described how well the index match to the column list.\r\n\t * @param strings a list of columns that should match\r\n\t * @return Integer.MAX_VALUE does not match; 0 - 100% match\r\n\t */\r\n\tfinal int matchFactor(Strings strings){\r\n\t\tif(strings.size() < columns.size())\r\n\t\t\treturn Integer.MAX_VALUE; //does not map\r\n\t\t\r\n\t\tnextColumn:\r\n\t\tfor(int c=0; c<columns.size(); c++){\r\n\t\t\tString colName = columns.get(c);\r\n\t\t\tfor(int s=0; s<strings.size(); s++){\r\n\t\t\t\tif(colName.equalsIgnoreCase(strings.get(s)) )\r\n\t\t\t\t\tcontinue nextColumn;\r\n\t\t\t}\r\n\t\t\treturn Integer.MAX_VALUE; //No Strin found for colName\r\n\t\t}\r\n\t\treturn strings.size() - columns.size();\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * Create a binding of the columns form this index to the columns of the table.\r\n\t * @param database \r\n\t * @param tableView\r\n\t * @see IndexDescriptions#setTableView\r\n\t */\r\n\tfinal void init(Database database, TableView tableView)/* throws Exception*/{\r\n\t\tint size = tableView.columns.size();\r\n\t\tmatrix = new int[size];\r\n\t\tfor(int i=0; i<matrix.length; i++){\r\n\t\t\tmatrix[i] = -1;\r\n\t\t}\r\n\t\t\r\n\t\tfor(int i=0; i<columns.size(); i++){\r\n\t\t\tmatrix[tableView.findColumnIdx(columns.get(i))] = i;\r\n\t\t}\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * Create the index. A raFile for storing the index data is saved.\r\n\t */\r\n\tfinal void create(SSConnection con, Database database, TableView tableView) throws Exception{\r\n\t\tinit( database, tableView );\r\n\t\traFile = createFile( con, database );\r\n\t}\r\n\t\r\n\t\r\n\tstatic File getFile(Database database, String name) throws Exception{\r\n\t\treturn new File( Utils.createIdxFileName( database, name ) );\r\n\t}\r\n\t\r\n\r\n\tprivate FileChannel createFile(SSConnection con, Database database) throws Exception{\r\n\t    if( database.isReadOnly() ){\r\n\t        throw SmallSQLException.create(Language.DB_READONLY);\r\n\t    }\r\n\t\tFile file = getFile( database, name );\r\n\t\tboolean ok = file.createNewFile();\r\n\t\tif(!ok) throw SmallSQLException.create(Language.INDEX_EXISTS, name);\r\n\t\tFileChannel randomFile = Utils.openRaFile( file, database.isReadOnly() );\r\n        con.add(new CreateFile(file, randomFile, con, database));\r\n\t\twriteMagic(randomFile);\r\n\t\treturn randomFile;\r\n\t}\r\n    \r\n    \r\n    private void load(Database database) throws SQLException{\r\n        try{\r\n            File file = getFile( database, name );\r\n            if(!file.exists())\r\n                throw SmallSQLException.create(Language.INDEX_MISSING, name);\r\n            raFile = Utils.openRaFile( file, database.isReadOnly() );\r\n            ByteBuffer buffer = ByteBuffer.allocate(8);\r\n            raFile.read(buffer);\r\n            buffer.position(0);\r\n            int magic   = buffer.getInt();\r\n            int version = buffer.getInt();\r\n            if(magic != MAGIC_INDEX){\r\n                throw SmallSQLException.create(Language.INDEX_FILE_INVALID, file.getName());\r\n            }\r\n            if(version > INDEX_VERSION){\r\n            \tObject[] params = { new Integer(version), file.getName() };\r\n                throw SmallSQLException.create(Language.FILE_TOONEW, params);\r\n            }\r\n        }catch(Throwable e){\r\n            if(raFile != null)\r\n                try{\r\n                    raFile.close();\r\n                }catch(Exception e2){\r\n                    DriverManager.println(e2.toString());\r\n                }\r\n            throw SmallSQLException.createFromException(e);\r\n        }\r\n    }\r\n\t\r\n\r\n\tvoid drop(Database database) throws Exception {\r\n        close();\r\n\t\tboolean ok = getFile( database, name).delete();\r\n\t\tif(!ok) throw SmallSQLException.create(Language.TABLE_CANT_DROP, name);\r\n\t}\r\n    \r\n    \r\n    void close() throws Exception{\r\n        if(raFile != null){\r\n            raFile.close();\r\n            raFile = null;\r\n        }\r\n    }\r\n    \r\n\r\n\tprivate final void writeMagic(FileChannel raFile) throws Exception{\r\n\t    ByteBuffer buffer = ByteBuffer.allocate(8);\r\n\t    buffer.putInt(MAGIC_INDEX);\r\n\t    buffer.putInt(INDEX_VERSION);\r\n\t    buffer.position(0);\r\n\t    raFile.write(buffer);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * This is call if a single colum of the table is changed.\r\n\t * @param columnIdx The column position in the table\r\n\t * @param valueExpression the new value of the current row.\r\n\t */\r\n\tfinal void writeExpression( int columnIdx, Expression valueExpression) {\r\n\t\tint idx = matrix[columnIdx];\r\n\t\tif(idx >= 0) //set only if the column part of this index\r\n\t\t\texpressions.set(idx, valueExpression);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * This is call if the row is finish written.\r\n\t * @param con the connection for a later commit or rollback.\r\n\t */\r\n\tfinal void writeFinish(SSConnection con) {\r\n\t\t//TODO\r\n\t\t//index.addValues(expressions);\t\t\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * Save this IndexDescription in the Table definition.\r\n\t */\r\n\tfinal void save(StoreImpl store) throws SQLException{\r\n\t\tstore.writeInt(constraintType);\r\n\t\tstore.writeInt(columns.size());\r\n\t\tfor(int c=0; c<columns.size(); c++){\r\n\t\t\tstore.writeString( columns.get(c) );\r\n\t\t}\r\n\t\tstore.writeString(name);\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * Restore a IndexDescription from a saved Table.\r\n\t */\r\n\tfinal static IndexDescription load(Database database, TableView tableView, StoreImpl store) throws SQLException{\r\n\t\tint constraintType = store.readInt();\r\n\t\tint count = store.readInt();\r\n\t\tStrings columns = new Strings();\r\n\t\tExpressions expressions = new Expressions();\r\n\t\tSQLParser sqlParser = new SQLParser();\r\n\t\tfor(int c=0; c<count; c++){\r\n\t\t\tString column = store.readString();\r\n\t\t\tcolumns.add( column );\r\n\t\t\texpressions.add( sqlParser.parseExpression(column));\r\n\t\t}\r\n\t\tIndexDescription indexDesc = new IndexDescription( store.readString(), tableView.name, constraintType, expressions, columns);\r\n        indexDesc.init( database, tableView );\r\n        indexDesc.load(database);\r\n\t\treturn indexDesc;\r\n\t}\r\n\r\n\r\n}\r\n"},{"path":"/src/smallsql/junit/TestDBMetaData.java","source":"/* =============================================================\r\n * SmallSQL : a free Java DBMS library for the Java(tm) platform\r\n * =============================================================\r\n *\r\n * (C) Copyright 2004-2007, by Volker Berlin.\r\n *\r\n * Project Info:  http://www.smallsql.de/\r\n *\r\n * This library is free software; you can redistribute it and/or modify it \r\n * under the terms of the GNU Lesser General Public License as published by \r\n * the Free Software Foundation; either version 2.1 of the License, or \r\n * (at your option) any later version.\r\n *\r\n * This library is distributed in the hope that it will be useful, but \r\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \r\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public \r\n * License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, \r\n * USA.  \r\n *\r\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc. \r\n * in the United States and other countries.]\r\n *\r\n * ---------------\r\n * TestDBMetaData.java\r\n * ---------------\r\n * Author: Volker Berlin\r\n * \r\n */\r\npackage smallsql.junit;\r\n\r\nimport java.sql.*;\r\nimport java.text.*;\r\nimport java.util.Locale;\r\n/**\r\n * @author Volker Berlin\r\n *\r\n */\r\npublic class TestDBMetaData extends BasicTestCase {\r\n\r\n\tpublic TestDBMetaData(){\r\n\t\tsuper();\r\n\t}\r\n    \r\n    \r\n\tpublic TestDBMetaData(String arg0) {\r\n\t\tsuper(arg0);\r\n\t}\r\n\r\n    \r\n    public void testGetURL() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        DatabaseMetaData md = con.getMetaData();\r\n        assertEquals( \"URL\", AllTests.JDBC_URL, md.getURL());\r\n    }\r\n    \r\n    \r\n    public void testVersions() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        DatabaseMetaData md = con.getMetaData();\r\n        assertEquals( \"DriverVersion\", md.getDriverVersion(), md.getDatabaseProductVersion());\r\n        Driver driver = DriverManager.getDriver(AllTests.JDBC_URL);\r\n        assertEquals( \"MajorVersion\", driver.getMajorVersion(), md.getDatabaseMajorVersion());\r\n        assertEquals( \"MajorVersion\", driver.getMajorVersion(), md.getDriverMajorVersion());\r\n        assertEquals( \"MinorVersion\", driver.getMinorVersion(), md.getDatabaseMinorVersion());\r\n        assertEquals( \"MinorVersion\", driver.getMinorVersion(), md.getDriverMinorVersion());\r\n        assertEquals( \"Version\", new DecimalFormat(\"###0.00\", new DecimalFormatSymbols(Locale.US)).format(driver.getMajorVersion()+driver.getMinorVersion()/100.0), md.getDriverVersion());\r\n        assertTrue( \"jdbcCompliant\", driver.jdbcCompliant() );\r\n    }\r\n    \r\n    \r\n    public void testFunctions() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        DatabaseMetaData md = con.getMetaData();\r\n        assertEquals( \"getNumericFunctions\", \"ABS,ACOS,ASIN,ATAN,ATAN2,CEILING,COS,COT,DEGREES,EXP,FLOOR,LOG,LOG10,MOD,PI,POWER,RADIANS,RAND,ROUND,SIGN,SIN,SQRT,TAN,TRUNCATE\",\r\n                md.getNumericFunctions());\r\n        assertEquals( \"getStringFunctions\", \"ASCII,BIT_LENGTH,CHAR_LENGTH,CHARACTER_LENGTH,CHAR,CONCAT,DIFFERENCE,INSERT,LCASE,LEFT,LENGTH,LOCATE,LTRIM,OCTET_LENGTH,REPEAT,REPLACE,RIGHT,RTRIM,SOUNDEX,SPACE,SUBSTRING,TRIM,UCASE\",\r\n                md.getStringFunctions());\r\n        assertEquals( \"getStringFunctions\", \"IFNULL,USER,CONVERT,CAST,IIF\",\r\n                md.getSystemFunctions());\r\n        assertEquals( \"getStringFunctions\", \"CURDATE,CURRENT_DATE,CURTIME,DAYNAME,DAYOFMONTH,DAYOFWEEK,DAYOFYEAR,DAY,HOUR,MILLISECOND,MINUTE,MONTH,MONTHNAME,NOW,QUARTER,SECOND,TIMESTAMPADD,TIMESTAMPDIFF,WEEK,YEAR\",\r\n                md.getTimeDateFunctions());\r\n    }\r\n    \r\n    \r\n    public void testGetProcedures() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        DatabaseMetaData md = con.getMetaData();\r\n        ResultSet rs = md.getProcedures( null, null, \"*\");\r\n        String[] colNames = {\"PROCEDURE_CAT\", \"PROCEDURE_SCHEM\", \"PROCEDURE_NAME\", \"\", \"\", \"\", \"REMARKS\", \"PROCEDURE_TYPE\"};\r\n        int[] colTypes = {Types.NULL, Types.NULL, Types.NULL, Types.NULL, Types.NULL, Types.NULL, Types.NULL, Types.NULL };\r\n        assertRSMetaData( rs, colNames, colTypes);\r\n    }\r\n    \r\n    \r\n    public void testGetProcedureColumns() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        DatabaseMetaData md = con.getMetaData();\r\n        ResultSet rs = md.getProcedureColumns( null, null, \"*\", null);\r\n        String[] colNames = {\"PROCEDURE_CAT\", \"PROCEDURE_SCHEM\", \"PROCEDURE_NAME\", \"COLUMN_NAME\", \"COLUMN_TYPE\", \"DATA_TYPE\", \"TYPE_NAME\", \"PRECISION\", \"LENGTH\", \"SCALE\", \"RADIX\", \"NULLABLE\", \"REMARKS\" };\r\n        int[] colTypes = {Types.NULL, Types.NULL, Types.NULL, Types.NULL, Types.NULL, Types.NULL, Types.NULL, Types.NULL, Types.NULL, Types.NULL, Types.NULL, Types.NULL, Types.NULL };\r\n        assertRSMetaData( rs, colNames, colTypes);\r\n    }\r\n    \r\n    \r\n    public void testGetTables() throws Exception{\r\n        String[] colNames = {\"TABLE_CAT\",\"TABLE_SCHEM\",\"TABLE_NAME\",\"TABLE_TYPE\",\"REMARKS\",\"TYPE_CAT\",\"TYPE_SCHEM\",\"TYPE_NAME\",\"SELF_REFERENCING_COL_NAME\",\"REF_GENERATION\"};\r\n        int[] types = {Types.VARCHAR, Types.NULL, Types.VARCHAR, Types.VARCHAR, Types.NULL, Types.NULL, Types.NULL, Types.NULL, Types.NULL, Types.NULL};\r\n        \r\n        //First test the function without a database connection\r\n        Connection con = DriverManager.getConnection(\"jdbc:smallsql?\");\r\n        DatabaseMetaData md = con.getMetaData();\r\n        ResultSet rs = md.getTables(null, null, null, null);\r\n        super.assertRSMetaData(rs, colNames, new int[colNames.length]); //All types are NULL, because no row.\r\n        assertFalse(rs.next());\r\n        con.close();\r\n        \r\n        //Then test it with a database\r\n        con = AllTests.getConnection();\r\n        md = con.getMetaData();\r\n        rs = md.getTables(null, null, null, null);\r\n        super.assertRSMetaData(rs, colNames, types);\r\n    }\r\n    \r\n    \r\n    public void testGetSchemas() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        DatabaseMetaData md = con.getMetaData();\r\n        ResultSet rs = md.getSchemas();\r\n        String[] colNames = {\"TABLE_SCHEM\"};\r\n        int[] colTypes = {Types.NULL};\r\n        assertRSMetaData( rs, colNames, colTypes);\r\n        assertFalse(rs.next());\r\n    }\r\n    \r\n    \r\n\tpublic void testGetCatalogs() throws Exception{\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\ttry{\r\n\t\t\tcon.createStatement().execute(\"drop database test2\\n\\r\\t\");\r\n\t\t}catch(SQLException e){/* ignore it if the database already exists */}\r\n\t\tcon.createStatement().execute(\"create database test2\");\r\n\t\tDatabaseMetaData md = con.getMetaData();\r\n\t\tResultSet rs = md.getCatalogs();\r\n\t\tassertRSMetaData( rs, new String[]{\"TABLE_CAT\"}, new int[]{Types.VARCHAR});\r\n\t\twhile(rs.next()){\r\n\t\t\tSystem.out.println( \"testCatalogs:\"+rs.getObject(1) );\r\n\t\t}\r\n\t}\r\n\t\r\n    \r\n    public void testGetTableTypes() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        DatabaseMetaData md = con.getMetaData();\r\n        ResultSet rs = md.getTableTypes();\r\n        String[] colNames = {\"TABLE_TYPE\"};\r\n        int[] colTypes = {Types.VARCHAR};\r\n        assertRSMetaData( rs, colNames, colTypes);\r\n        String type = \"\";\r\n        int count = 0;\r\n        while(rs.next()){\r\n            String type2 = rs.getString(\"TABLE_TYPE\");\r\n            assertTrue( type+\"-\"+type2, type.compareTo(type2)<0);\r\n            type = type2;\r\n            count++;\r\n        }\r\n        assertEquals(\"Table Type Count\", 3, count);\r\n    }\r\n    \r\n    \r\n\tpublic void testGetColumn() throws Exception{\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tdropTable(con,\"tableColumns\");\r\n\t\tdropView( con, \"viewColumns\");\r\n\t\tcon.createStatement().execute(\"create table tableColumns(a int default 5)\");\r\n\t\tDatabaseMetaData md = con.getMetaData();\r\n\t\t\r\n\t\tResultSet rs = md.getColumns(null, null, \"tableColumns\", null);\r\n        String[] colNames = {\"TABLE_CAT\", \"TABLE_SCHEM\", \"TABLE_NAME\", \"COLUMN_NAME\", \"DATA_TYPE\", \"TYPE_NAME\", \"COLUMN_SIZE\", \"BUFFER_LENGTH\", \"DECIMAL_DIGITS\", \"NUM_PREC_RADIX\", \"NULLABLE\", \"REMARKS\", \"COLUMN_DEF\", \"SQL_DATA_TYPE\", \"SQL_DATETIME_SUB\", \"CHAR_OCTET_LENGTH\", \"ORDINAL_POSITION\", \"IS_NULLABLE\"};\r\n        int[] colTypes = {Types.VARCHAR, Types.NULL, Types.VARCHAR, Types.VARCHAR, Types.SMALLINT, Types.VARCHAR, Types.INTEGER, Types.NULL, Types.INTEGER, Types.INTEGER, Types.INTEGER, Types.NULL, Types.VARCHAR, Types.NULL, Types.NULL, Types.INTEGER, Types.INTEGER, Types.VARCHAR};\r\n\t\tassertRSMetaData( rs, colNames, colTypes);\t\t\r\n\t\tassertTrue( \"No row\", rs.next() );\r\n\t\tassertEquals( \"a\", rs.getObject(\"COLUMN_NAME\") ); \r\n\t\tassertEquals( \"INT\", rs.getObject(\"TYPE_NAME\") ); \r\n\t\tassertEquals( \"5\", rs.getObject(\"COLUMN_Def\") ); \r\n\t\t\r\n\t\tcon.createStatement().execute(\"create view viewColumns as Select * from tableColumns\");\r\n\t\t\r\n\t\trs = md.getColumns(null, null, \"viewColumns\", null);\r\n\t\tassertRSMetaData( rs, colNames, colTypes);\t\t\r\n\t\tassertTrue( \"No row\", rs.next() );\r\n\t\tassertEquals( \"a\", rs.getObject(\"COLUMN_NAME\") ); \r\n\t\tassertEquals( \"INT\", rs.getObject(\"TYPE_NAME\") ); \r\n\t\tassertEquals( \"5\", rs.getObject(\"COLUMN_Def\") ); \r\n\r\n\t\tdropView( con, \"viewColumns\");\r\n\t\tdropTable( con, \"tableColumns\");\r\n\t}\r\n    \r\n    \r\n    public void testGetTypeInfo() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        DatabaseMetaData md = con.getMetaData();\r\n        \r\n        ResultSet rs = md.getTypeInfo();  \r\n        \r\n        String[] colNames = {\"TYPE_NAME\", \"DATA_TYPE\", \"PRECISION\", \"LITERAL_PREFIX\", \"LITERAL_SUFFIX\", \"CREATE_PARAMS\", \"NULLABLE\", \"CASE_SENSITIVE\", \"SEARCHABLE\", \"UNSIGNED_ATTRIBUTE\", \"FIXED_PREC_SCALE\", \"AUTO_INCREMENT\", \"LOCAL_TYPE_NAME\", \"MINIMUM_SCALE\", \"MAXIMUM_SCALE\", \"SQL_DATA_TYPE\", \"SQL_DATETIME_SUB\", \"NUM_PREC_RADIX\"};\r\n        int[] colTypes = {Types.VARCHAR, Types.SMALLINT, Types.INTEGER, Types.VARCHAR, Types.VARCHAR, Types.VARCHAR, Types.SMALLINT, Types.BOOLEAN, Types.SMALLINT, Types.BOOLEAN, Types.BOOLEAN, Types.BOOLEAN, Types.NULL, Types.INTEGER, Types.INTEGER, Types.NULL, Types.NULL, Types.NULL };\r\n        assertRSMetaData(rs, colNames, colTypes);\r\n        \r\n        assertTrue(rs.next());\r\n        int lastDataType = rs.getInt(\"data_type\");\r\n        while(rs.next()){\r\n            int dataType = rs.getInt(\"data_type\");\r\n            assertTrue(\"Wrong sorting order\", dataType>=lastDataType );\r\n            lastDataType = dataType;\r\n        }\r\n    }\r\n\t\r\n    \r\n    public void testGetCrossReference() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        dropTable(con,\"tblCross1\");\r\n        dropTable(con,\"tblCross2\");\r\n        DatabaseMetaData md = con.getMetaData();\r\n        \r\n        Statement st = con.createStatement();\r\n        st.execute(\"Create Table tblCross1(id1 counter primary key, v nvarchar(100))\");\r\n        //st.execute(\"Create Table tblCross2(id2 counter foreign key REFERENCES tblCross1(id1), v nvarchar(100))\");\r\n        st.execute(\"Create Table tblCross2(id2 int , v nvarchar(100), foreign key (id2) REFERENCES tblCross1(id1))\");\r\n        String[] colNames = {\"PKTABLE_CAT\", \"PKTABLE_SCHEM\", \"PKTABLE_NAME\", \"PKCOLUMN_NAME\", \"FKTABLE_CAT\", \"FKTABLE_SCHEM\", \"FKTABLE_NAME\", \"FKCOLUMN_NAME\", \"KEY_SEQ\", \"UPDATE_RULE\", \"DELETE_RULE\", \"FK_NAME\", \"PK_NAME\", \"DEFERRABILITY\"};\r\n        int[] colTypes = {Types.VARCHAR, Types.NULL, Types.VARCHAR, Types.VARCHAR, Types.VARCHAR, Types.NULL, Types.VARCHAR, Types.VARCHAR, Types.SMALLINT, Types.SMALLINT, Types.SMALLINT, Types.VARCHAR, Types.VARCHAR, Types.SMALLINT };\r\n        \r\n        ResultSet rs = md.getCrossReference(null,null,\"tblCross1\",null,null,\"tblCross2\");\r\n        assertRSMetaData(rs, colNames, colTypes);\r\n        assertTrue(rs.next());\r\n        assertFalse(rs.next());\r\n        \r\n        rs = md.getImportedKeys(null,null,\"tblCross2\");\r\n        assertRSMetaData(rs, colNames, colTypes);\r\n        assertTrue(rs.next());\r\n        assertFalse(rs.next());\r\n        \r\n        rs = md.getExportedKeys(null,null,\"tblCross1\");\r\n        assertRSMetaData(rs, colNames, colTypes);\r\n        assertTrue(rs.next());\r\n        assertFalse(rs.next());\r\n        \r\n        dropTable(con,\"tblCross1\");\r\n        dropTable(con,\"tblCross2\");\r\n    }\r\n    \r\n    \r\n    public void testGetBestRowIdentifier() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        dropTable(con,\"tblBestRow1\");\r\n        DatabaseMetaData md = con.getMetaData();\r\n        Statement st = con.createStatement();\r\n        st.execute(\"Create Table tblBestRow1(id1 counter primary key, v nvarchar(100))\");\r\n        String[] colNames = {\"SCOPE\", \"COLUMN_NAME\", \"DATA_TYPE\", \"TYPE_NAME\", \"COLUMN_SIZE\", \"BUFFER_LENGTH\", \"DECIMAL_DIGITS\", \"PSEUDO_COLUMN\"};\r\n        int[] colTypes = {Types.SMALLINT, Types.VARCHAR, Types.INTEGER, Types.VARCHAR, Types.INTEGER, Types.NULL, Types.SMALLINT, Types.SMALLINT};\r\n        \r\n        ResultSet rs = md.getBestRowIdentifier(null, null, \"tblBestRow1\", DatabaseMetaData.bestRowSession, true);        \r\n        assertRSMetaData(rs, colNames, colTypes);\r\n        assertTrue(rs.next());\r\n        assertEquals(\"Columnname:\", \"id1\", rs.getString(\"COLUMN_NAME\"));\r\n        assertFalse(rs.next());\r\n        \r\n        String[] colNames2 = {\"TABLE_CAT\", \"TABLE_SCHEM\", \"TABLE_NAME\", \"COLUMN_NAME\", \"KEY_SEQ\", \"PK_NAME\"};\r\n        int[] colTypes2 = {Types.VARCHAR, Types.NULL, Types.VARCHAR, Types.VARCHAR, Types.SMALLINT, Types.VARCHAR};\r\n        rs = md.getPrimaryKeys(null, null, \"tblBestRow1\");        \r\n        assertRSMetaData(rs, colNames2, colTypes2);\r\n        assertTrue(rs.next());\r\n        assertEquals(\"Columnname:\", \"id1\", rs.getString(\"COLUMN_NAME\"));\r\n        assertFalse(rs.next());\r\n        \r\n        String[] colNames3 = {\"TABLE_CAT\", \"TABLE_SCHEM\", \"TABLE_NAME\", \"NON_UNIQUE\", \"INDEX_QUALIFIER\", \"INDEX_NAME\", \"TYPE\", \"ORDINAL_POSITION\", \"COLUMN_NAME\", \"ASC_OR_DESC\", \"CARDINALITY\", \"PAGES\", \"FILTER_CONDITION\"};\r\n        int[] colTypes3 = {Types.VARCHAR, Types.NULL, Types.VARCHAR, Types.BOOLEAN, Types.NULL, Types.VARCHAR, Types.SMALLINT, Types.SMALLINT, Types.VARCHAR, Types.NULL, Types.NULL, Types.NULL, Types.NULL};\r\n        rs = md.getIndexInfo(null, null, \"tblBestRow1\", true, true);        \r\n        assertRSMetaData(rs, colNames3, colTypes3);\r\n        assertTrue(rs.next());\r\n        assertEquals(\"Columnname:\", \"id1\", rs.getString(\"COLUMN_NAME\"));\r\n        assertFalse(rs.next());\r\n        \r\n        dropTable(con,\"tblBestRow1\");\r\n    }\r\n    \r\n    \r\n    public void testGetgetUDTs() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        DatabaseMetaData md = con.getMetaData();\r\n        ResultSet rs = md.getUDTs(null, null, null, null);\r\n        String[] colNames = {\"TYPE_CAT\", \"TYPE_SCHEM\", \"TYPE_NAME\", \"CLASS_NAME\", \"DATA_TYPE\", \"REMARKS\"};\r\n        int[] colTypes = new int[colNames.length];\r\n        assertRSMetaData( rs, colNames, colTypes);\r\n        assertFalse(rs.next());\r\n    }\r\n    \r\n    \r\n    public void testGetConnection() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        DatabaseMetaData md = con.getMetaData();\r\n        assertEquals(con, md.getConnection());\r\n    }\r\n\r\n    \r\n}\r\n"},{"path":"/src/smallsql/junit/TestDBMetaData.java","source":"/* =============================================================\r\n * SmallSQL : a free Java DBMS library for the Java(tm) platform\r\n * =============================================================\r\n *\r\n * (C) Copyright 2004-2007, by Volker Berlin.\r\n *\r\n * Project Info:  http://www.smallsql.de/\r\n *\r\n * This library is free software; you can redistribute it and/or modify it \r\n * under the terms of the GNU Lesser General Public License as published by \r\n * the Free Software Foundation; either version 2.1 of the License, or \r\n * (at your option) any later version.\r\n *\r\n * This library is distributed in the hope that it will be useful, but \r\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \r\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public \r\n * License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, \r\n * USA.  \r\n *\r\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc. \r\n * in the United States and other countries.]\r\n *\r\n * ---------------\r\n * TestDBMetaData.java\r\n * ---------------\r\n * Author: Volker Berlin\r\n * \r\n */\r\npackage smallsql.junit;\r\n\r\nimport java.sql.*;\r\nimport java.text.*;\r\nimport java.util.Locale;\r\n/**\r\n * @author Volker Berlin\r\n *\r\n */\r\npublic class TestDBMetaData extends BasicTestCase {\r\n\r\n\tpublic TestDBMetaData(){\r\n\t\tsuper();\r\n\t}\r\n    \r\n    \r\n\tpublic TestDBMetaData(String arg0) {\r\n\t\tsuper(arg0);\r\n\t}\r\n\r\n    \r\n    public void testGetURL() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        DatabaseMetaData md = con.getMetaData();\r\n        assertEquals( \"URL\", AllTests.JDBC_URL, md.getURL());\r\n    }\r\n    \r\n    \r\n    public void testVersions() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        DatabaseMetaData md = con.getMetaData();\r\n        assertEquals( \"DriverVersion\", md.getDriverVersion(), md.getDatabaseProductVersion());\r\n        Driver driver = DriverManager.getDriver(AllTests.JDBC_URL);\r\n        assertEquals( \"MajorVersion\", driver.getMajorVersion(), md.getDatabaseMajorVersion());\r\n        assertEquals( \"MajorVersion\", driver.getMajorVersion(), md.getDriverMajorVersion());\r\n        assertEquals( \"MinorVersion\", driver.getMinorVersion(), md.getDatabaseMinorVersion());\r\n        assertEquals( \"MinorVersion\", driver.getMinorVersion(), md.getDriverMinorVersion());\r\n        assertEquals( \"Version\", new DecimalFormat(\"###0.00\", new DecimalFormatSymbols(Locale.US)).format(driver.getMajorVersion()+driver.getMinorVersion()/100.0), md.getDriverVersion());\r\n        assertTrue( \"jdbcCompliant\", driver.jdbcCompliant() );\r\n    }\r\n    \r\n    \r\n    public void testFunctions() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        DatabaseMetaData md = con.getMetaData();\r\n        assertEquals( \"getNumericFunctions\", \"ABS,ACOS,ASIN,ATAN,ATAN2,CEILING,COS,COT,DEGREES,EXP,FLOOR,LOG,LOG10,MOD,PI,POWER,RADIANS,RAND,ROUND,SIGN,SIN,SQRT,TAN,TRUNCATE\",\r\n                md.getNumericFunctions());\r\n        assertEquals( \"getStringFunctions\", \"ASCII,BIT_LENGTH,CHAR_LENGTH,CHARACTER_LENGTH,CHAR,CONCAT,DIFFERENCE,INSERT,LCASE,LEFT,LENGTH,LOCATE,LTRIM,OCTET_LENGTH,REPEAT,REPLACE,RIGHT,RTRIM,SOUNDEX,SPACE,SUBSTRING,TRIM,UCASE\",\r\n                md.getStringFunctions());\r\n        assertEquals( \"getStringFunctions\", \"IFNULL,USER,CONVERT,CAST,IIF\",\r\n                md.getSystemFunctions());\r\n        assertEquals( \"getStringFunctions\", \"CURDATE,CURRENT_DATE,CURTIME,DAYNAME,DAYOFMONTH,DAYOFWEEK,DAYOFYEAR,DAY,HOUR,MILLISECOND,MINUTE,MONTH,MONTHNAME,NOW,QUARTER,SECOND,TIMESTAMPADD,TIMESTAMPDIFF,WEEK,YEAR\",\r\n                md.getTimeDateFunctions());\r\n    }\r\n    \r\n    \r\n    public void testGetProcedures() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        DatabaseMetaData md = con.getMetaData();\r\n        ResultSet rs = md.getProcedures( null, null, \"*\");\r\n        String[] colNames = {\"PROCEDURE_CAT\", \"PROCEDURE_SCHEM\", \"PROCEDURE_NAME\", \"\", \"\", \"\", \"REMARKS\", \"PROCEDURE_TYPE\"};\r\n        int[] colTypes = {Types.NULL, Types.NULL, Types.NULL, Types.NULL, Types.NULL, Types.NULL, Types.NULL, Types.NULL };\r\n        assertRSMetaData( rs, colNames, colTypes);\r\n    }\r\n    \r\n    \r\n    public void testGetProcedureColumns() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        DatabaseMetaData md = con.getMetaData();\r\n        ResultSet rs = md.getProcedureColumns( null, null, \"*\", null);\r\n        String[] colNames = {\"PROCEDURE_CAT\", \"PROCEDURE_SCHEM\", \"PROCEDURE_NAME\", \"COLUMN_NAME\", \"COLUMN_TYPE\", \"DATA_TYPE\", \"TYPE_NAME\", \"PRECISION\", \"LENGTH\", \"SCALE\", \"RADIX\", \"NULLABLE\", \"REMARKS\" };\r\n        int[] colTypes = {Types.NULL, Types.NULL, Types.NULL, Types.NULL, Types.NULL, Types.NULL, Types.NULL, Types.NULL, Types.NULL, Types.NULL, Types.NULL, Types.NULL, Types.NULL };\r\n        assertRSMetaData( rs, colNames, colTypes);\r\n    }\r\n    \r\n    \r\n    public void testGetTables() throws Exception{\r\n        String[] colNames = {\"TABLE_CAT\",\"TABLE_SCHEM\",\"TABLE_NAME\",\"TABLE_TYPE\",\"REMARKS\",\"TYPE_CAT\",\"TYPE_SCHEM\",\"TYPE_NAME\",\"SELF_REFERENCING_COL_NAME\",\"REF_GENERATION\"};\r\n        int[] types = {Types.VARCHAR, Types.NULL, Types.VARCHAR, Types.VARCHAR, Types.NULL, Types.NULL, Types.NULL, Types.NULL, Types.NULL, Types.NULL};\r\n        \r\n        //First test the function without a database connection\r\n        Connection con = DriverManager.getConnection(\"jdbc:smallsql?\");\r\n        DatabaseMetaData md = con.getMetaData();\r\n        ResultSet rs = md.getTables(null, null, null, null);\r\n        super.assertRSMetaData(rs, colNames, new int[colNames.length]); //All types are NULL, because no row.\r\n        assertFalse(rs.next());\r\n        con.close();\r\n        \r\n        //Then test it with a database\r\n        con = AllTests.getConnection();\r\n        md = con.getMetaData();\r\n        rs = md.getTables(null, null, null, null);\r\n        super.assertRSMetaData(rs, colNames, types);\r\n    }\r\n    \r\n    \r\n    public void testGetSchemas() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        DatabaseMetaData md = con.getMetaData();\r\n        ResultSet rs = md.getSchemas();\r\n        String[] colNames = {\"TABLE_SCHEM\"};\r\n        int[] colTypes = {Types.NULL};\r\n        assertRSMetaData( rs, colNames, colTypes);\r\n        assertFalse(rs.next());\r\n    }\r\n    \r\n    \r\n\tpublic void testGetCatalogs() throws Exception{\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\ttry{\r\n\t\t\tcon.createStatement().execute(\"drop database test2\\n\\r\\t\");\r\n\t\t}catch(SQLException e){/* ignore it if the database already exists */}\r\n\t\tcon.createStatement().execute(\"create database test2\");\r\n\t\tDatabaseMetaData md = con.getMetaData();\r\n\t\tResultSet rs = md.getCatalogs();\r\n\t\tassertRSMetaData( rs, new String[]{\"TABLE_CAT\"}, new int[]{Types.VARCHAR});\r\n\t\twhile(rs.next()){\r\n\t\t\tSystem.out.println( \"testCatalogs:\"+rs.getObject(1) );\r\n\t\t}\r\n\t}\r\n\t\r\n    \r\n    public void testGetTableTypes() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        DatabaseMetaData md = con.getMetaData();\r\n        ResultSet rs = md.getTableTypes();\r\n        String[] colNames = {\"TABLE_TYPE\"};\r\n        int[] colTypes = {Types.VARCHAR};\r\n        assertRSMetaData( rs, colNames, colTypes);\r\n        String type = \"\";\r\n        int count = 0;\r\n        while(rs.next()){\r\n            String type2 = rs.getString(\"TABLE_TYPE\");\r\n            assertTrue( type+\"-\"+type2, type.compareTo(type2)<0);\r\n            type = type2;\r\n            count++;\r\n        }\r\n        assertEquals(\"Table Type Count\", 3, count);\r\n    }\r\n    \r\n    \r\n\tpublic void testGetColumn() throws Exception{\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tdropTable(con,\"tableColumns\");\r\n\t\tdropView( con, \"viewColumns\");\r\n\t\tcon.createStatement().execute(\"create table tableColumns(a int default 5)\");\r\n\t\tDatabaseMetaData md = con.getMetaData();\r\n\t\t\r\n\t\tResultSet rs = md.getColumns(null, null, \"tableColumns\", null);\r\n        String[] colNames = {\"TABLE_CAT\", \"TABLE_SCHEM\", \"TABLE_NAME\", \"COLUMN_NAME\", \"DATA_TYPE\", \"TYPE_NAME\", \"COLUMN_SIZE\", \"BUFFER_LENGTH\", \"DECIMAL_DIGITS\", \"NUM_PREC_RADIX\", \"NULLABLE\", \"REMARKS\", \"COLUMN_DEF\", \"SQL_DATA_TYPE\", \"SQL_DATETIME_SUB\", \"CHAR_OCTET_LENGTH\", \"ORDINAL_POSITION\", \"IS_NULLABLE\"};\r\n        int[] colTypes = {Types.VARCHAR, Types.NULL, Types.VARCHAR, Types.VARCHAR, Types.SMALLINT, Types.VARCHAR, Types.INTEGER, Types.NULL, Types.INTEGER, Types.INTEGER, Types.INTEGER, Types.NULL, Types.VARCHAR, Types.NULL, Types.NULL, Types.INTEGER, Types.INTEGER, Types.VARCHAR};\r\n\t\tassertRSMetaData( rs, colNames, colTypes);\t\t\r\n\t\tassertTrue( \"No row\", rs.next() );\r\n\t\tassertEquals( \"a\", rs.getObject(\"COLUMN_NAME\") ); \r\n\t\tassertEquals( \"INT\", rs.getObject(\"TYPE_NAME\") ); \r\n\t\tassertEquals( \"5\", rs.getObject(\"COLUMN_Def\") ); \r\n\t\t\r\n\t\tcon.createStatement().execute(\"create view viewColumns as Select * from tableColumns\");\r\n\t\t\r\n\t\trs = md.getColumns(null, null, \"viewColumns\", null);\r\n\t\tassertRSMetaData( rs, colNames, colTypes);\t\t\r\n\t\tassertTrue( \"No row\", rs.next() );\r\n\t\tassertEquals( \"a\", rs.getObject(\"COLUMN_NAME\") ); \r\n\t\tassertEquals( \"INT\", rs.getObject(\"TYPE_NAME\") ); \r\n\t\tassertEquals( \"5\", rs.getObject(\"COLUMN_Def\") ); \r\n\r\n\t\tdropView( con, \"viewColumns\");\r\n\t\tdropTable( con, \"tableColumns\");\r\n\t}\r\n    \r\n    \r\n    public void testGetTypeInfo() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        DatabaseMetaData md = con.getMetaData();\r\n        \r\n        ResultSet rs = md.getTypeInfo();  \r\n        \r\n        String[] colNames = {\"TYPE_NAME\", \"DATA_TYPE\", \"PRECISION\", \"LITERAL_PREFIX\", \"LITERAL_SUFFIX\", \"CREATE_PARAMS\", \"NULLABLE\", \"CASE_SENSITIVE\", \"SEARCHABLE\", \"UNSIGNED_ATTRIBUTE\", \"FIXED_PREC_SCALE\", \"AUTO_INCREMENT\", \"LOCAL_TYPE_NAME\", \"MINIMUM_SCALE\", \"MAXIMUM_SCALE\", \"SQL_DATA_TYPE\", \"SQL_DATETIME_SUB\", \"NUM_PREC_RADIX\"};\r\n        int[] colTypes = {Types.VARCHAR, Types.SMALLINT, Types.INTEGER, Types.VARCHAR, Types.VARCHAR, Types.VARCHAR, Types.SMALLINT, Types.BOOLEAN, Types.SMALLINT, Types.BOOLEAN, Types.BOOLEAN, Types.BOOLEAN, Types.NULL, Types.INTEGER, Types.INTEGER, Types.NULL, Types.NULL, Types.NULL };\r\n        assertRSMetaData(rs, colNames, colTypes);\r\n        \r\n        assertTrue(rs.next());\r\n        int lastDataType = rs.getInt(\"data_type\");\r\n        while(rs.next()){\r\n            int dataType = rs.getInt(\"data_type\");\r\n            assertTrue(\"Wrong sorting order\", dataType>=lastDataType );\r\n            lastDataType = dataType;\r\n        }\r\n    }\r\n\t\r\n    \r\n    public void testGetCrossReference() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        dropTable(con,\"tblCross1\");\r\n        dropTable(con,\"tblCross2\");\r\n        DatabaseMetaData md = con.getMetaData();\r\n        \r\n        Statement st = con.createStatement();\r\n        st.execute(\"Create Table tblCross1(id1 counter primary key, v nvarchar(100))\");\r\n        //st.execute(\"Create Table tblCross2(id2 counter foreign key REFERENCES tblCross1(id1), v nvarchar(100))\");\r\n        st.execute(\"Create Table tblCross2(id2 int , v nvarchar(100), foreign key (id2) REFERENCES tblCross1(id1))\");\r\n        String[] colNames = {\"PKTABLE_CAT\", \"PKTABLE_SCHEM\", \"PKTABLE_NAME\", \"PKCOLUMN_NAME\", \"FKTABLE_CAT\", \"FKTABLE_SCHEM\", \"FKTABLE_NAME\", \"FKCOLUMN_NAME\", \"KEY_SEQ\", \"UPDATE_RULE\", \"DELETE_RULE\", \"FK_NAME\", \"PK_NAME\", \"DEFERRABILITY\"};\r\n        int[] colTypes = {Types.VARCHAR, Types.NULL, Types.VARCHAR, Types.VARCHAR, Types.VARCHAR, Types.NULL, Types.VARCHAR, Types.VARCHAR, Types.SMALLINT, Types.SMALLINT, Types.SMALLINT, Types.VARCHAR, Types.VARCHAR, Types.SMALLINT };\r\n        \r\n        ResultSet rs = md.getCrossReference(null,null,\"tblCross1\",null,null,\"tblCross2\");\r\n        assertRSMetaData(rs, colNames, colTypes);\r\n        assertTrue(rs.next());\r\n        assertFalse(rs.next());\r\n        \r\n        rs = md.getImportedKeys(null,null,\"tblCross2\");\r\n        assertRSMetaData(rs, colNames, colTypes);\r\n        assertTrue(rs.next());\r\n        assertFalse(rs.next());\r\n        \r\n        rs = md.getExportedKeys(null,null,\"tblCross1\");\r\n        assertRSMetaData(rs, colNames, colTypes);\r\n        assertTrue(rs.next());\r\n        assertFalse(rs.next());\r\n        \r\n        dropTable(con,\"tblCross1\");\r\n        dropTable(con,\"tblCross2\");\r\n    }\r\n    \r\n    \r\n    public void testGetBestRowIdentifier() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        dropTable(con,\"tblBestRow1\");\r\n        DatabaseMetaData md = con.getMetaData();\r\n        Statement st = con.createStatement();\r\n        st.execute(\"Create Table tblBestRow1(id1 counter primary key, v nvarchar(100))\");\r\n        String[] colNames = {\"SCOPE\", \"COLUMN_NAME\", \"DATA_TYPE\", \"TYPE_NAME\", \"COLUMN_SIZE\", \"BUFFER_LENGTH\", \"DECIMAL_DIGITS\", \"PSEUDO_COLUMN\"};\r\n        int[] colTypes = {Types.SMALLINT, Types.VARCHAR, Types.INTEGER, Types.VARCHAR, Types.INTEGER, Types.NULL, Types.SMALLINT, Types.SMALLINT};\r\n        \r\n        ResultSet rs = md.getBestRowIdentifier(null, null, \"tblBestRow1\", DatabaseMetaData.bestRowSession, true);        \r\n        assertRSMetaData(rs, colNames, colTypes);\r\n        assertTrue(rs.next());\r\n        assertEquals(\"Columnname:\", \"id1\", rs.getString(\"COLUMN_NAME\"));\r\n        assertFalse(rs.next());\r\n        \r\n        String[] colNames2 = {\"TABLE_CAT\", \"TABLE_SCHEM\", \"TABLE_NAME\", \"COLUMN_NAME\", \"KEY_SEQ\", \"PK_NAME\"};\r\n        int[] colTypes2 = {Types.VARCHAR, Types.NULL, Types.VARCHAR, Types.VARCHAR, Types.SMALLINT, Types.VARCHAR};\r\n        rs = md.getPrimaryKeys(null, null, \"tblBestRow1\");        \r\n        assertRSMetaData(rs, colNames2, colTypes2);\r\n        assertTrue(rs.next());\r\n        assertEquals(\"Columnname:\", \"id1\", rs.getString(\"COLUMN_NAME\"));\r\n        assertFalse(rs.next());\r\n        \r\n        String[] colNames3 = {\"TABLE_CAT\", \"TABLE_SCHEM\", \"TABLE_NAME\", \"NON_UNIQUE\", \"INDEX_QUALIFIER\", \"INDEX_NAME\", \"TYPE\", \"ORDINAL_POSITION\", \"COLUMN_NAME\", \"ASC_OR_DESC\", \"CARDINALITY\", \"PAGES\", \"FILTER_CONDITION\"};\r\n        int[] colTypes3 = {Types.VARCHAR, Types.NULL, Types.VARCHAR, Types.BOOLEAN, Types.NULL, Types.VARCHAR, Types.SMALLINT, Types.SMALLINT, Types.VARCHAR, Types.NULL, Types.NULL, Types.NULL, Types.NULL};\r\n        rs = md.getIndexInfo(null, null, \"tblBestRow1\", true, true);        \r\n        assertRSMetaData(rs, colNames3, colTypes3);\r\n        assertTrue(rs.next());\r\n        assertEquals(\"Columnname:\", \"id1\", rs.getString(\"COLUMN_NAME\"));\r\n        assertFalse(rs.next());\r\n        \r\n        dropTable(con,\"tblBestRow1\");\r\n    }\r\n    \r\n    \r\n    public void testGetgetUDTs() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        DatabaseMetaData md = con.getMetaData();\r\n        ResultSet rs = md.getUDTs(null, null, null, null);\r\n        String[] colNames = {\"TYPE_CAT\", \"TYPE_SCHEM\", \"TYPE_NAME\", \"CLASS_NAME\", \"DATA_TYPE\", \"REMARKS\"};\r\n        int[] colTypes = new int[colNames.length];\r\n        assertRSMetaData( rs, colNames, colTypes);\r\n        assertFalse(rs.next());\r\n    }\r\n    \r\n    \r\n    public void testGetConnection() throws Exception{\r\n        Connection con = AllTests.getConnection();\r\n        DatabaseMetaData md = con.getMetaData();\r\n        assertEquals(con, md.getConnection());\r\n    }\r\n\r\n    \r\n}\r\n"},{"path":"/src/smallsql/junit/TestThreads.java","source":"/*\r\n * Created on 13.07.2008\r\n */\r\npackage smallsql.junit;\r\n\r\nimport java.sql.*;\r\nimport java.util.ArrayList;\r\n\r\n/**\r\n * Test some thread problems.\r\n * \r\n * @author Volker Berlin\r\n */\r\npublic class TestThreads extends BasicTestCase{\r\n\r\n    volatile Throwable throwable;\r\n\r\n\r\n    /**\r\n     * Test the concurrently read of a table\r\n     * \r\n     * @throws Throwable\r\n     *             if an thread problem occur\r\n     */\r\n    public void testConcurrentRead() throws Throwable{\r\n        ArrayList threadList = new ArrayList();\r\n        throwable = null;\r\n\r\n        // Any table from another test that include rows.\r\n        final String sql = \"Select * From table_OrderBy1\";\r\n\r\n        // calculate the row count of this table\r\n        final Connection con = AllTests.getConnection();\r\n        Statement st = con.createStatement();\r\n        ResultSet rs = st.executeQuery(\"Select * From table_OrderBy1\");\r\n        int count = 0;\r\n        while(rs.next()){\r\n            count++;\r\n        }\r\n        final int rowCount = count;\r\n\r\n        // start threads that check the row count\r\n        for(int i = 0; i < 200; i++){\r\n            Thread thread = new Thread(new Runnable(){\r\n\r\n                public void run(){\r\n                    try{\r\n                        assertRowCount(rowCount, sql);\r\n                    }catch(Throwable ex){\r\n                        throwable = ex;\r\n                    }\r\n                }\r\n\r\n            });\r\n            threadList.add(thread);\r\n            thread.start();\r\n        }\r\n\r\n        // wait until all threads are finish\r\n        for(int i = 0; i < threadList.size(); i++){\r\n            Thread thread = (Thread)threadList.get(i);\r\n            thread.join(5000);\r\n        }\r\n\r\n        // throw the exception if one occur\r\n        if(throwable != null){\r\n            throw throwable;\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Create a table with a single row. In different threads on the same connection a int value will be increment.\r\n     * \r\n     * @throws Throwable\r\n     *             if an thread problem occur\r\n     */\r\n    public void testConcurrentThreadWrite() throws Throwable{\r\n        ArrayList threadList = new ArrayList();\r\n        throwable = null;\r\n        final Connection con = AllTests.getConnection();\r\n        Statement st = con.createStatement();\r\n        try{\r\n            st.execute(\"CREATE TABLE ConcurrentWrite( value int)\");\r\n            st.execute(\"INSERT INTO ConcurrentWrite(value) Values(0)\");\r\n\r\n            // start threads that check the row count\r\n            for(int i = 0; i < 200; i++){\r\n                Thread thread = new Thread(new Runnable(){\r\n\r\n                    public void run(){\r\n                        try{\r\n                            Statement st2 = con.createStatement();\r\n                            int count = st2.executeUpdate(\"UPDATE ConcurrentWrite SET value = value + 1\");\r\n                            assertEquals(\"Update Count\", 1, count);\r\n                        }catch(Throwable ex){\r\n                            throwable = ex;\r\n                        }\r\n                    }\r\n\r\n                });\r\n                threadList.add(thread);\r\n                thread.start();\r\n            }\r\n\r\n            // wait until all threads are finish\r\n            for(int i = 0; i < threadList.size(); i++){\r\n                Thread thread = (Thread)threadList.get(i);\r\n                thread.join(5000);\r\n            }\r\n\r\n            // throw the exception if one occur\r\n            if(throwable != null){\r\n                throw throwable;\r\n            }\r\n\r\n            assertEqualsRsValue(new Integer(200), \"SELECT value FROM ConcurrentWrite\");\r\n        }finally{\r\n            dropTable(con, \"ConcurrentWrite\");\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Create a table with a single row. In different connections a int value will be increment.\r\n     * \r\n     * @throws Throwable\r\n     *             if an thread problem occur\r\n     */\r\n    public void testConcurrentConnectionWrite() throws Throwable{\r\n        ArrayList threadList = new ArrayList();\r\n        throwable = null;\r\n        Connection con = AllTests.getConnection();\r\n        Statement st = con.createStatement();\r\n        try{\r\n            st.execute(\"CREATE TABLE ConcurrentWrite( value int)\");\r\n            st.execute(\"INSERT INTO ConcurrentWrite(value) Values(0)\");\r\n\r\n            // start threads that check the row count\r\n            for(int i = 0; i < 200; i++){\r\n                Thread thread = new Thread(new Runnable(){\r\n\r\n                    public void run(){\r\n                        try{\r\n                            Connection con2 = AllTests.createConnection();\r\n                            Statement st2 = con2.createStatement();\r\n                            int count = st2.executeUpdate(\"UPDATE ConcurrentWrite SET value = value + 1\");\r\n                            assertEquals(\"Update Count\", 1, count);\r\n                            con2.close();\r\n                        }catch(Throwable ex){\r\n                            throwable = ex;\r\n                        }\r\n                    }\r\n\r\n                });\r\n                threadList.add(thread);\r\n                thread.start();\r\n            }\r\n\r\n            // wait until all threads are finish\r\n            for(int i = 0; i < threadList.size(); i++){\r\n                Thread thread = (Thread)threadList.get(i);\r\n                thread.join(5000);\r\n            }\r\n\r\n            // throw the exception if one occur\r\n            if(throwable != null){\r\n                throw throwable;\r\n            }\r\n\r\n            assertEqualsRsValue(new Integer(200), \"SELECT value FROM ConcurrentWrite\");\r\n        }finally{\r\n            dropTable(con, \"ConcurrentWrite\");\r\n        }\r\n    }\r\n\r\n}\r\n"},{"path":"/src/smallsql/database/Utils.java","source":"/* =============================================================\r\n * SmallSQL : a free Java DBMS library for the Java(tm) platform\r\n * =============================================================\r\n *\r\n * (C) Copyright 2004-2011, by Volker Berlin.\r\n *\r\n * Project Info:  http://www.smallsql.de/\r\n *\r\n * This library is free software; you can redistribute it and/or modify it \r\n * under the terms of the GNU Lesser General Public License as published by \r\n * the Free Software Foundation; either version 2.1 of the License, or \r\n * (at your option) any later version.\r\n *\r\n * This library is distributed in the hope that it will be useful, but \r\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \r\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public \r\n * License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, \r\n * USA.  \r\n *\r\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc. \r\n * in the United States and other countries.]\r\n *\r\n * ---------------\r\n * Utils.java\r\n * ---------------\r\n * Author: Volker Berlin\r\n * \r\n */\r\npackage smallsql.database;\r\n\r\nimport java.io.File;\r\nimport java.io.FileNotFoundException;\r\nimport java.io.RandomAccessFile;\r\nimport java.nio.channels.FileChannel;\r\nimport java.nio.channels.FileLock;\r\nimport java.sql.SQLException;\r\nimport smallsql.database.language.Language;\r\n\r\nclass Utils {\r\n\r\n\tstatic final String MASTER_FILENAME = \"smallsql.master\";\r\n\tstatic final String TABLE_VIEW_EXTENTION = \".sdb\";\r\n\tprivate static final String LOB_EXTENTION = \".lob\";\r\n\tstatic final String IDX_EXTENTION = \".idx\";\r\n\tprivate static final Integer[] integerCache = new Integer[260];\r\n\tprivate static final Short[]   shortCache   = new Short[260];\r\n\t\r\n\tstatic{\r\n\t\tfor(int i=-4; i<256; i++){\r\n\t\t\tintegerCache[ i+4 ] = new Integer(i);\r\n\t\t\tshortCache  [ i+4 ] = new Short((short)i);\r\n\t\t}\r\n\t}\r\n    \r\n    static String createTableViewFileName(Database database, String name){\r\n        return database.getName() + '/' + name + TABLE_VIEW_EXTENTION;\r\n    }\r\n\r\n\tstatic String createLobFileName(Database database, String name){\r\n\t\treturn database.getName() + '/' + name + LOB_EXTENTION;\r\n\t}\r\n\r\n\tstatic String createIdxFileName(Database database, String name){\r\n\t\treturn database.getName() + '/' + name + IDX_EXTENTION;\r\n\t}\r\n\r\n\tstatic boolean like(String value, String pattern){\r\n\t\tif(value == null || pattern == null) return false;\r\n\t\tif(pattern.length() == 0) return true;\r\n\r\n\t\tint mIdx = 0;//index in mask Array\r\n\t\tint sIdx = 0;//index in search Array\r\n\t\tboolean range = false;\r\n\t\tweiter:\r\n\t\twhile(pattern.length() > mIdx && value.length() > sIdx) {\r\n\t\t\tchar m = Character.toUpperCase(pattern.charAt(mIdx++));\r\n\t\t\tswitch(m) {\r\n\t\t\t\tcase '%':\r\n\t\t\t\t\trange = true;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase '_':\r\n\t\t\t\t\tsIdx++;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tif(range) {//% wildcard is active\r\n\t\t\t\t\t\tfor(; sIdx < value.length(); sIdx++) {\r\n\t\t\t\t\t\t\tif(Character.toUpperCase(value.charAt(sIdx)) == m) break;//Counter mustn't increment before break\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif(sIdx >= value.length()) return false;\r\n\t\t\t\t\t\tint lastmIdx = mIdx - 1;\r\n\t\t\t\t\t\tsIdx++;\r\n\t\t\t\t\t\twhile(pattern.length() > mIdx && value.length() > sIdx) {\r\n\t\t\t\t\t\t\tm = Character.toUpperCase(pattern.charAt(mIdx++));\r\n\t\t\t\t\t\t\tif(Character.toUpperCase(value.charAt(sIdx)) != m) {\r\n\t\t\t\t\t\t\t\tif(m == '%' || m == '_') {\r\n\t\t\t\t\t\t\t\t\tmIdx--;\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tmIdx = lastmIdx;\r\n\t\t\t\t\t\t\t\tcontinue weiter;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tsIdx++;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\trange = false;\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tif(Character.toUpperCase(value.charAt(sIdx)) != m) return false;\r\n\t\t\t\t\t\tsIdx++;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\twhile(pattern.length() > mIdx) {\r\n            //Search mask is not too ends yet it may only '%' be contained \r\n\t\t\tif(Character.toUpperCase(pattern.charAt(mIdx++)) != '%') return false;\r\n\t\t}\r\n\t\twhile(value.length() > sIdx && !range) return false;\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\t\r\n\tstatic int long2int(long value){\r\n\t\tif(value > Integer.MAX_VALUE)\r\n\t\t\treturn Integer.MAX_VALUE;\r\n\t\tif(value < Integer.MIN_VALUE)\r\n\t\t\treturn Integer.MIN_VALUE;\r\n\t\treturn (int)value;\r\n\t}\r\n\t\r\n\tstatic long double2long(double value){\r\n\t\tif(value > Long.MAX_VALUE)\r\n\t\t\treturn Long.MAX_VALUE;\r\n\t\tif(value < Long.MIN_VALUE)\r\n\t\t\treturn Long.MIN_VALUE;\r\n\t\treturn (long)value;\r\n\t}\r\n\r\n\r\n\r\n    static float bytes2float( byte[] bytes ){\r\n        return Float.intBitsToFloat( bytes2int( bytes ) );\r\n    }\r\n\r\n    static double bytes2double( byte[] bytes ){\r\n        return Double.longBitsToDouble( bytes2long( bytes ) );\r\n    }\r\n\r\n    static long bytes2long( byte[] bytes ){\r\n        long result = 0;\r\n        int length = Math.min( 8, bytes.length);\r\n        for(int i=0; i<length; i++){\r\n            result = (result << 8) | (bytes[i] & 0xFF);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    static int bytes2int( byte[] bytes ){\r\n        int result = 0;\r\n        int length = Math.min( 4, bytes.length);\r\n        for(int i=0; i<length; i++){\r\n            result = (result << 8) | (bytes[i] & 0xFF);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    static byte[] double2bytes( double value ){\r\n        return long2bytes(Double.doubleToLongBits(value));\r\n    }\r\n\r\n    static byte[] float2bytes( float value ){\r\n        return int2bytes(Float.floatToIntBits(value));\r\n    }\r\n\r\n    static byte[] long2bytes( long value ){\r\n        byte[] result = new byte[8];\r\n        result[0] = (byte)(value >> 56);\r\n        result[1] = (byte)(value >> 48);\r\n        result[2] = (byte)(value >> 40);\r\n        result[3] = (byte)(value >> 32);\r\n        result[4] = (byte)(value >> 24);\r\n        result[5] = (byte)(value >> 16);\r\n        result[6] = (byte)(value >> 8);\r\n        result[7] = (byte)(value);\r\n        return result;\r\n    }\r\n    \r\n    static int money2int( long value ) {\r\n\t\tif (value < Integer.MIN_VALUE) return Integer.MIN_VALUE;\r\n\t\telse if (value > Integer.MAX_VALUE) return Integer.MAX_VALUE;\r\n\t\telse return (int) value;\r\n\t}\r\n\r\n\tstatic byte[] int2bytes( int value ){\r\n\t\tbyte[] result = new byte[4];\r\n\t\tresult[0] = (byte)(value >> 24);\r\n\t\tresult[1] = (byte)(value >> 16);\r\n\t\tresult[2] = (byte)(value >> 8);\r\n\t\tresult[3] = (byte)(value);\r\n\t\treturn result;\r\n\t}\r\n\r\n    static String bytes2hex( byte[] bytes ){\r\n        StringBuffer buf = new StringBuffer(bytes.length << 1);\r\n        for(int i=0; i<bytes.length; i++){\r\n            buf.append( digits[ (bytes[i] >> 4) & 0x0F ] );\r\n            buf.append( digits[ (bytes[i]     ) & 0x0F ] );\r\n        }\r\n        return buf.toString();\r\n    }\r\n\r\n    static byte[] hex2bytes( char[] hex, int offset, int length) throws SQLException{\r\n        try{\r\n            byte[] bytes = new byte[length / 2];\r\n            for(int i=0; i<bytes.length; i++){\r\n                bytes[i] = (byte)((hexDigit2int( hex[ offset++ ] ) << 4)\r\n                                | hexDigit2int( hex[ offset++ ] ));\r\n            }\r\n            return bytes;\r\n        }catch(Exception e){\r\n             throw SmallSQLException.create(Language.SEQUENCE_HEX_INVALID, String.valueOf(offset)); /*, offset*/\r\n        }\r\n    }\r\n\r\n    private static int hexDigit2int(char digit){\r\n        if(digit >= '0' && digit <= '9') return digit - '0';\r\n        digit |= 0x20;\r\n        if(digit >= 'a' && digit <= 'f') return digit - 'W'; // -'W'  ==  -'a' + 10\r\n        throw new RuntimeException();\r\n    }\r\n\r\n    static byte[] unique2bytes( String unique ) throws SQLException{\r\n        char[] chars = unique.toCharArray();\r\n        byte[] daten = new byte[16];\r\n        daten[3] = hex2byte( chars, 0 );\r\n        daten[2] = hex2byte( chars, 2 );\r\n        daten[1] = hex2byte( chars, 4 );\r\n        daten[0] = hex2byte( chars, 6 );\r\n\r\n        daten[5] = hex2byte( chars, 9 );\r\n        daten[4] = hex2byte( chars, 11 );\r\n\r\n        daten[7] = hex2byte( chars, 14 );\r\n        daten[6] = hex2byte( chars, 16 );\r\n\r\n        daten[8] = hex2byte( chars, 19 );\r\n        daten[9] = hex2byte( chars, 21 );\r\n\r\n        daten[10] = hex2byte( chars, 24 );\r\n        daten[11] = hex2byte( chars, 26 );\r\n        daten[12] = hex2byte( chars, 28 );\r\n        daten[13] = hex2byte( chars, 30 );\r\n        daten[14] = hex2byte( chars, 32 );\r\n        daten[15] = hex2byte( chars, 34 );\r\n        return daten;\r\n    }\r\n\r\n    private static byte hex2byte( char[] hex, int offset) throws SQLException{\r\n        try{\r\n                return (byte)((hexDigit2int( hex[ offset++ ] ) << 4)\r\n                                | hexDigit2int( hex[ offset++ ] ));\r\n        }catch(Exception e){\r\n             throw SmallSQLException.create(Language.SEQUENCE_HEX_INVALID_STR, new Object[] { new Integer(offset), new String(hex) });\r\n        }\r\n    }\r\n\r\n    static String bytes2unique( byte[] daten, int offset ){\r\n    \tif(daten.length-offset < 16){\r\n    \t\tbyte[] temp = new byte[16];\r\n    \t\tSystem.arraycopy(daten, offset, temp, 0, daten.length-offset);\r\n    \t\tdaten = temp;\r\n    \t}\r\n        char[] chars = new char[36];\r\n        chars[8] = chars[13] = chars[18] = chars[23] = '-';\r\n\r\n        chars[0] = digits[ (daten[offset+3] >> 4) & 0x0F ];\r\n        chars[1] = digits[ (daten[offset+3]     ) & 0x0F ];\r\n        chars[2] = digits[ (daten[offset+2] >> 4) & 0x0F ];\r\n        chars[3] = digits[ (daten[offset+2]     ) & 0x0F ];\r\n        chars[4] = digits[ (daten[offset+1] >> 4) & 0x0F ];\r\n        chars[5] = digits[ (daten[offset+1]     ) & 0x0F ];\r\n        chars[6] = digits[ (daten[offset+0] >> 4) & 0x0F ];\r\n        chars[7] = digits[ (daten[offset+0]     ) & 0x0F ];\r\n\r\n        chars[ 9] = digits[ (daten[offset+5] >> 4) & 0x0F ];\r\n        chars[10] = digits[ (daten[offset+5]     ) & 0x0F ];\r\n        chars[11] = digits[ (daten[offset+4] >> 4) & 0x0F ];\r\n        chars[12] = digits[ (daten[offset+4]     ) & 0x0F ];\r\n\r\n        chars[14] = digits[ (daten[offset+7] >> 4) & 0x0F ];\r\n        chars[15] = digits[ (daten[offset+7]     ) & 0x0F ];\r\n        chars[16] = digits[ (daten[offset+6] >> 4) & 0x0F ];\r\n        chars[17] = digits[ (daten[offset+6]     ) & 0x0F ];\r\n\r\n        chars[19] = digits[ (daten[offset+8] >> 4) & 0x0F ];\r\n        chars[20] = digits[ (daten[offset+8]     ) & 0x0F ];\r\n        chars[21] = digits[ (daten[offset+9] >> 4) & 0x0F ];\r\n        chars[22] = digits[ (daten[offset+9]     ) & 0x0F ];\r\n\r\n        chars[24] = digits[ (daten[offset+10] >> 4) & 0x0F ];\r\n        chars[25] = digits[ (daten[offset+10]     ) & 0x0F ];\r\n        chars[26] = digits[ (daten[offset+11] >> 4) & 0x0F ];\r\n        chars[27] = digits[ (daten[offset+11]     ) & 0x0F ];\r\n        chars[28] = digits[ (daten[offset+12] >> 4) & 0x0F ];\r\n        chars[29] = digits[ (daten[offset+12]     ) & 0x0F ];\r\n        chars[30] = digits[ (daten[offset+13] >> 4) & 0x0F ];\r\n        chars[31] = digits[ (daten[offset+13]     ) & 0x0F ];\r\n        chars[32] = digits[ (daten[offset+14] >> 4) & 0x0F ];\r\n        chars[33] = digits[ (daten[offset+14]     ) & 0x0F ];\r\n        chars[34] = digits[ (daten[offset+15] >> 4) & 0x0F ];\r\n        chars[35] = digits[ (daten[offset+15]     ) & 0x0F ];\r\n        return new String(chars);\r\n    }\r\n\r\n    static boolean string2boolean( String val){\r\n        try{\r\n            return Double.parseDouble( val ) != 0;\r\n        }catch(NumberFormatException e){/*ignore it if it not a number*/}\r\n        return \"true\".equalsIgnoreCase( val ) || \"yes\".equalsIgnoreCase( val ) || \"t\".equalsIgnoreCase( val );\r\n    }\r\n\t\r\n\t\r\n\tstatic long doubleToMoney(double value){\r\n\t\tif(value < 0)\r\n\t\t\treturn (long)(value * 10000 - 0.5);\r\n\t\treturn (long)(value * 10000 + 0.5);\r\n\t}\r\n\r\n    static int indexOf( char value, char[] str, int offset, int length ){\r\n        value |= 0x20;\r\n        for(int end = offset+length;offset < end; offset++){\r\n            if((str[offset] | 0x20) == value) return offset;\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    static int indexOf( int value, int[] list ){\r\n        int offset = 0;\r\n        for(int end = list.length; offset < end; offset++){\r\n            if((list[offset]) == value) return offset;\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    static int indexOf( byte[] value, byte[] list, int offset ){\r\n        int length = value.length;\r\n        loop1:\r\n        for(int end = list.length-length; offset <= end; offset++){\r\n            for(int i=0; i<length; i++ ){\r\n                if(list[offset+i] != value[i]){\r\n                    continue loop1;\r\n                }\r\n            }\r\n            return offset;\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    static int compareBytes( byte[] leftBytes, byte[] rightBytes){\r\n        int length = Math.min( leftBytes.length, rightBytes.length );\r\n        int comp = 0;\r\n        for(int i=0; i<length; i++){\r\n            if(leftBytes[i] != rightBytes[i]){\r\n                comp = leftBytes[i] < rightBytes[i] ? -1 : 1;\r\n                break;\r\n            }\r\n        }\r\n        if(comp == 0 && leftBytes.length != rightBytes.length){\r\n            comp = leftBytes.length < rightBytes.length ? -1 : 1;\r\n        }\r\n        return comp;\r\n    }\r\n\t\r\n    \r\n    /**\r\n     * \r\n     * @param colNames\r\n     * @param data\r\n     * @return\r\n     * @throws SQLException\r\n     */\r\n    static CommandSelect createMemoryCommandSelect( SSConnection con, String[] colNames, Object[][] data) throws SQLException{\r\n\t\tMemoryResult source = new MemoryResult(data, colNames.length);\r\n\t\tCommandSelect cmd = new CommandSelect(con.log);\r\n\t\tfor(int i=0; i<colNames.length; i++){\r\n\t\t\tExpressionName expr = new ExpressionName(colNames[i]);\r\n\t\t\tcmd.addColumnExpression( expr );\r\n\t\t\texpr.setFrom( source, i, source.getColumn(i));\r\n\t\t}\r\n\t\tcmd.setSource(source);\r\n\t\treturn cmd;\r\n    }\r\n\t\r\n\r\n\t/**\r\n     *  recycle Integer objects, this is faster as to garbage the objects\r\n\t */\r\n\tstatic final Integer getInteger(int value){\r\n\t\tif(value >= -4 && value < 256){\r\n\t\t\treturn integerCache[ value+4 ];\t\t\r\n\t\t}else\r\n\t\t\treturn new Integer(value);\r\n\t}\r\n\t\r\n\t/**\r\n     * recycle Integer objects, this is faster as to garbage the objects\r\n\t */\r\n\tstatic final Short getShort(int value){\r\n\t\tif(value >= -4 && value < 256){\r\n\t\t\treturn shortCache[ value+4 ];\t\t\r\n\t\t}else\r\n\t\t\treturn new Short((short)value);\r\n\t}\r\n    \r\n    \r\n    /**\r\n     * Open a RandomAccessFile and lock it that no other thread or VM can open it..\r\n     * \r\n     * @param file\r\n     *            The file that should be open.\r\n     * @return a FileChannel\r\n     * @throws FileNotFoundException\r\n     *             If the file can not open\r\n     * @param readonly open database in read only mode\r\n     * @throws SQLException\r\n     *             If the file can't lock.\r\n     */\r\n    static final FileChannel openRaFile( File file, boolean readonly ) throws FileNotFoundException, SQLException{\r\n        RandomAccessFile raFile = new RandomAccessFile(file, readonly ? \"r\" : \"rw\" );\r\n        FileChannel channel = raFile.getChannel();\r\n        if( !readonly ){\r\n            try{\r\n                FileLock lock = channel.tryLock();\r\n                if(lock == null){\r\n                    throw SmallSQLException.create(Language.CANT_LOCK_FILE, file);\r\n                }\r\n            }catch(SQLException sqlex){\r\n                throw sqlex;\r\n            }catch(Throwable th){\r\n                throw SmallSQLException.createFromException(Language.CANT_LOCK_FILE, file, th);\r\n            }\r\n        }\r\n        return channel;\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Get all the ExpressionName objects that are part of the tree.\r\n     * If it only a constant expression then a empty list is return.\r\n     * @param tree the expression to scan\r\n     * @return the list of ExpressionName instances\r\n     */\r\n    static final Expressions getExpressionNameFromTree(Expression tree){\r\n        Expressions list = new Expressions();\r\n        getExpressionNameFromTree( list, tree );\r\n        return list;\r\n    }\r\n    \r\n    /**\r\n     * Scan the tree recursively.\r\n     */\r\n    private static final void getExpressionNameFromTree(Expressions list, Expression tree){\r\n        if(tree.getType() == Expression.NAME ){\r\n            list.add(tree);\r\n        }\r\n        Expression[] params = tree.getParams();\r\n        if(params != null){\r\n            for(int i=0; i<params.length; i++){\r\n                getExpressionNameFromTree( list, tree );\r\n            }\r\n        }\r\n    }\r\n\r\n    final static char[] digits = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};\r\n}"},{"path":"/src/smallsql/junit/BenchTest.java","source":"/* =============================================================\r\n * SmallSQL : a free Java DBMS library for the Java(tm) platform\r\n * =============================================================\r\n *\r\n * (C) Copyright 2004-2006, by Volker Berlin.\r\n *\r\n * Project Info:  http://www.smallsql.de/\r\n *\r\n * This library is free software; you can redistribute it and/or modify it \r\n * under the terms of the GNU Lesser General Public License as published by \r\n * the Free Software Foundation; either version 2.1 of the License, or \r\n * (at your option) any later version.\r\n *\r\n * This library is distributed in the hope that it will be useful, but \r\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \r\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public \r\n * License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, \r\n * USA.  \r\n *\r\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc. \r\n * in the United States and other countries.]\r\n *\r\n * ---------------\r\n * BenchTest.java\r\n * ---------------\r\n * Author: Volker Berlin\r\n * \r\n */\r\npackage smallsql.junit;\r\n\r\nimport java.sql.*;\r\n\r\npublic class BenchTest\r\n{\r\n    static byte[] byteArray = {23, 34, 67 };\r\n    static byte[] largeByteArray = new byte[4000];\r\n    \r\n    static String driverClassName = \"smallsql.database.SSDriver\";\r\n    static String userName        = \"sa\";\r\n    static String password        = \"\";\r\n    static String jdbcUrl         = \"jdbc:smallsql:AllTests\";\r\n    static int    rowCount        = 10000;\r\n    \r\n    static Connection con;\r\n    static final String tableName = \"BenchTest2\";\r\n        \r\n    \r\n    public static void main(String[] args) throws SQLException{\r\n        for(int i=0; i<args.length;){\r\n            String option = args[i++];\r\n            if      (option.equals(\"-driver\")  ) driverClassName = args[i++];\r\n            else if (option.equals(\"-user\")    ) userName = args[i++];\r\n            else if (option.equals(\"-password\")) password = args[i++];\r\n            else if (option.equals(\"-url\")     ) jdbcUrl  = args[i++];\r\n            else if (option.equals(\"-rowcount\")) rowCount = Integer.parseInt(args[i++]);\r\n            else if (option.equals(\"-?\") | option.equals(\"-help\")){\r\n                System.out.println( \"Valid options are :\\n\\t-driver\\n\\t-url\\n\\t-user\\n\\t-password\\n\\t-rowcount\");\r\n                System.exit(0);\r\n            }\r\n            else {System.out.println(\"Option \" + option + \" is ignored\");i++;}\r\n        }\r\n        System.out.println( \"Driver:  \\t\" + driverClassName);\r\n        System.out.println( \"Username:\\t\" + userName);\r\n        System.out.println( \"Password:\\t\" + password);\r\n        System.out.println( \"JDBC URL:\\t\" + jdbcUrl);\r\n        System.out.println( \"Row Count:\\t\" + rowCount);\r\n        System.out.println();\r\n        try{\r\n            Class.forName(driverClassName).newInstance();\r\n            con = DriverManager.getConnection( jdbcUrl, userName,password);\r\n            System.out.println( con.getMetaData().getDriverName() + \" \" + con.getMetaData().getDriverVersion());\r\n            System.out.println();\r\n            createTestTable( con );\r\n            test_InsertClassic( con );\r\n            test_DeleteAll( con );\r\n            test_InsertEmptyRows( con );\r\n            test_DeleteRows( con );\r\n            test_InsertRows( con );\r\n            test_RowRequestPages( con );\r\n            test_UpdateRows( con );\r\n            test_UpdateRowsPrepare( con );\r\n            test_UpdateRowsPrepareSP( con );\r\n            test_UpdateRowsPrepareBatch( con );\r\n            test_Scroll_getXXX( con );\r\n            test_UpdateLargeBinary( con );\r\n            test_UpdateLargeBinaryWithSP( con );\r\n        }catch(Exception e){\r\n            e.printStackTrace();\r\n        }finally{\r\n            if (con != null){\r\n                //dropTestTable( con );\r\n                con.close();\r\n            }\r\n        }\r\n    }\r\n    \r\n    \r\n    \r\n    /**\r\n      *  1. Test\r\n      *  Insert rows with default values with a classic insert statement.\r\n      */  \r\n    static void test_InsertClassic(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test insert rows with default values with a classic insert statement: \" + rowCount + \" rows\");\r\n        \r\n        try{\r\n            Statement st = con.createStatement( ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE );\r\n            long time = -System.currentTimeMillis();\r\n            for (int i=0; i<rowCount; i++){\r\n                st.execute(\"INSERT INTO \" + tableName + \"(i) VALUES(\" + i +\")\");\r\n            }\r\n            time += System.currentTimeMillis();\r\n            ResultSet rs = st.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n            rs.next();\r\n            int count = rs.getInt(1);\r\n            if (count != rowCount)\r\n                System.out.println( \"  Failed: Only \" + count + \" rows were inserted.\");\r\n            else System.out.println( \"  Test time: \" + time + \" ms\");\r\n            st.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }\r\n    \r\n    \r\n    \r\n    /**\r\n      *  2. Test\r\n      *  Delete all rows with a single statement.\r\n      */  \r\n    static void test_DeleteAll(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test delete all rows: \" + rowCount + \" rows\");\r\n        \r\n        try{\r\n            long time = -System.currentTimeMillis();\r\n            Statement st = con.createStatement();\r\n            st.execute(\"DELETE FROM \" + tableName);\r\n            time += System.currentTimeMillis();\r\n            System.out.println( \"  Test time: \" + time + \" ms\");\r\n            st.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }\r\n    \r\n    \r\n    \r\n    /**\r\n      *  3. Test\r\n      *  Insert only empty rows with the default values of the row with the method insertRow().\r\n      */  \r\n    static void test_InsertEmptyRows(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test insert empty rows with insertRow(): \" + rowCount + \" rows\");\r\n        \r\n        try{\r\n            Statement st = con.createStatement( ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE );\r\n            ResultSet rs = st.executeQuery(\"SELECT * FROM \"+tableName);\r\n            long time = -System.currentTimeMillis();\r\n            for (int i=0; i<rowCount; i++){\r\n                rs.moveToInsertRow();\r\n                rs.insertRow();\r\n            }\r\n            time += System.currentTimeMillis();\r\n            rs = st.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n            rs.next();\r\n            int count = rs.getInt(1);\r\n            if (count != rowCount)\r\n                 System.out.println( \"  Failed: Only \" + count + \" rows were inserted.\");\r\n            else System.out.println( \"  Test time: \" + time + \" ms\");\r\n            st.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }\r\n    \r\n    \r\n    \r\n    /**\r\n      *  4. Test\r\n      *  Delete rows with the method deleteRow().\r\n      */  \r\n    static void test_DeleteRows(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test delete rows with deleteRow(): \" + rowCount + \" rows\");\r\n        \r\n        try{\r\n            Statement st1 = con.createStatement();\r\n            ResultSet rs = st1.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n            rs.next();\r\n            int count = rs.getInt(1);\r\n            if (count != rowCount){\r\n                // There are not the correct count of rows.\r\n                if (count == 0){\r\n                    createTestDataWithClassicInsert( con );\r\n                    rs = st1.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n                    rs.next();\r\n                    count = rs.getInt(1);\r\n                }\r\n                if (count != rowCount){\r\n                    System.out.println( \"  Failed: Only \" + (rowCount-count) + \" rows were deleted.\");\r\n                    return;\r\n                }\r\n            }\r\n            st1.close();\r\n            \r\n            Statement st = con.createStatement( ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE );\r\n            rs = st.executeQuery(\"SELECT * FROM \"+tableName);\r\n            long time = -System.currentTimeMillis();\r\n            for (int i=0; i<rowCount; i++){\r\n                rs.next();\r\n                rs.deleteRow();\r\n            }\r\n            time += System.currentTimeMillis();\r\n            rs = st.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n            rs.next();\r\n            count = rs.getInt(1);\r\n            if (count != 0)\r\n                 System.out.println( \"  Failed: Only \" + (rowCount-count) + \" rows were deleted.\");\r\n            else System.out.println( \"  Test time: \" + time + \" ms\");\r\n            st.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }\r\n    \r\n    \r\n    \r\n    /**\r\n      *  5. Test\r\n      *  Insert rows with the method insertRow().\r\n      */  \r\n    static void test_InsertRows(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test insert rows with insertRow(): \" + rowCount + \" rows\");\r\n        \r\n        try{\r\n            Statement st = con.createStatement( ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE );\r\n            ResultSet rs = st.executeQuery(\"SELECT * FROM \" + tableName);\r\n            long time = -System.currentTimeMillis();\r\n            for (int i=0; i<rowCount; i++){\r\n                rs.moveToInsertRow();\r\n\t            rs.updateBytes (  \"bi\", byteArray );\r\n\t            rs.updateString(  \"c\" , \"Test\" );\r\n\t            rs.updateDate  (  \"d\" , new Date( System.currentTimeMillis() ) );\r\n\t            rs.updateFloat (  \"de\", (float)1234.56789 );\r\n\t            rs.updateFloat (  \"f\" , (float)9876.54321 );\r\n\t            rs.updateBytes (  \"im\", largeByteArray );\r\n\t            rs.updateInt   (  \"i\" , i );\r\n\t            rs.updateDouble(  \"m\" , 23.45 );\r\n\t            rs.updateDouble(  \"n\" , 567.45 );\r\n\t            rs.updateFloat (  \"r\" , (float)78.89 );\r\n\t            rs.updateTime  (  \"sd\", new Time( System.currentTimeMillis() ) );\r\n\t            rs.updateShort (  \"si\", (short)i );\r\n\t            rs.updateFloat (  \"sm\", (float)34.56 );\r\n\t            rs.updateString(  \"sy\", \"sysname (30) NULL\" );\r\n\t            rs.updateString(  \"t\" , \"ntext NULL, sample to save in the field\" );\r\n\t            rs.updateByte  (  \"ti\", (byte)i );\r\n\t            rs.updateBytes (  \"vb\", byteArray );\r\n\t            rs.updateString(  \"vc\", \"nvarchar (255) NULL\" );\r\n                rs.insertRow();\r\n            }\r\n            time += System.currentTimeMillis();\r\n            rs = st.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n            rs.next();\r\n            int count = rs.getInt(1);\r\n            if (count != rowCount){\r\n                  st.execute(\"DELETE FROM \" + tableName);\r\n                  System.out.println( \"  Failed: Only \" + count + \" rows were inserted.\");\r\n            }else System.out.println( \"  Test time: \" + time + \" ms\");\r\n            st.close();\r\n        }catch(Exception e){\r\n        \te.printStackTrace();\r\n            try{\r\n                // reset for the next test\r\n                Statement st = con.createStatement();\r\n                st.execute(\"DELETE FROM \" + tableName);\r\n                st.close();\r\n            }catch(Exception ee){/* ignore it */}\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }\r\n    \r\n    \r\n    \r\n    /**\r\n      *  6. Test\r\n      *  Request one page of rows from a large ResultSet.\r\n      */  \r\n    static void test_RowRequestPages(Connection con){\r\n        int pages = 100; \r\n        int rows  = rowCount / pages;\r\n        System.out.println();\r\n        System.out.println( \"Test request row pages : \" + pages + \" pages, \" +rows + \" rows per page\");\r\n        try{\r\n            Statement st1 = con.createStatement();\r\n            ResultSet rs = st1.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n            rs.next();\r\n            int count = rs.getInt(1);\r\n            if (count != rowCount){\r\n                // There are not the correct count of rows.\r\n                if (count == 0){\r\n                    createTestDataWithClassicInsert( con );\r\n                    rs = st1.executeQuery( \"SELECT count(*) FROM \" + tableName);\r\n                    rs.next();\r\n                    count = rs.getInt(1);\r\n                }\r\n                if (count != rowCount){\r\n                    System.out.println( \"  Failed: Only \" + (rowCount-count) + \" rows were found.\");\r\n                    return;\r\n                }\r\n            }\r\n            st1.close();\r\n            \r\n            long time = -System.currentTimeMillis();\r\n            Statement st = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_READ_ONLY);\r\n            st.setFetchSize( rows );\r\n            for (int i=0; i<pages; i++){\r\n                rs = st.executeQuery(\"SELECT * FROM \" + tableName);\r\n                rs.absolute( i*rows+1 );\r\n                for (int r=1; r<rows; r++){\r\n                    // only (rows-1) rows because absolute has already the first row\r\n                    if (!rs.next()){\r\n                        System.out.println( \"  Failed: No rows were found at page \" + i + \" page and row \" + r);\r\n                        return;\r\n                    }\r\n                    int col_i = rs.getInt(\"i\");\r\n                    if (col_i != (i*rows+r)){\r\n                        System.out.println( \"  Failed: Wrong row \" + col_i + \", it should be row \" + (i*rows+r));\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n            time += System.currentTimeMillis();\r\n            System.out.println( \"  Test time: \" + time + \" ms\");\r\n            st.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }\r\n\r\n    \r\n    \r\n    /**\r\n      *  7. Test\r\n      *  Update rows with the method updateRow().\r\n      */  \r\n    static void test_UpdateRows(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test update rows with updateRow(): \" + rowCount + \" rows\");\r\n        \r\n        try{\r\n            Statement st = con.createStatement( ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE );\r\n            ResultSet rs = st.executeQuery(\"SELECT * FROM \" + tableName);\r\n            int colCount = rs.getMetaData().getColumnCount();\r\n            long time = -System.currentTimeMillis();\r\n            int count = 0;\r\n            while(rs.next()){\r\n                for (int i=2; i<=colCount; i++){\r\n                    rs.updateObject( i, rs.getObject(i) );\r\n                }\r\n                rs.updateRow();\r\n                count++;\r\n            }\r\n            time += System.currentTimeMillis();\r\n            if (count != rowCount)\r\n                 System.out.println( \"  Failed: Only \" + count + \" rows were updated.\");\r\n            else System.out.println( \"  Test time: \" + time + \" ms\");\r\n            st.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\" + e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }\r\n    \r\n    \r\n    \r\n    /**\r\n      *  8. Test\r\n      *  Update rows with a PreparedStatement.\r\n      */  \r\n    static void test_UpdateRowsPrepare(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test update rows with a PreparedStatement: \" + rowCount + \" rows\");\r\n        try{\r\n            PreparedStatement pr = con.prepareStatement( \"UPDATE \" + tableName + \" SET bi=?,c=?,d=?,de=?,f=?,im=?,i=?,m=?,n=?,r=?,sd=?,si=?,sm=?,sy=?,t=?,ti=?,vb=?,vc=? WHERE i=?\" );\r\n            long time = -System.currentTimeMillis();\r\n            for (int i=0; i<rowCount; i++){\r\n\t            pr.setBytes (  1, byteArray );\r\n\t            pr.setString(  2 , \"Test\" );\r\n\t            pr.setDate  (  3 , new Date( System.currentTimeMillis() ) );\r\n\t            pr.setFloat (  4, (float)1234.56789 );\r\n\t            pr.setFloat (  5 , (float)9876.54321 );\r\n\t            pr.setBytes (  6, largeByteArray );\r\n\t            pr.setInt   (  7 , i );\r\n\t            pr.setDouble(  8 , 23.45 );\r\n\t            pr.setDouble(  9 , 567.45 );\r\n\t            pr.setFloat (  10 , (float)78.89 );\r\n\t            pr.setTime  (  11, new Time( System.currentTimeMillis() ) );\r\n\t            pr.setShort (  12, (short)23456 );\r\n\t            pr.setFloat (  13, (float)34.56 );\r\n\t            pr.setString(  14, \"sysname (30) NULL\" );\r\n\t            pr.setString(  15 , \"text NULL\" );\r\n\t            pr.setByte  (  16, (byte)28 );\r\n\t            pr.setBytes (  17, byteArray );\r\n\t            pr.setString(  18, \"varchar (255) NULL\" );\r\n\t            pr.setInt   (  19 , i );\r\n                int updateCount = pr.executeUpdate();\r\n                if (updateCount != 1){\r\n                    System.out.println( \"  Failed: Update count should be 1 but it is \" + updateCount + \".\");\r\n                    return;\r\n                }\r\n            }\r\n            time += System.currentTimeMillis();\r\n            System.out.println( \"  Test time: \" + time + \" ms\");\r\n            pr.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }\r\n    \r\n    \r\n    \r\n    /**\r\n      *  9. Test\r\n      *  Update rows with a PreparedStatement and a stored procedure.\r\n      */  \r\n    static void test_UpdateRowsPrepareSP(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test update rows with a PreparedStatement and a stored procedure: \" + rowCount + \" rows\");\r\n        \r\n        try{\r\n            Statement st = con.createStatement();\r\n            try{st.execute(\"drop procedure sp_\"+tableName);}catch(Exception e){/* ignore it */}\r\n            st.execute(\"create procedure sp_\"+tableName+\" (@bi binary,@c nchar(255),@d datetime,@de decimal,@f float,@im image,@i int,@m money,@n numeric(18, 0),@r real,@sd smalldatetime,@si smallint,@sm smallmoney,@sy sysname,@t ntext,@ti tinyint,@vb varbinary(255),@vc nvarchar(255)) as UPDATE \" + tableName + \" SET bi=@bi,c=@c,d=@d,de=@de,f=@f,im=@im,i=@i,m=@m,n=@n,r=@r,sd=@sd,si=@si,sm=@sm,sy=@sy,t=@t,ti=@ti,vb=@vb,vc=@vc WHERE i=@i\");\r\n\r\n            PreparedStatement pr = con.prepareStatement( \"exec sp_\" + tableName + \" ?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?\" );\r\n            long time = -System.currentTimeMillis();\r\n            for (int i=0; i<rowCount; i++){\r\n\t            pr.setBytes (  1, byteArray );\r\n\t            pr.setString(  2 , \"Test\" );\r\n\t            pr.setDate  (  3 , new Date( System.currentTimeMillis() ) );\r\n\t            pr.setFloat (  4, (float)1234.56789 );\r\n\t            pr.setFloat (  5 , (float)9876.54321 );\r\n\t            pr.setBytes (  6, largeByteArray );\r\n\t            pr.setInt   (  7 , i );\r\n\t            pr.setDouble(  8 , 23.45 );\r\n\t            pr.setDouble(  9 , 567.45 );\r\n\t            pr.setFloat (  10 , (float)78.89 );\r\n\t            pr.setTime  (  11, new Time( System.currentTimeMillis() ) );\r\n\t            pr.setShort (  12, (short)23456 );\r\n\t            pr.setFloat (  13, (float)34.56 );\r\n\t            pr.setString(  14, \"sysname (30) NULL\" );\r\n\t            pr.setString(  15 , \"text NULL\" );\r\n\t            pr.setByte  (  16, (byte)28 );\r\n\t            pr.setBytes (  17, byteArray );\r\n\t            pr.setString(  18, \"varchar (255) NULL\" );\r\n                int updateCount = pr.executeUpdate();\r\n                if (updateCount != 1){\r\n                    System.out.println( \"  Failed: Update count should be 1 but it is \" + updateCount + \".\");\r\n                    return;\r\n                }\r\n            }\r\n            time += System.currentTimeMillis();\r\n            System.out.println( \"  Test time: \" + time + \" ms\");\r\n            st.execute(\"drop procedure sp_\"+tableName);\r\n            st.close();\r\n            pr.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }\r\n    \r\n\r\n    \r\n    /**\r\n      *  10. Test\r\n      *  Update rows with a PreparedStatement and Batch.\r\n      */  \r\n    static void test_UpdateRowsPrepareBatch(Connection con){\r\n        int batchSize = 10;\r\n        int batches = rowCount / batchSize;\r\n        System.out.println();\r\n        System.out.println( \"Test update rows with PreparedStatement and Batches: \" + batches + \" batches, \" + batchSize + \" batch size\");\r\n        \r\n        try{\r\n            PreparedStatement pr = con.prepareStatement( \"UPDATE \" + tableName + \" SET bi=?,c=?,d=?,de=?,f=?,im=?,i=?,m=?,n=?,r=?,sd=?,si=?,sm=?,sy=?,t=?,ti=?,vb=?,vc=? WHERE i=?\" );\r\n            long time = -System.currentTimeMillis();\r\n            for (int i=0; i<batches; i++){\r\n                for (int r=0; r<batchSize; r++){\r\n\t                pr.setBytes (  1, byteArray );\r\n\t                pr.setString(  2 , \"Test\" );\r\n\t                pr.setDate  (  3 , new Date( System.currentTimeMillis() ) );\r\n\t                pr.setFloat (  4, (float)1234.56789 );\r\n\t                pr.setFloat (  5 , (float)9876.54321 );\r\n\t                pr.setBytes (  6, largeByteArray );\r\n\t                pr.setInt   (  7 , i*batchSize + r );\r\n\t                pr.setDouble(  8 , 23.45 );\r\n\t                pr.setDouble(  9 , 567.45 );\r\n\t                pr.setFloat (  10 , (float)78.89 );\r\n\t                pr.setTime  (  11, new Time( System.currentTimeMillis() ) );\r\n\t                pr.setShort (  12, (short)23456 );\r\n\t                pr.setFloat (  13, (float)34.56 );\r\n\t                pr.setString(  14, \"sysname (30) NULL\" );\r\n\t                pr.setString(  15 , \"text NULL\" );\r\n\t                pr.setByte  (  16, (byte)28 );\r\n\t                pr.setBytes (  17, byteArray );\r\n\t                pr.setString(  18, \"varchar (255) NULL\" );\r\n\t                pr.setInt   (  19 , i );\r\n\t                pr.addBatch();\r\n\t            }\r\n                int[] updateCount = pr.executeBatch();\r\n                if (updateCount.length != batchSize){\r\n                    System.out.println( \"  Failed: Update count size should be \" + batchSize + \" but it is \" + updateCount.length + \".\");\r\n                    return;\r\n                }\r\n            }\r\n            time += System.currentTimeMillis();\r\n            System.out.println( \"  Test time: \" + time + \" ms\");\r\n            pr.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }\r\n     \r\n    \r\n    \r\n    /**\r\n      *  11. Test\r\n      *  Scroll and call the getXXX methods for every columns.\r\n      */  \r\n    static void test_Scroll_getXXX(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test scroll and call the getXXX methods for every columns: \" + rowCount + \" rows\");\r\n        \r\n        try{\r\n            Statement st = con.createStatement();\r\n            long time = -System.currentTimeMillis();\r\n            ResultSet rs = st.executeQuery(\"SELECT * FROM \" + tableName);\r\n            for (int i=0; i<rowCount; i++){\r\n                    rs.next();\r\n\t                rs.getInt   (  1 );\r\n\t                rs.getBytes (  2 );\r\n\t                rs.getString(  3 );\r\n\t                rs.getDate  (  4 );\r\n\t                rs.getFloat (  5 );\r\n\t                rs.getFloat (  6 );\r\n\t                rs.getBytes (  7 );\r\n\t                rs.getInt   (  8 );\r\n\t                rs.getDouble(  9 );\r\n\t                rs.getDouble(  10 );\r\n\t                rs.getFloat (  11 );\r\n\t                rs.getTime  (  12 );\r\n\t                rs.getShort (  13 );\r\n\t                rs.getFloat (  14 );\r\n\t                rs.getString(  15 );\r\n\t                rs.getString(  16 );\r\n\t                rs.getByte  (  17 );\r\n\t                rs.getBytes (  18 );\r\n\t                rs.getString(  19 );\r\n            }\r\n            time += System.currentTimeMillis();\r\n            System.out.println( \"  Test time: \" + time + \" ms\");\r\n            st.close();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }\r\n     \r\n    \r\n    /**\r\n      *  12. Test\r\n      *  Update large binary data.\r\n      */  \r\n    static void test_UpdateLargeBinary(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test update large binary data: \" + rowCount + \"KB bytes\");\r\n        \r\n        try{\r\n            java.io.FileOutputStream fos = new java.io.FileOutputStream(tableName+\".bin\");\r\n            byte bytes[] = new byte[1024];\r\n            for(int i=0; i<rowCount; i++){\r\n                fos.write(bytes);\r\n            }\r\n            fos.close();\r\n            java.io.FileInputStream fis = new java.io.FileInputStream(tableName+\".bin\");\r\n            long time = -System.currentTimeMillis();\r\n            PreparedStatement pr = con.prepareStatement(\"Update \" + tableName + \" set im=? WHERE pr=1\");\r\n            pr.setBinaryStream( 1, fis, rowCount*1024 );\r\n            pr.execute();\r\n            pr.close();\r\n            time += System.currentTimeMillis();\r\n            System.out.println( \"  Test time: \" + time + \" ms\");\r\n            fis.close();\r\n            java.io.File file = new java.io.File(tableName+\".bin\");\r\n            file.delete();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }\r\n     \r\n    \r\n\r\n    \r\n    /**\r\n      *  12. Test\r\n      *  Update large binary data with a SP.\r\n      */  \r\n    static void test_UpdateLargeBinaryWithSP(Connection con){\r\n        System.out.println();\r\n        System.out.println( \"Test update large binary data with a SP: \" + rowCount + \"KB bytes\");\r\n        \r\n        try{\r\n            java.io.FileOutputStream fos = new java.io.FileOutputStream(tableName+\".bin\");\r\n            byte bytes[] = new byte[1024];\r\n            for(int i=0; i<rowCount; i++){\r\n                fos.write(bytes);\r\n            }\r\n            fos.close();\r\n            java.io.FileInputStream fis = new java.io.FileInputStream(tableName+\".bin\");\r\n            long time = -System.currentTimeMillis();\r\n            Statement st = con.createStatement();\r\n            st.execute(\"CREATE PROCEDURE #UpdateLargeBinary(@im image) as Update \" + tableName + \" set im=@im WHERE pr=2\");\r\n            PreparedStatement pr = con.prepareStatement(\"exec #UpdateLargeBinary ?\");\r\n            pr.setBinaryStream( 1, fis, rowCount*1024 );\r\n            pr.execute();\r\n            st.execute(\"DROP PROCEDURE #UpdateLargeBinary\");\r\n            st.close();\r\n            pr.close();\r\n            time += System.currentTimeMillis();\r\n            System.out.println( \"  Test time: \" + time + \" ms\");\r\n            fis.close();\r\n            java.io.File file = new java.io.File(tableName+\".bin\");\r\n            file.delete();\r\n        }catch(Exception e){\r\n            System.out.println(\"  Failed:\"+e);\r\n        }finally{\r\n            System.out.println();\r\n            System.out.println(\"===================================================================\");\r\n        }\r\n    }\r\n     \r\n    \r\n\r\n    \r\n    /**\r\n      *  Create a new Table for testing\r\n      */  \r\n    static void createTestTable(Connection con) throws SQLException{\r\n            Statement st;\r\n            st = con.createStatement();\r\n            //delete old table\r\n            dropTestTable( con );\r\n\r\n            //create table\r\n            st.execute(\r\n                \"CREATE TABLE \" + tableName + \" (\"+\r\n\t            \"    pr  numeric IDENTITY,\"+\r\n\t            \"    bi  binary (255) NULL ,\"+\r\n\t            \"    c   nchar (255) NULL ,\"+\r\n\t            \"    d   datetime NULL ,\"+\r\n\t            \"    de  decimal(18, 0) NULL ,\"+\r\n\t            \"    f   float NULL ,\"+\r\n\t            \"    im  image NULL ,\"+\r\n\t            \"    i   int NULL ,\"+\r\n\t            \"    m   money NULL ,\"+\r\n\t            \"    n   numeric(18, 0) NULL ,\"+\r\n\t            \"    r   real NULL ,\"+\r\n\t            \"    sd  smalldatetime NULL ,\"+\r\n\t            \"    si  smallint NULL ,\"+\r\n\t            \"    sm  smallmoney NULL ,\"+\r\n\t            \"    sy  sysname NULL ,\"+\r\n\t            \"    t   ntext NULL ,\"+\r\n\t            \"    ti  tinyint NULL ,\"+\r\n\t            \"    vb  varbinary (255) NULL ,\"+\r\n\t            \"    vc  nvarchar (255) NULL, \"+\r\n\t            \"CONSTRAINT PK_BenchTest2 PRIMARY KEY CLUSTERED (pr) \"+\r\n\t            \")\");\r\n\t        st.close();  \r\n    }\r\n    \r\n\r\n    \r\n    static void deleteTestTable(Connection con){\r\n        try{\r\n            Statement st = con.createStatement();\r\n            st.execute(\"DELETE FROM \" + tableName);\r\n            st.close();\r\n        }catch(Exception e){/* ignore it */}\r\n    }\r\n\r\n    static void dropTestTable(Connection con){\r\n        try{\r\n            Statement st = con.createStatement();\r\n            st.execute(\"drop table \" + tableName);\r\n            st.close();\r\n        }catch(Exception e){/* ignore it */}\r\n    }\r\n    \r\n    // create test data after the insert test is failed\r\n    static void createTestDataWithClassicInsert(Connection con) throws SQLException{\r\n        String sql = \"INSERT INTO \" + tableName + \"(bi,c,d,de,f,im,i,m,n,r,si,sd,sm,sy,t,ti,vb,vc) VALUES(0x172243,'Test','20010101',1234.56789,9876.54321,0x\";\r\n        for(int i=0; i<largeByteArray.length; i++){\r\n            sql += \"00\";\r\n        }\r\n        Statement st = con.createStatement();\r\n        for (int i=0; i<rowCount; i++){\r\n            st.execute(sql + \",\"+i+\",23.45,567.45,78.89,\"+i+\",'11:11:11',34.56,'sysname (30) NULL','ntext NULL, sample to save in the field',\"+(i & 0xFF)+\",0x172243,'nvarchar (255) NULL')\"  );\r\n        }\r\n        st.close();\r\n    }\r\n}"},{"path":"/src/smallsql/junit/BasicTestCase.java","source":"/* =============================================================\r\n * SmallSQL : a free Java DBMS library for the Java(tm) platform\r\n * =============================================================\r\n *\r\n * (C) Copyright 2004-2007, by Volker Berlin.\r\n *\r\n * Project Info:  http://www.smallsql.de/\r\n *\r\n * This library is free software; you can redistribute it and/or modify it \r\n * under the terms of the GNU Lesser General Public License as published by \r\n * the Free Software Foundation; either version 2.1 of the License, or \r\n * (at your option) any later version.\r\n *\r\n * This library is distributed in the hope that it will be useful, but \r\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \r\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public \r\n * License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, \r\n * USA.  \r\n *\r\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc. \r\n * in the United States and other countries.]\r\n *\r\n * ---------------\r\n * Column.java\r\n * ---------------\r\n * BasicTestCase: Volker Berlin\r\n * \r\n */\r\npackage smallsql.junit;\r\n\r\nimport junit.framework.*;\r\n\r\nimport java.io.*;\r\nimport java.math.BigDecimal;\r\nimport java.sql.*;\r\nimport java.text.DateFormatSymbols;\r\n\r\npublic class BasicTestCase extends TestCase {\r\n\r\n\t/** Localized 3-letters months */\r\n\tprotected static final String[] MONTHS = \r\n\t\tnew DateFormatSymbols().getShortMonths();\r\n\r\n\tpublic BasicTestCase(){\r\n        super();\r\n    }\r\n\r\n    public BasicTestCase(String name){\r\n        super(makeNameValid(name));\r\n    }\r\n    \r\n    private static String makeNameValid(String name){\r\n    \treturn name.replace(',' , ';').replace('(','{');\r\n    }\r\n    \r\n    void dropTable(Connection con, String name) throws SQLException{\r\n\t\ttry {\r\n\t\t\tStatement st = con.createStatement();\r\n\t\t\tst.execute(\"drop table \"+name);\r\n\t\t\tst.close();\r\n\t\t} catch (SQLException e) {\r\n            String msg = e.getMessage();\r\n            if(msg.indexOf(\"[SmallSQL]Table\")==0 && msg.indexOf(name)>0 && msg.indexOf(\"can't be dropped.\")>0 ){\r\n                return;\r\n            }\r\n            throw e;\r\n        }\r\n    }\r\n\r\n    void dropView(Connection con, String name){\r\n\t\ttry {\r\n\t\t\tStatement st = con.createStatement();\r\n\t\t\tst.execute(\"drop view \"+name);\r\n\t\t\tst.close();\r\n\t\t} catch (SQLException e) {/* ignore it, if the view not exist */}\r\n    }\r\n\r\n\tpublic void assertRSMetaData( ResultSet rs, String[] colNames, int[] types) throws Exception{\r\n\t\tResultSetMetaData rm = rs.getMetaData();\r\n\t\tint count = rm.getColumnCount();\r\n\t\tassertEquals( \"Column count:\", colNames.length, count);\r\n\t\tfor(int i=1; i<=count; i++){\r\n\t\t\tassertEquals(\"Col \"+i+\" name\", colNames[i-1], rm.getColumnName(i));\r\n\t\t\tassertEquals(\"Col \"+i+\" label\", colNames[i-1], rm.getColumnLabel(i));\r\n\t\t\tassertEquals(\"Col \"+i+\" type\", types   [i-1], rm.getColumnType(i));\r\n\t\t\tswitch(types[i-1]){\r\n\t\t\t\tcase Types.VARCHAR:\r\n\t\t\t\t\tassertTrue  (\"Wrong Precision (\" + rm.getColumnTypeName(i) + \") for Column \"+i+\": \"+rm.getPrecision(i), rm.getPrecision(i) > 0);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase Types.INTEGER:\r\n\t\t\t\t\tassertTrue  (\"Wrong Precision (\" + rm.getColumnTypeName(i) + \") for Column \"+i, rm.getPrecision(i) > 0);\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tprivate final static char[] digits = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};\r\n\tprivate static String bytes2hex( byte[] bytes ){\r\n\t\tStringBuffer buf = new StringBuffer(bytes.length << 1);\r\n\t\tfor(int i=0; i<bytes.length; i++){\r\n\t\t\tbuf.append( digits[ (bytes[i] >> 4) & 0x0F ] );\r\n\t\t\tbuf.append( digits[ (bytes[i]     ) & 0x0F ] );\r\n\t\t}\r\n\t\treturn buf.toString();\r\n\t}\r\n\t\r\n\tpublic void assertEqualsObject( String msg, Object obj1, Object obj2 ){\r\n\t\tif(obj1 instanceof byte[]){\r\n\t\t\tif(!java.util.Arrays.equals( (byte[])obj1, (byte[])obj2)){\r\n\t\t\t\tfail(msg + \" expected:\" + bytes2hex((byte[])obj1)+ \" but was:\"+bytes2hex((byte[])obj2));\r\n\t\t\t}\r\n\t\t}else{ \r\n\t\t\tif(obj1 instanceof BigDecimal)\r\n\t\t\t\tif(((BigDecimal)obj1).compareTo((BigDecimal)obj2) == 0) return;\r\n\t\t\r\n\t\t\tassertEquals( msg, obj1, obj2);\r\n\t\t}\r\n\t}\r\n\t\r\n    public void assertEqualsObject( String msg, Object obj1, Object obj2, boolean needTrim ){\r\n        if(needTrim && obj1 != null){\r\n            // trim for CHAR and BINARY\r\n            if(obj1 instanceof String) obj1 = ((String)obj1).trim();\r\n            if(obj1 instanceof byte[]){\r\n                byte[] tmp = (byte[])obj1;\r\n                int k=tmp.length-1;\r\n                for(; k>= 0; k--) if(tmp[k] != 0) break;\r\n                k++;\r\n                byte[] tmp2 = new byte[k];\r\n                System.arraycopy( tmp, 0, tmp2, 0, k);\r\n                obj1 = tmp2;\r\n            }\r\n        }\r\n\t\tif(needTrim && obj2 != null){\r\n\t\t\t// trim for CHAR and BINARY\r\n\t\t\tif(obj2 instanceof String) obj2 = ((String)obj2).trim();\r\n\t\t\tif(obj2 instanceof byte[]){\r\n\t\t\t\tbyte[] tmp = (byte[])obj2;\r\n\t\t\t\tint k=tmp.length-1;\r\n\t\t\t\tfor(; k>= 0; k--) if(tmp[k] != 0) break;\r\n\t\t\t\tk++;\r\n\t\t\t\tbyte[] tmp2 = new byte[k];\r\n\t\t\t\tSystem.arraycopy( tmp, 0, tmp2, 0, k);\r\n\t\t\t\tobj2 = tmp2;\r\n\t\t\t}\r\n\t\t}\r\n\t\tassertEqualsObject( msg, obj1, obj2);\r\n    }\r\n    \r\n    \r\n\tvoid assertRowCount(int sollCount, String sql ) throws Exception{\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs = st.executeQuery(sql);\r\n        assertRowCount(sollCount,rs);\r\n    }\r\n    \r\n    \r\n    void assertRowCount(int sollCount, ResultSet rs ) throws Exception{\r\n\t\tint colCount = rs.getMetaData().getColumnCount();\r\n\t\tint count = 0;\r\n\t\t//System.out.println(sql);\r\n\t\twhile(rs.next()){\r\n\t\t\tcount++;\r\n\t\t\tfor(int i=1; i<=colCount; i++){\r\n\t\t\t\trs.getObject(i);\r\n\t\t\t\t//System.out.print( \" \"+rs.getObject(i));\r\n\t\t\t}\r\n\t\t\t//System.out.println();\r\n\t\t}\r\n\t\tassertEquals( \"Wrong row count\", sollCount, count);\r\n\t\tfor(int i=1; i<=colCount; i++){\r\n\t\t\ttry{\r\n\t\t\t\t// if not a SQLException occur then it is an error\r\n\t\t\t\tfail( \"Column:\"+i+\" Value:\"+String.valueOf(rs.getObject(i)));\r\n\t\t\t}catch(SQLException e){\r\n                assertSQLException(\"01000\", 0, e);\r\n            }\r\n\t\t}\r\n\t\tassertFalse( \"Scroll after last\", rs.next() );\r\n\t}\r\n\r\n\t\r\n    /**\r\n     * Identical to the Implementation from Utils.string2boolean\r\n     */\r\n    private boolean string2boolean( String val){\r\n        try{\r\n            return Double.parseDouble( val ) != 0;\r\n        }catch(NumberFormatException e){/*ignore it if it not a number*/}\r\n        return \"true\".equalsIgnoreCase( val ) || \"yes\".equalsIgnoreCase( val ) || \"t\".equalsIgnoreCase( val );\r\n    }\r\n\t\r\n\t/**\r\n\t * Test a single Value of a the ResultSet that was produce from the SQL\r\n\t */\r\n   \tvoid assertEqualsRsValue(Object obj, String sql) throws Exception{\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs = st.executeQuery(sql);\r\n\t\tassertTrue( \"No row produce\", rs.next());\r\n        assertEqualsRsValue(obj,rs,false);\r\n    }\r\n    \r\n    \r\n    void assertEqualsRsValue(Object obj, ResultSet rs, boolean needTrim) throws Exception{\r\n        String name = rs.getMetaData().getColumnName(1);\r\n\t\tassertEqualsObject( \"Values not identical on read:\", obj, rs.getObject(name), needTrim);\r\n\t\tif(obj instanceof Time){\r\n\t\t\tassertEquals(\"Time is different:\", obj, rs.getTime(name) );\r\n\t\t\tassertEquals(\"Time String is different:\", obj.toString(), rs.getString(name) );\r\n\t\t}\r\n\t\tif(obj instanceof Timestamp){\r\n\t\t\tassertEquals(\"Timestamp is different:\", obj, rs.getTimestamp(name) );\r\n\t\t\tassertEquals(\"Timestamp String is different:\", obj.toString(), rs.getString(name) );\r\n\t\t}\r\n\t\tif(obj instanceof Date){\r\n\t\t\tassertEquals(\"Date is different:\", obj, rs.getDate(name) );\r\n\t\t\tassertEquals(\"Date String is different:\", obj.toString(), rs.getString(name) );\r\n\t\t}\r\n\t\tif(obj instanceof String){\r\n            String str = (String)obj;\r\n            assertEqualsObject(\"String is different:\", str, rs.getString(name), needTrim );\r\n\t\t\tassertEquals(\"String Boolean is different:\", string2boolean(str), rs.getBoolean(name) );\r\n            try{\r\n                assertEquals(\"String Long is different:\", Long.parseLong(str), rs.getLong(name) );\r\n            }catch(NumberFormatException ex){/* ignore */}\r\n            try{\r\n                assertEquals(\"String Integer is different:\", Integer.parseInt(str), rs.getInt(name) );\r\n            }catch(NumberFormatException ex){/* ignore */}\r\n            try{\r\n                assertEquals(\"String Float is different:\", Float.parseFloat(str), rs.getFloat(name), 0.0 );\r\n            }catch(NumberFormatException ex){/* ignore */}\r\n            try{\r\n                assertEquals(\"String Double is different:\", Double.parseDouble(str), rs.getDouble(name), 0.0 );\r\n            }catch(NumberFormatException ex){/* ignore */}\r\n\t\t}\r\n\t\tif(obj instanceof BigDecimal){\r\n            if(!needTrim){\r\n                assertEquals(\"BigDecimal is different:\", obj, rs.getBigDecimal(name) );\r\n                assertEquals(\"Scale is different:\", ((BigDecimal)obj).scale(), rs.getMetaData().getScale(1));\r\n            }\r\n            assertEquals(\"Scale Meta is different:\", rs.getBigDecimal(name).scale(), rs.getMetaData().getScale(1));\r\n\t\t\tBigDecimal big2 = ((BigDecimal)obj).setScale(2,BigDecimal.ROUND_HALF_EVEN);\r\n\t\t\tassertEquals(\"BigDecimal mit scale is different:\", big2, rs.getBigDecimal(name, 2) );\r\n\t\t}\r\n\t\tif(obj instanceof Integer){\r\n\t\t\tassertEquals(\"Scale is different:\", 0, rs.getMetaData().getScale(1));\r\n\t\t}\r\n\t\tif(obj instanceof Number){\r\n            long longValue = ((Number)obj).longValue();\r\n\t\t\tint intValue = ((Number)obj).intValue();\r\n            if(longValue >= Integer.MAX_VALUE)\r\n                intValue = Integer.MAX_VALUE;\r\n            if(longValue <= Integer.MIN_VALUE)\r\n                intValue = Integer.MIN_VALUE;\r\n\t\t\tassertEquals(\"int is different:\", intValue, rs.getInt(name) );\r\n\t\t\tassertEquals(\"long is different:\", longValue, rs.getLong(name) );\r\n\t\t\tif(intValue >= Short.MIN_VALUE && intValue <= Short.MAX_VALUE)\r\n\t\t\t\tassertEquals(\"short is different:\", (short)intValue, rs.getShort(name) );\r\n\t\t\tif(intValue >= Byte.MIN_VALUE && intValue <= Byte.MAX_VALUE)\r\n\t\t\t\tassertEquals(\"byte is different:\", (byte)intValue, rs.getByte(name) );\r\n\t\t\t\r\n\t\t\tdouble value = ((Number)obj).doubleValue();\r\n\t\t\tassertEquals(\"Double is different:\", value, rs.getDouble(name),0.0 );\r\n\t\t\tassertEquals(\"Float is different:\", (float)value, rs.getFloat(name),0.0 );\r\n\t\t\tString valueStr = obj.toString();\r\n            if(!needTrim){\r\n                assertEquals(\"Number String is different:\", valueStr, rs.getString(name) );\r\n            }\r\n\t\t\tBigDecimal decimal = Double.isInfinite(value) || Double.isNaN(value) ? null : new BigDecimal(valueStr);\r\n            assertEqualsObject(\"Number BigDecimal is different:\", decimal, rs.getBigDecimal(name) );\r\n\t\t\tassertEquals(\"Number boolean is different:\", value != 0, rs.getBoolean(name) );\r\n\t\t}\r\n\t\tif(obj == null){\r\n\t\t\tassertNull(\"String is different:\", rs.getString(name) );\r\n\t\t\tassertNull(\"Date is different:\", rs.getDate(name) );\r\n\t\t\tassertNull(\"Time is different:\", rs.getTime(name) );\r\n\t\t\tassertNull(\"Timestamp is different:\", rs.getTimestamp(name) );\r\n\t\t\tassertNull(\"BigDecimal is different:\", rs.getBigDecimal(name) );\r\n\t\t\tassertNull(\"BigDecimal with scale is different:\", rs.getBigDecimal(name, 2) );\r\n\t\t\tassertNull(\"Bytes with scale is different:\", rs.getBytes(name) );\r\n\t\t\tassertEquals(\"Double is different:\", 0, rs.getDouble(name),0 );\r\n\t\t\tassertEquals(\"Float is different:\", 0, rs.getFloat(name),0 );\r\n\t\t\tassertEquals(\"Long is different:\", 0, rs.getLong(name) );\r\n\t\t\tassertEquals(\"Int is different:\", 0, rs.getInt(name) );\r\n\t\t\tassertEquals(\"SmallInt is different:\", 0, rs.getShort(name) );\r\n\t\t\tassertEquals(\"TinyInt is different:\", 0, rs.getByte(name) );\r\n\t\t\tassertEquals(\"Boolean is different:\", false, rs.getBoolean(name) );\r\n\t\t}\r\n\t\tif(obj instanceof byte[]){\r\n\t\t    assertTrue(\"Binary should start with 0x\", rs.getString(name).startsWith(\"0x\"));\r\n\t\t}\r\n\t\t\r\n\t\tResultSetMetaData metaData = rs.getMetaData();\r\n\t\tString className = metaData.getColumnClassName(1);\r\n\t\tassertNotNull( \"ClassName:\", className);\r\n\t\tif(obj != null){\r\n\t\t\tClass gotClass = Class.forName(className);\r\n\t\t\tClass objClass = obj.getClass();\r\n\t\t\tString objClassName = objClass.getName();\r\n\t\t\t\r\n\t\t\tint expectedLen = metaData.getColumnDisplaySize(1);\r\n\r\n\t\t\t// B/CLOBs must be treated as special cases\t\t\t\r\n\t\t\tif (gotClass.equals(java.sql.Blob.class)) {\r\n\t\t\t\tassertTrue(\r\n\t\t\t\t\t\"ClassName assignable: \"+className+\"<->\"+objClassName,\r\n\t\t\t\t\tobjClass.equals(new byte[0].getClass()));\r\n\r\n\t\t\t\tString message = \"Check DisplaySize: \" + expectedLen + \"!=\" + Integer.MAX_VALUE + \")\";\r\n\t\t\t\tassertTrue( message, expectedLen == Integer.MAX_VALUE );\r\n\t\t\t}\r\n\t\t\telse if (gotClass.equals(java.sql.Clob.class)) { // same as NCLOB\r\n\t\t\t\tassertTrue(\r\n\t\t\t\t\t\"ClassName assignable: \"+className+\"<->\"+objClassName,\r\n\t\t\t\t\tobjClass.equals(String.class));\r\n\r\n\t\t\t\tString message = \"Check DisplaySize: \" + expectedLen + \"!=\" + Integer.MAX_VALUE + \")\";\r\n\t\t\t\tassertTrue( message, expectedLen == Integer.MAX_VALUE );\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tString foundStr = rs.getString(name);\r\n\t\t\t\t\r\n\t\t\t\tassertTrue(\"ClassName assignable: \"+className+\"<->\"+objClassName, gotClass.isAssignableFrom(objClass));\r\n\t\t\t\tassertTrue( \"DisplaySize to small \"+ expectedLen +\"<\"+foundStr.length()+\" (\" + foundStr + \")\", expectedLen >= foundStr.length() );\r\n\t\t\t}\r\n\t\t}\r\n   \t}\r\n    \r\n    \r\n    void assertSQLException(String sqlstate, int vendorCode, SQLException ex) {\r\n        StringWriter sw = new StringWriter();\r\n        ex.printStackTrace(new PrintWriter(sw));\r\n        assertEquals( \"Vendor Errorcode:\"+sw, vendorCode, ex.getErrorCode() );\r\n        assertEquals( \"SQL State:\"+sw, sqlstate, ex.getSQLState());\r\n    }\r\n    \r\n\r\n   \t\r\n\tvoid printSQL(String sql) throws SQLException{\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs = st.executeQuery(sql);\r\n\t\tprintRS( rs );\r\n\t}\r\n\t\r\n   \tvoid printRS(ResultSet rs) throws SQLException{\r\n   \t\tint count = rs.getMetaData().getColumnCount();\r\n\t\twhile(rs.next()){ \r\n\t\t\tfor(int i=1; i<=count; i++){\r\n\t\t\t\tSystem.out.print(rs.getString(i) + '\\t');\r\n\t\t\t} \r\n\t\t\tSystem.out.println();\r\n\t\t}\r\n\r\n   \t}\r\n   \t\r\n   \t/**\r\n\t * Returns the localized 3-letters month.\r\n\t * \r\n\t * @param ordinal\r\n\t *            month ordinal (1-based).\r\n\t * @return 3-letters month.\r\n\t */\r\n   \tstatic String getMonth3L(int ordinal) {\r\n   \t\treturn MONTHS[ordinal - 1];\r\n   \t}\r\n}"},{"path":"/src/smallsql/database/SSCallableStatement.java","source":"/* =============================================================\r\n * SmallSQL : a free Java DBMS library for the Java(tm) platform\r\n * =============================================================\r\n *\r\n * (C) Copyright 2004-2007, by Volker Berlin.\r\n *\r\n * Project Info:  http://www.smallsql.de/\r\n *\r\n * This library is free software; you can redistribute it and/or modify it \r\n * under the terms of the GNU Lesser General Public License as published by \r\n * the Free Software Foundation; either version 2.1 of the License, or \r\n * (at your option) any later version.\r\n *\r\n * This library is distributed in the hope that it will be useful, but \r\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \r\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public \r\n * License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, \r\n * USA.  \r\n *\r\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc. \r\n * in the United States and other countries.]\r\n *\r\n * ---------------\r\n * SSCallableStatament.java\r\n * ---------------\r\n * Author: Volker Berlin\r\n * \r\n */\r\npackage smallsql.database;\r\n\r\nimport java.sql.*;\r\nimport java.math.*;\r\nimport java.util.Map;\r\nimport java.util.Calendar;\r\nimport java.net.URL;\r\nimport java.io.*;\r\nimport smallsql.database.language.Language;\r\n\r\npublic class SSCallableStatement extends SSPreparedStatement implements CallableStatement {\r\n\r\n    private boolean wasNull;\r\n\r\n    SSCallableStatement( SSConnection con, String sql ) throws SQLException {\r\n        super( con, sql );\r\n    }\r\n\r\n    SSCallableStatement( SSConnection con, String sql, int rsType, int rsConcurrency ) throws SQLException {\r\n        super( con, sql, rsType, rsConcurrency );\r\n    }\r\n\r\n    private Expression getValue(int i) throws SQLException{\r\n        /**@todo: Implement this java.sql.CallableStatement method*/\r\n        throw new java.lang.UnsupportedOperationException(\"Method getValue() not yet implemented.\");\r\n    }\r\n\r\n    private int findParameter( String parameterName ){\r\n        /**@todo: Implement this java.sql.CallableStatement method*/\r\n        throw new java.lang.UnsupportedOperationException(\"Method findParameter() not yet implemented.\");\r\n    }\r\n/*==============================================================================\r\n\r\n    Public Interface\r\n\r\n==============================================================================*/\r\n    public void registerOutParameter(int i, int sqlType) throws SQLException {\r\n        /**@todo: Implement this java.sql.CallableStatement method*/\r\n        throw new java.lang.UnsupportedOperationException(\"Method registerOutParameter() not yet implemented.\");\r\n    }\r\n    public void registerOutParameter(int i, int sqlType, int scale) throws SQLException {\r\n        /**@todo: Implement this java.sql.CallableStatement method*/\r\n        throw new java.lang.UnsupportedOperationException(\"Method registerOutParameter() not yet implemented.\");\r\n    }\r\n    \r\n    \r\n    public boolean wasNull(){\r\n        return wasNull;\r\n    }\r\n    \r\n    \r\n    public String getString(int i) throws SQLException {\r\n        try{\r\n            String obj = getValue(i).getString();\r\n            wasNull = obj == null;\r\n            return obj;\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }\r\n    public boolean getBoolean(int i) throws SQLException {\r\n        try{\r\n            Expression expr = getValue(i);\r\n            wasNull = expr.isNull();\r\n            return expr.getBoolean();\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }\r\n    public byte getByte(int i) throws SQLException {\r\n        return (byte)getInt( i );\r\n    }\r\n    public short getShort(int i) throws SQLException {\r\n        return (byte)getInt( i );\r\n    }\r\n    public int getInt(int i) throws SQLException {\r\n        try{\r\n            Expression expr = getValue(i);\r\n            wasNull = expr.isNull();\r\n            return expr.getInt();\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }\r\n    public long getLong(int i) throws SQLException {\r\n        try{\r\n            Expression expr = getValue(i);\r\n            wasNull = expr.isNull();\r\n            return expr.getLong();\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }\r\n    public float getFloat(int i) throws SQLException {\r\n        try{\r\n            Expression expr = getValue(i);\r\n            wasNull = expr.isNull();\r\n            return expr.getFloat();\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }\r\n    public double getDouble(int i) throws SQLException {\r\n        try{\r\n            Expression expr = getValue(i);\r\n            wasNull = expr.isNull();\r\n            return expr.getLong();\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }\r\n    public BigDecimal getBigDecimal(int i, int scale) throws SQLException {\r\n        try{\r\n            MutableNumeric obj = getValue(i).getNumeric();\r\n            wasNull = obj == null;\r\n            if(wasNull) return null;\r\n            return obj.toBigDecimal(scale);\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }\r\n    public byte[] getBytes(int i) throws SQLException {\r\n        try{\r\n            byte[] obj = getValue(i).getBytes();\r\n            wasNull = obj == null;\r\n            return obj;\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }\r\n    public Date getDate(int i) throws SQLException {\r\n        try{\r\n\t\t\tExpression expr = getValue(i);\r\n            wasNull = expr.isNull();\r\n\t\t\tif(wasNull) return null;\r\n\t\t\treturn DateTime.getDate( expr.getLong() );\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }\r\n    public Time getTime(int i) throws SQLException {\r\n        try{\r\n\t\t\tExpression expr = getValue(i);\r\n            wasNull = expr.isNull();\r\n\t\t\tif(wasNull) return null;\r\n\t\t\treturn DateTime.getTime( expr.getLong() );\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }\r\n    public Timestamp getTimestamp(int i) throws SQLException {\r\n        try{\r\n            Expression expr = getValue(i);\r\n            wasNull = expr.isNull();\r\n            if(wasNull) return null;\r\n            return DateTime.getTimestamp( expr.getLong() );\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }\r\n    public Object getObject(int i) throws SQLException {\r\n        try{\r\n            Object obj = getValue(i).getObject();\r\n            wasNull = obj == null;\r\n            return obj;\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }\r\n    public BigDecimal getBigDecimal(int i) throws SQLException {\r\n        try{\r\n            MutableNumeric obj = getValue(i).getNumeric();\r\n            wasNull = obj == null;\r\n            if(wasNull) return null;\r\n            return obj.toBigDecimal();\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }\r\n    public Object getObject(int i, Map map) throws SQLException {\r\n        /**@todo: Implement this java.sql.CallableStatement method*/\r\n        throw SmallSQLException.create(Language.UNSUPPORTED_OPERATION, \"Method getObject() not yet implemented.\");\r\n    }\r\n    public Ref getRef(int i) throws SQLException {\r\n        /**@todo: Implement this java.sql.CallableStatement method*/\r\n        throw SmallSQLException.create(Language.UNSUPPORTED_OPERATION, \"Method getRef() not yet implemented.\");\r\n    }\r\n    public Blob getBlob(int i) throws SQLException {\r\n        /**@todo: Implement this java.sql.CallableStatement method*/\r\n        throw SmallSQLException.create(Language.UNSUPPORTED_OPERATION, \"Method getBlob() not yet implemented.\");\r\n    }\r\n    public Clob getClob(int i) throws SQLException {\r\n        /**@todo: Implement this java.sql.CallableStatement method*/\r\n        throw SmallSQLException.create(Language.UNSUPPORTED_OPERATION, \"Method getClob() not yet implemented.\");\r\n    }\r\n    public Array getArray(int i) throws SQLException {\r\n        /**@todo: Implement this java.sql.CallableStatement method*/\r\n        throw SmallSQLException.create(Language.UNSUPPORTED_OPERATION, \"Method getArray() not yet implemented.\");\r\n    }\r\n    public Date getDate(int i, Calendar cal) throws SQLException {\r\n        /**@todo: Implement this java.sql.CallableStatement method*/\r\n        throw SmallSQLException.create(Language.UNSUPPORTED_OPERATION, \"Method getDate() not yet implemented.\");\r\n    }\r\n    public Time getTime(int i, Calendar cal) throws SQLException {\r\n        /**@todo: Implement this java.sql.CallableStatement method*/\r\n        throw SmallSQLException.create(Language.UNSUPPORTED_OPERATION, \"Method getTime() not yet implemented.\");\r\n    }\r\n    public Timestamp getTimestamp(int i, Calendar cal) throws SQLException {\r\n        /**@todo: Implement this java.sql.CallableStatement method*/\r\n        throw SmallSQLException.create(Language.UNSUPPORTED_OPERATION, \"Method getTimestamp() not yet implemented.\");\r\n    }\r\n    public void registerOutParameter(int i, int sqlType, String typeName) throws SQLException {\r\n        /**@todo: Implement this java.sql.CallableStatement method*/\r\n        throw SmallSQLException.create(Language.UNSUPPORTED_OPERATION, \"Method registerOutParameter() not yet implemented.\");\r\n    }\r\n    public void registerOutParameter(String parameterName, int sqlType) throws SQLException {\r\n        registerOutParameter( findParameter( parameterName ), sqlType );\r\n    }\r\n    public void registerOutParameter(String parameterName, int sqlType, int scale) throws SQLException {\r\n        registerOutParameter( findParameter( parameterName ), sqlType, scale );\r\n    }\r\n    public void registerOutParameter(String parameterName, int sqlType, String typeName) throws SQLException {\r\n        registerOutParameter( findParameter( parameterName ), sqlType, typeName );\r\n    }\r\n    public URL getURL(int parameterIndex) throws SQLException {\r\n        /**@todo: Implement this java.sql.CallableStatement method*/\r\n        throw SmallSQLException.create(Language.UNSUPPORTED_OPERATION, \"Method getURL() not yet implemented.\");\r\n    }\r\n    public void setURL(String parameterName, URL x) throws SQLException {\r\n        setURL( findParameter( parameterName ), x );\r\n    }\r\n    public void setNull(String parameterName, int sqlType) throws SQLException {\r\n        setNull( findParameter( parameterName ), sqlType );\r\n    }\r\n    public void setBoolean(String parameterName, boolean x) throws SQLException {\r\n        setBoolean( findParameter( parameterName ), x );\r\n    }\r\n    public void setByte(String parameterName, byte x) throws SQLException {\r\n        setByte( findParameter( parameterName ), x );\r\n    }\r\n    public void setShort(String parameterName, short x) throws SQLException {\r\n        setShort( findParameter( parameterName ), x );\r\n    }\r\n    public void setInt(String parameterName, int x) throws SQLException {\r\n        setInt( findParameter( parameterName ), x );\r\n    }\r\n    public void setLong(String parameterName, long x) throws SQLException {\r\n        setLong( findParameter( parameterName ), x );\r\n    }\r\n    public void setFloat(String parameterName, float x) throws SQLException {\r\n        setFloat( findParameter( parameterName ), x );\r\n    }\r\n    public void setDouble(String parameterName, double x) throws SQLException {\r\n        setDouble( findParameter( parameterName ), x );\r\n    }\r\n    public void setBigDecimal(String parameterName, BigDecimal x) throws SQLException {\r\n        setBigDecimal( findParameter( parameterName ), x );\r\n    }\r\n    public void setString(String parameterName, String x) throws SQLException {\r\n        setString( findParameter( parameterName ), x );\r\n    }\r\n    public void setBytes(String parameterName, byte[] x) throws SQLException {\r\n        setBytes( findParameter( parameterName ), x );\r\n    }\r\n    public void setDate(String parameterName, Date x) throws SQLException {\r\n        setDate( findParameter( parameterName ), x );\r\n    }\r\n    public void setTime(String parameterName, Time x) throws SQLException {\r\n        setTime( findParameter( parameterName ), x );\r\n    }\r\n    public void setTimestamp(String parameterName, Timestamp x) throws SQLException {\r\n        setTimestamp( findParameter( parameterName ), x );\r\n    }\r\n    public void setAsciiStream(String parameterName, InputStream x, int length) throws SQLException {\r\n        setAsciiStream( findParameter( parameterName ), x, length );\r\n    }\r\n    public void setBinaryStream(String parameterName, InputStream x, int length) throws SQLException {\r\n        setBinaryStream( findParameter( parameterName ), x, length );\r\n    }\r\n    public void setObject(String parameterName, Object x, int sqlType, int scale) throws SQLException {\r\n        setObject( findParameter( parameterName ), x, sqlType, scale );\r\n    }\r\n    public void setObject(String parameterName, Object x, int sqlType) throws SQLException {\r\n        setObject( findParameter( parameterName ), x, sqlType );\r\n    }\r\n    public void setObject(String parameterName, Object x) throws SQLException {\r\n        setObject( findParameter( parameterName ), x );\r\n    }\r\n    public void setCharacterStream(String parameterName, Reader x, int length) throws SQLException {\r\n        setCharacterStream( findParameter( parameterName ), x, length );\r\n    }\r\n    public void setDate(String parameterName, Date x, Calendar cal) throws SQLException {\r\n        setDate( findParameter( parameterName ), x, cal );\r\n    }\r\n    public void setTime(String parameterName, Time x, Calendar cal) throws SQLException {\r\n        setTime( findParameter( parameterName ), x, cal );\r\n    }\r\n    public void setTimestamp(String parameterName, Timestamp x, Calendar cal) throws SQLException {\r\n        setTimestamp( findParameter( parameterName ), x, cal );\r\n    }\r\n    public void setNull(String parameterName, int sqlType, String typeName) throws SQLException {\r\n        setNull( findParameter( parameterName ), sqlType, typeName );\r\n    }\r\n    public String getString(String parameterName) throws SQLException {\r\n        return getString( findParameter( parameterName ) );\r\n    }\r\n    public boolean getBoolean(String parameterName) throws SQLException {\r\n        return getBoolean( findParameter( parameterName ) );\r\n    }\r\n    public byte getByte(String parameterName) throws SQLException {\r\n        return getByte( findParameter( parameterName ) );\r\n    }\r\n    public short getShort(String parameterName) throws SQLException {\r\n        return getShort( findParameter( parameterName ) );\r\n    }\r\n    public int getInt(String parameterName) throws SQLException {\r\n        return getInt( findParameter( parameterName ) );\r\n    }\r\n    public long getLong(String parameterName) throws SQLException {\r\n        return getLong( findParameter( parameterName ) );\r\n    }\r\n    public float getFloat(String parameterName) throws SQLException {\r\n        return getFloat( findParameter( parameterName ) );\r\n    }\r\n    public double getDouble(String parameterName) throws SQLException {\r\n        return getDouble( findParameter( parameterName ) );\r\n    }\r\n    public byte[] getBytes(String parameterName) throws SQLException {\r\n        return getBytes( findParameter( parameterName ) );\r\n    }\r\n    public Date getDate(String parameterName) throws SQLException {\r\n        return getDate( findParameter( parameterName ) );\r\n    }\r\n    public Time getTime(String parameterName) throws SQLException {\r\n        return getTime( findParameter( parameterName ) );\r\n    }\r\n    public Timestamp getTimestamp(String parameterName) throws SQLException {\r\n        return getTimestamp( findParameter( parameterName ) );\r\n    }\r\n    public Object getObject(String parameterName) throws SQLException {\r\n        return getObject( findParameter( parameterName ) );\r\n    }\r\n    public BigDecimal getBigDecimal(String parameterName) throws SQLException {\r\n        return getBigDecimal( findParameter( parameterName ) );\r\n    }\r\n    public Object getObject(String parameterName, Map map) throws SQLException {\r\n        return getObject( findParameter( parameterName ), map );\r\n    }\r\n    public Ref getRef(String parameterName) throws SQLException {\r\n        return getRef( findParameter( parameterName ) );\r\n    }\r\n    public Blob getBlob(String parameterName) throws SQLException {\r\n        return getBlob( findParameter( parameterName ) );\r\n    }\r\n    public Clob getClob(String parameterName) throws SQLException {\r\n        return getClob( findParameter( parameterName ) );\r\n    }\r\n    public Array getArray(String parameterName) throws SQLException {\r\n        return getArray( findParameter( parameterName ) );\r\n    }\r\n    public Date getDate(String parameterName, Calendar cal) throws SQLException {\r\n        return getDate( findParameter( parameterName ), cal );\r\n    }\r\n    public Time getTime(String parameterName, Calendar cal) throws SQLException {\r\n        return getTime( findParameter( parameterName ), cal );\r\n    }\r\n    public Timestamp getTimestamp(String parameterName, Calendar cal) throws SQLException {\r\n        return getTimestamp( findParameter( parameterName ), cal );\r\n    }\r\n    public URL getURL(String parameterName) throws SQLException {\r\n        return getURL( findParameter( parameterName ) );\r\n    }\r\n}"},{"path":"/src/smallsql/database/SQLParser.java","source":"/* =============================================================\r\n * SmallSQL : a free Java DBMS library for the Java(tm) platform\r\n * =============================================================\r\n *\r\n * (C) Copyright 2004-2007, by Volker Berlin.\r\n *\r\n * Project Info:  http://www.smallsql.de/\r\n *\r\n * This library is free software; you can redistribute it and/or modify it \r\n * under the terms of the GNU Lesser General Public License as published by \r\n * the Free Software Foundation; either version 2.1 of the License, or \r\n * (at your option) any later version.\r\n *\r\n * This library is distributed in the hope that it will be useful, but \r\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \r\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public \r\n * License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, \r\n * USA.  \r\n *\r\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc. \r\n * in the United States and other countries.]\r\n *\r\n * ---------------\r\n * SQLParser.java\r\n * ---------------\r\n * Author: Volker Berlin\r\n * \r\n */\r\npackage smallsql.database;\r\n\r\nimport java.util.List;\r\nimport java.sql.*;\r\nimport smallsql.database.language.Language;\r\n\r\nfinal class SQLParser {\r\n\r\n\tSSConnection con;\r\n\tprivate char[] sql;\r\n    private List tokens;\r\n    private int tokenIdx;\r\n\r\n    Command parse(SSConnection con, String sqlString) throws SQLException{\r\n    \tthis.con = con;\r\n        Command cmd = parse( sqlString.toCharArray() );\r\n        SQLToken token = nextToken();\r\n        if(token != null){\r\n        \tthrow createSyntaxError(token, Language.STXADD_ADDITIONAL_TOK);\r\n        }\r\n        return cmd;\r\n    }\r\n    \r\n    final private Command parse(char[] sql) throws SQLException{\r\n        this.sql = sql;\r\n        this.tokens = SQLTokenizer.parseSQL( sql );\r\n        tokenIdx = 0;\r\n\r\n        SQLToken token = nextToken(COMMANDS);\r\n        switch (token.value){\r\n            case SQLTokenizer.SELECT:\r\n                    return select();\r\n            case SQLTokenizer.DELETE:\r\n                    return delete();\r\n            case SQLTokenizer.INSERT:\r\n                    return insert();\r\n            case SQLTokenizer.UPDATE:\r\n                    return update();\r\n            case SQLTokenizer.CREATE:\r\n                    return create();\r\n            case SQLTokenizer.DROP:\r\n                    return drop();\r\n            case SQLTokenizer.ALTER:\r\n                    return alter();\r\n            case SQLTokenizer.SET:\r\n                    return set();\r\n\t\t\tcase SQLTokenizer.USE:\r\n\t\t\t\t\ttoken = nextToken(MISSING_EXPRESSION);\r\n\t\t\t\t\tString name = token.getName( sql );\r\n\t\t\t\t\tcheckValidIdentifier( name, token );\r\n\t\t\t\t\tCommandSet set = new CommandSet( con.log, SQLTokenizer.USE);\r\n\t\t\t\t\tset.name = name;\r\n\t\t\t\t\treturn set;\r\n            case SQLTokenizer.EXECUTE:\r\n                    return execute();\r\n            case SQLTokenizer.TRUNCATE:\r\n            \t\treturn truncate();\r\n            default:\r\n                    throw new Error();\r\n        }\r\n    }\r\n    \r\n    \r\n    Expression parseExpression(String expr) throws SQLException{\r\n\t\tthis.sql = expr.toCharArray();\r\n\t\tthis.tokens = SQLTokenizer.parseSQL( sql );\r\n\t\ttokenIdx = 0;\r\n    \treturn expression( null, 0);\r\n    }\r\n\r\n    /**\r\n\t * Create a syntax error message, using a custom message.\r\n\t * \r\n\t * @param token\r\n\t *            token object; if not null, generates a SYNTAX_BASE_OFS,\r\n\t *            otherwise a SYNTAX_BASE_END.\r\n\t * @param addMessage\r\n\t *            additional message object to append.\r\n\t */\r\n    private SQLException createSyntaxError(SQLToken token, String addMessageCode) {\r\n    \tString message = getErrorString(token, addMessageCode, null);\r\n    \treturn SmallSQLException.create(Language.CUSTOM_MESSAGE, message);\r\n    }\r\n    \r\n    /**\r\n\t * Create a syntax error message, using a message with a parameter.\r\n\t * \r\n\t * @param token\r\n\t *            token object; if not null, generates a SYNTAX_BASE_OFS,\r\n\t *            otherwise a SYNTAX_BASE_END.\r\n\t * @param addMessageCode\r\n\t *            additional message[Code] to append.\r\n\t * @param param0\r\n\t *            parameter.\r\n\t */\r\n    private SQLException createSyntaxError(SQLToken token, String addMessageCode, \r\n    \t\tObject param0) {\r\n    \tString message = getErrorString(token, addMessageCode, param0);\r\n    \treturn SmallSQLException.create(Language.CUSTOM_MESSAGE, message);\r\n    }\r\n    \r\n    /**\r\n\t * Create an \"Additional keyword required\" syntax error.\r\n\t * \r\n\t * @param token\r\n\t *            token object.\r\n\t * @param validValues\r\n\t *            valid values.\r\n\t * @return Exception.\r\n\t */\r\n    private SQLException createSyntaxError(SQLToken token, int[] validValues){\r\n    \tString msgStr = SmallSQLException.translateMsg(\r\n    \t\t\tLanguage.STXADD_KEYS_REQUIRED, new Object[] { });\r\n    \t\r\n    \tStringBuffer msgBuf = new StringBuffer( msgStr );\r\n\r\n        for(int i=0; i<validValues.length; i++){\r\n            String name = SQLTokenizer.getKeyWord(validValues[i]);\r\n            if(name == null) name = String.valueOf( (char)validValues[i] );\r\n            msgBuf.append( name );\r\n            if (i < validValues.length - 2)\r\n                msgBuf.append( \", \");\r\n            else\r\n            if ( i == validValues.length - 2 )\r\n                msgBuf.append( \" or \");\r\n        }\r\n\r\n    \tString message = getErrorString(\r\n    \t\t\ttoken, Language.CUSTOM_MESSAGE, msgBuf);\r\n    \treturn SmallSQLException.create(Language.CUSTOM_MESSAGE, message);\r\n    }\r\n\r\n    /**\r\n\t * Create the complete error string (begin + middle + end).\r\n\t * \r\n\t * @param token\r\n\t *            token object.\r\n\t * @param middleMsgCode\r\n\t *            middle message[code].\r\n\t * @param middleMsgParam\r\n\t *            middle message[code] parameter.\r\n\t * @return complete error message string.\r\n\t */\r\n    private String getErrorString(SQLToken token, String middleMsgCode, \r\n    \t\tObject middleMsgParam) {\r\n    \tStringBuffer buffer = new StringBuffer(1024);\r\n\r\n    \t/* begin */\r\n    \t\r\n        if(token != null){\r\n        \tObject[] params = { String.valueOf(token.offset),\r\n        \t\t\t\t\t\tString.valueOf(sql, token.offset, token.length) };\r\n        \tString begin = SmallSQLException.translateMsg(Language.SYNTAX_BASE_OFS, params);\r\n        \tbuffer.append(begin);\r\n        }\r\n        else{\r\n        \tString begin = SmallSQLException.translateMsg(\r\n        \t\t\tLanguage.SYNTAX_BASE_END, new Object[] { });\r\n        \tbuffer.append(begin);\r\n        }\r\n    \t\r\n    \t/* middle */\r\n    \t\r\n    \tString middle = SmallSQLException.translateMsg(\r\n    \t\t\tmiddleMsgCode, new Object[] { middleMsgParam });\r\n    \t\r\n    \tbuffer.append(middle);\r\n    \t\r\n    \t/* end */\r\n    \t\r\n        int valOffset = (token != null) ? token.offset : sql.length;\r\n        int valBegin = Math.max( 0, valOffset-40);\r\n        int valEnd   = Math.min( valOffset+20, sql.length );\r\n        String lineSeparator = System.getProperty( \"line.separator\" );\r\n        buffer.append( lineSeparator );\r\n        buffer.append( sql, valBegin, valEnd-valBegin);\r\n        buffer.append( lineSeparator );\r\n        for(; valBegin<valOffset; valBegin++) buffer.append(' ');\r\n        buffer.append('^');\r\n    \t\r\n    \treturn buffer.toString();    \t\r\n    }\r\n    \r\n    private void checkValidIdentifier(String name, SQLToken token) throws SQLException{\r\n        if(token.value == SQLTokenizer.ASTERISK) return;\r\n        if(token.value != SQLTokenizer.VALUE &&\r\n\t\t   token.value != SQLTokenizer.IDENTIFIER &&\r\n           token.value < 200){\r\n            throw createSyntaxError( token, Language.STXADD_IDENT_EXPECT);\r\n        }\r\n        if(name.length() == 0) {\r\n            throw createSyntaxError( token, Language.STXADD_IDENT_EMPTY, name);\r\n        }\r\n        char firstChar = name.charAt(0);\r\n\t\tif(firstChar != '#' && firstChar < '@') {\r\n\t\t\tthrow createSyntaxError( token, Language.STXADD_IDENT_WRONG, name );\r\n\t\t}\r\n    }\r\n    \r\n\t/**\r\n     * Returns a valid identifier from this token.\r\n     * @param token the token of the identifier\r\n     * @return the string with the name\r\n     * @throws SQLException if the identifier is invalid\r\n     */\r\n    private String getIdentifier(SQLToken token) throws SQLException{\r\n    \tString name = token.getName(sql);\r\n    \tcheckValidIdentifier( name, token );\r\n    \treturn name;\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Returns a valid identifier from the next token from token stack.\r\n     * @return the string with the name\r\n     * @throws SQLException if the identifier is invalid\r\n     */\r\n    private String nextIdentifier() throws SQLException{\r\n    \treturn getIdentifier( nextToken( MISSING_IDENTIFIER ) );\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Check if the identifier is a 2 part name with a point in the middle like FIRST.SECOND\r\n     * @param name the name of the first part\r\n     * @return the second part if exist else returns the first part\r\n     * @throws SQLException \r\n     */\r\n    private String nextIdentiferPart(String name) throws SQLException{\r\n        SQLToken token = nextToken();\r\n        //check if the object name include a database name\r\n        if(token != null && token.value == SQLTokenizer.POINT){\r\n            return nextIdentifier();\r\n        }else{\r\n            previousToken();\r\n        }\r\n        return name;\r\n    }\r\n    \r\n    \r\n    final private boolean isKeyword(SQLToken token){\r\n    \tif(token == null) return false;\r\n    \tswitch(token.value){\r\n    \t\tcase SQLTokenizer.SELECT:\r\n    \t\tcase SQLTokenizer.INSERT:\r\n    \t\tcase SQLTokenizer.UPDATE:\r\n    \t\tcase SQLTokenizer.UNION:\r\n    \t\tcase SQLTokenizer.FROM:\r\n    \t\tcase SQLTokenizer.WHERE:\r\n    \t\tcase SQLTokenizer.GROUP:\r\n    \t\tcase SQLTokenizer.HAVING:\r\n\t\t\tcase SQLTokenizer.ORDER:\r\n    \t\tcase SQLTokenizer.COMMA:\r\n\t\t\tcase SQLTokenizer.SET:\r\n            case SQLTokenizer.JOIN:\r\n            case SQLTokenizer.LIMIT:\r\n    \t\t\treturn true;\r\n    \t}\r\n    \treturn false;\r\n    }\r\n    \r\n\t/** \r\n\t * Return the last token that the method nextToken has return\r\n\t */\r\n\tprivate SQLToken lastToken(){\r\n\t\tif(tokenIdx > tokens.size()){\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\treturn (SQLToken)tokens.get( tokenIdx-1 );\r\n\t}\r\n    private void previousToken(){\r\n        tokenIdx--;\r\n    }\r\n\r\n    private SQLToken nextToken(){\r\n        if(tokenIdx >= tokens.size()){\r\n            tokenIdx++; // must be ever increment that the method previousToken() is working\r\n            return null;\r\n        }\r\n        return (SQLToken)tokens.get( tokenIdx++ );\r\n    }\r\n\r\n    private SQLToken nextToken( int[] validValues) throws SQLException{\r\n        SQLToken token = nextToken();\r\n        if(token == null) throw createSyntaxError( token, validValues);\r\n        if(validValues == MISSING_EXPRESSION){\r\n            return token; // an expression can be contained in every token.\r\n        }\r\n        if(validValues == MISSING_IDENTIFIER){\r\n            // the follow token are not valid identifier\r\n            switch(token.value){\r\n                case SQLTokenizer.PARENTHESIS_L:\r\n                case SQLTokenizer.PARENTHESIS_R:\r\n                case SQLTokenizer.COMMA:\r\n                    throw createSyntaxError( token, validValues);\r\n            }\r\n            return token;\r\n        }\r\n        for(int i=validValues.length-1; i>=0; i--){\r\n            if(token.value == validValues[i]) return token;\r\n        }\r\n        throw createSyntaxError( token, validValues);\r\n    }\r\n    \r\n\r\n    /**\r\n     * A single SELECT of a UNION or only a simple single SELECT.\r\n     * @return\r\n     * @throws SQLException\r\n     */\r\n    private CommandSelect singleSelect() throws SQLException{\r\n        CommandSelect selCmd = new CommandSelect(con.log);\r\n\t\tSQLToken token;\r\n        // scan for prefix like DISTINCT, ALL and the TOP clause; sample: SELECT TOP 15 ...\r\nSwitch: while(true){\r\n\t\t\ttoken = nextToken(MISSING_EXPRESSION);\r\n\t\t\tswitch(token.value){\r\n\t\t\t\tcase SQLTokenizer.TOP:\r\n\t\t\t\t\ttoken = nextToken(MISSING_EXPRESSION);\r\n\t\t\t\t\ttry{\r\n\t\t\t\t\t\tint maxRows = Integer.parseInt(token.getName(sql));\r\n\t\t\t\t\t\tselCmd.setMaxRows(maxRows);\r\n\t\t\t\t\t}catch(NumberFormatException e){\r\n\t\t\t\t\t\tthrow createSyntaxError(token, Language.STXADD_NOT_NUMBER, token.getName(sql));\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.ALL:\r\n\t\t\t\t\tselCmd.setDistinct(false);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.DISTINCT:\r\n\t\t\t\t\tselCmd.setDistinct(true);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tpreviousToken();\r\n\t\t\t\t\tbreak Switch;\r\n\t\t\t}\r\n\t\t}\r\n\r\n        while(true){\r\n            Expression column = expression(selCmd, 0);\r\n            selCmd.addColumnExpression( column );\r\n\r\n            token = nextToken();\r\n            if(token == null) return selCmd; // SELECT without FROM\r\n\r\n            boolean as = false;\r\n            if(token.value == SQLTokenizer.AS){\r\n                token = nextToken(MISSING_EXPRESSION);\r\n                as = true;\r\n            }\r\n\r\n            if(as || (!isKeyword(token))){\r\n            \tString alias = getIdentifier( token);\r\n                column.setAlias( alias );\r\n                token = nextToken();\r\n                if(token == null) return selCmd; // SELECT without FROM\r\n            }\r\n\r\n            switch(token.value){\r\n                case SQLTokenizer.COMMA:\r\n                        if(column == null) throw createSyntaxError( token, MISSING_EXPRESSION );\r\n                        column = null;\r\n                        break;\r\n                case SQLTokenizer.FROM:\r\n                        if(column == null) throw createSyntaxError( token, MISSING_EXPRESSION );\r\n                        column = null;\r\n                        from(selCmd);\r\n                        return selCmd;\r\n\r\n                default:\r\n                        if(!isKeyword(token))\r\n                \t\t\tthrow createSyntaxError( token, new int[]{SQLTokenizer.COMMA, SQLTokenizer.FROM} );\r\n                        previousToken();\r\n                        return selCmd;\r\n            }\r\n        }\r\n    }\r\n    \r\n    \r\n    final private CommandSelect select() throws SQLException{\r\n\t\tCommandSelect selCmd = singleSelect();\r\n\t\tSQLToken token = nextToken();\r\n\t\t   \t\t\r\n    \tUnionAll union = null; \r\n\t\r\n\t\twhile(token != null && token.value == SQLTokenizer.UNION){\r\n\t\t\tif(union == null){\r\n\t\t\t\tunion = new UnionAll();\r\n\t\t\t\tunion.addDataSource(new ViewResult( con, selCmd ));\r\n\t\t\t\tselCmd = new CommandSelect(con.log);\r\n\t\t\t\tselCmd.setSource( union );\r\n\t\t\t\tDataSources from = new DataSources();\r\n\t\t\t\tfrom.add(union);\r\n\t\t\t\tselCmd.setTables( from );\r\n\t\t\t\tselCmd.addColumnExpression( new ExpressionName(\"*\") );\r\n\t\t\t}\r\n\t\t\tnextToken(MISSING_ALL);\r\n\t\t\tnextToken(MISSING_SELECT);\r\n\t\t\tunion.addDataSource( new ViewResult( con, singleSelect() ) );\r\n\t\t\ttoken = nextToken();\r\n\t\t}\r\n\t\tif(token != null && token.value == SQLTokenizer.ORDER){\r\n\t\t\torder( selCmd );\r\n\t\t\ttoken = nextToken();\r\n\t\t}\r\n\t\tif(token != null && token.value == SQLTokenizer.LIMIT){\r\n            limit( selCmd );\r\n            token = nextToken();\r\n        }\r\n        previousToken();\r\n\t\treturn selCmd;\r\n    }\r\n\r\n\r\n    private Command delete() throws SQLException{\r\n    \tCommandDelete cmd = new CommandDelete(con.log);\r\n    \tnextToken(MISSING_FROM);\r\n    \tfrom(cmd);\r\n\t\tSQLToken token = nextToken();\r\n\t\tif(token != null){\r\n\t\t\tif(token.value != SQLTokenizer.WHERE)\r\n\t\t\t\tthrow this.createSyntaxError(token, MISSING_WHERE);\r\n\t\t\twhere(cmd);\r\n\t\t}\r\n\t\treturn cmd;\r\n    }\r\n\r\n\r\n\tprivate Command truncate() throws SQLException{\r\n\t\tCommandDelete cmd = new CommandDelete(con.log);\r\n\t\tnextToken(MISSING_TABLE);\r\n\t\tfrom(cmd);\r\n\t\treturn cmd;\r\n\t}\r\n\r\n\r\n    private Command insert() throws SQLException{\r\n        SQLToken token = nextToken( MISSING_INTO );\r\n        CommandInsert cmd = new CommandInsert( con.log, nextIdentifier() );\r\n\r\n\t\tint parthesisCount = 0;\r\n\r\n\t\ttoken = nextToken(MISSING_PARENTHESIS_VALUES_SELECT);\r\n        if(token.value == SQLTokenizer.PARENTHESIS_L){\r\n        \ttoken = nextToken(MISSING_EXPRESSION);\r\n        \tif(token.value == SQLTokenizer.SELECT){\r\n\t\t\t\tparthesisCount++;\r\n\t\t\t\tcmd.noColumns = true;\r\n        \t}else{\r\n\t\t\t\tpreviousToken();\r\n\t            Expressions list = expressionParenthesisList(cmd);\r\n\t            for(int i=0; i<list.size(); i++){\r\n\t                cmd.addColumnExpression( list.get( i ) );\r\n\t            }\r\n\t            token = nextToken(MISSING_PARENTHESIS_VALUES_SELECT);\r\n        \t}\r\n        }else cmd.noColumns = true;\r\n        \r\nSwitch: while(true)\r\n        switch(token.value){\r\n        \tcase SQLTokenizer.VALUES:{\r\n\t            token = nextToken(MISSING_PARENTHESIS_L);\r\n\t            cmd.addValues( expressionParenthesisList(cmd) );\r\n\t            return cmd;\r\n\t        }\r\n        \tcase SQLTokenizer.SELECT:\r\n        \t\tcmd.addValues( select() );\r\n        \t\twhile(parthesisCount-- > 0){\r\n        \t\t\tnextToken(MISSING_PARENTHESIS_R);\r\n        \t\t}\r\n        \t\treturn cmd;\r\n        \tcase SQLTokenizer.PARENTHESIS_L:\r\n        \t\ttoken = nextToken(MISSING_PARENTHESIS_VALUES_SELECT);\r\n        \t\tparthesisCount++;\r\n        \t\tcontinue Switch;\r\n        \tdefault:\r\n        \t\tthrow new Error();\r\n        }\r\n    }\r\n\r\n\r\n    private Command update() throws SQLException{\r\n\t\tCommandUpdate cmd = new CommandUpdate(con.log);\r\n\t\t// read table name\r\n\t\tDataSources tables = new DataSources();\r\n\t\tcmd.setTables( tables );\r\n\t\tcmd.setSource( rowSource( cmd, tables, 0 ) );\r\n\t\t\r\n\t\tSQLToken token = nextToken(MISSING_SET);\r\n\t\twhile(true){\r\n\t\t\ttoken = nextToken();\r\n\t\t\tExpression dest = expressionSingle( cmd, token);\r\n\t\t\tif(dest.getType() != Expression.NAME) throw createSyntaxError( token, MISSING_IDENTIFIER );\r\n\t\t\tnextToken(MISSING_EQUALS);\r\n\t\t\tExpression src = expression(cmd, 0);\r\n\t\t\tcmd.addSetting( dest, src);\r\n\t\t\ttoken = nextToken();\r\n\t\t\tif(token == null) break;\r\n\t\t\tswitch(token.value){\r\n\t\t\t\tcase SQLTokenizer.WHERE:\r\n\t\t\t\t\twhere(cmd);\r\n\t\t\t\t\treturn cmd;\t\t\t\t\r\n\t\t\t\tcase SQLTokenizer.COMMA:\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\tdefault: throw createSyntaxError( token, MISSING_WHERE_COMMA );\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn cmd;\r\n    }\r\n\r\n\r\n    private Command create() throws SQLException{\r\n        while(true){\r\n            SQLToken token = nextToken(COMMANDS_CREATE);\r\n            switch(token.value){\r\n                case SQLTokenizer.DATABASE:\r\n                    return createDatabase();\r\n                case SQLTokenizer.TABLE:\r\n                    return createTable();\r\n                case SQLTokenizer.VIEW:\r\n                    return createView();\r\n                case SQLTokenizer.INDEX:\r\n                    return createIndex(false);\r\n                case SQLTokenizer.PROCEDURE:\r\n                    return createProcedure();\r\n                case SQLTokenizer.UNIQUE:\r\n                    do{\r\n                        token = nextToken(COMMANDS_CREATE_UNIQUE);\r\n                    }while(token.value == SQLTokenizer.INDEX);\r\n                    return createIndex(true);\r\n                case SQLTokenizer.NONCLUSTERED:\r\n                case SQLTokenizer.CLUSTERED:\r\n                    continue;\r\n                default:\r\n                    throw createSyntaxError( token, COMMANDS_CREATE );\r\n            }\r\n        }\r\n    }\r\n\t\r\n\r\n    private CommandCreateDatabase createDatabase() throws SQLException{\r\n        SQLToken token = nextToken();\r\n        if(token == null) throw createSyntaxError( token, MISSING_EXPRESSION );\r\n        return new CommandCreateDatabase( con.log, token.getName(sql));\r\n    }\r\n\t\r\n    \r\n    private CommandTable createTable() throws SQLException{\r\n        String catalog;\r\n        String tableName = catalog = nextIdentifier();\r\n        tableName = nextIdentiferPart(tableName);\r\n        if(tableName == catalog) catalog = null;\r\n        CommandTable cmdCreate = new CommandTable( con.log, catalog, tableName, SQLTokenizer.CREATE );\r\n        SQLToken token = nextToken( MISSING_PARENTHESIS_L );\r\n\r\n        nextCol:\r\n        while(true){\r\n            token = nextToken( MISSING_EXPRESSION );\r\n\t\t\t\r\n\t\t\tString constraintName;\r\n            if(token.value == SQLTokenizer.CONSTRAINT){\r\n            \t// reading a CONSTRAINT with name\r\n\t\t    \tconstraintName = nextIdentifier();\r\n\t\t\t\ttoken = nextToken( MISSING_KEYTYPE );\r\n            }else{\r\n\t\t\t\tconstraintName = null;\r\n            }\r\n\t\t\tswitch(token.value){\r\n\t\t\t\tcase SQLTokenizer.PRIMARY:\r\n\t\t\t\tcase SQLTokenizer.UNIQUE:\r\n\t\t\t\tcase SQLTokenizer.FOREIGN:\r\n\t\t\t\t\tIndexDescription index = index(cmdCreate, token.value, tableName, constraintName, null);\r\n                    if(token.value == SQLTokenizer.FOREIGN){\r\n                        nextToken( MISSING_REFERENCES );\r\n                        String pk = nextIdentifier();\r\n                        Expressions expressions = new Expressions();\r\n                        Strings columns = new Strings();\r\n                        expressionDefList( cmdCreate, expressions, columns );\r\n                        IndexDescription pkIndex = new IndexDescription( null, pk, SQLTokenizer.UNIQUE, expressions, columns);\r\n                        ForeignKey foreignKey = new ForeignKey(pk, pkIndex, tableName, index);\r\n                        cmdCreate.addForeingnKey(foreignKey);\r\n                    }else{\r\n                        cmdCreate.addIndex( index );\r\n                    }\r\n\t\r\n\t\t\t\t\ttoken = nextToken( MISSING_COMMA_PARENTHESIS );\r\n\t\t\t\t\tswitch(token.value){\r\n\t\t\t\t\t\tcase SQLTokenizer.PARENTHESIS_R:\r\n\t\t\t\t\t\t\treturn cmdCreate;\r\n\t\t\t\t\t\tcase SQLTokenizer.COMMA:\r\n\t\t\t\t\t\t\tcontinue nextCol;\r\n\t\t\t\t\t}\r\n            }\r\n            // the token is a column name\r\n\t\t\ttoken = addColumn( token, cmdCreate );\r\n            if(token == null){\r\n                throw createSyntaxError(token, MISSING_COMMA_PARENTHESIS);\r\n            }\r\n            switch(token.value){\r\n                case SQLTokenizer.PARENTHESIS_R:\r\n                    return cmdCreate;\r\n                case SQLTokenizer.COMMA:\r\n                    continue nextCol;\r\n                default:\r\n                    throw createSyntaxError(token, MISSING_COMMA_PARENTHESIS);\r\n            }\r\n        }\r\n    }\r\n    \r\n\t\r\n    /**\r\n     * Parse a Column and add it to the Command. If the column is unique or primary\r\n     * then an index is added.\r\n     * @param token the SQLToken with the column name\r\n     * @return the token of the delimiter\r\n     */\r\n    private SQLToken addColumn(SQLToken token, CommandTable cmdCreate) throws SQLException{\r\n        String colName = getIdentifier( token );\r\n        Column col = datatype(false);\r\n        col.setName( colName );\r\n\r\n\t\ttoken = nextToken();\r\n        boolean nullableWasSet = false;\r\n        boolean defaultWasSet = col.isAutoIncrement(); // with data type COUNTER already this value is set\r\n        while(true){\r\n            if(token == null){\r\n                cmdCreate.addColumn( col );\r\n                return null;\r\n            }\r\n            switch(token.value){\r\n                case SQLTokenizer.PARENTHESIS_R:\r\n                case SQLTokenizer.COMMA:\r\n                    cmdCreate.addColumn( col );\r\n                    return token;\r\n                case SQLTokenizer.DEFAULT:\r\n                    if(defaultWasSet) throw createSyntaxError( token, MISSING_COMMA_PARENTHESIS );\r\n\t\t\t\t\tint offset = token.offset + token.length;\r\n                    token = nextToken();\r\n                    if(token != null) offset = token.offset;\r\n\t\t\t\t\tpreviousToken();                    \r\n\t\t\t\t\tExpression expr = expression(cmdCreate, 0);\r\n\t\t\t\t\tSQLToken last = lastToken();\r\n\t\t\t\t\tint length = last.offset + last.length - offset;\r\n\t\t\t\t\tString def = new String( sql, offset, length );\r\n                    col.setDefaultValue( expr, def );\r\n                    defaultWasSet = true;\r\n                    break;\r\n                case SQLTokenizer.IDENTITY:\r\n                    if(defaultWasSet) throw createSyntaxError( token, MISSING_COMMA_PARENTHESIS );\r\n                    col.setAutoIncrement(true);\r\n                    defaultWasSet = true;\r\n                    break;\r\n                case SQLTokenizer.NULL:\r\n                    if(nullableWasSet) throw createSyntaxError( token, MISSING_COMMA_PARENTHESIS );\r\n                    //col.setNullable(true); is already default\r\n                    nullableWasSet = true;\r\n                    break;\r\n                case SQLTokenizer.NOT:\r\n                    if(nullableWasSet) throw createSyntaxError( token, MISSING_COMMA_PARENTHESIS );\r\n                    token = nextToken( MISSING_NULL );\r\n                    col.setNullable(false);\r\n                    nullableWasSet = true;\r\n                    break;\r\n\t\t\t\tcase SQLTokenizer.PRIMARY:\r\n\t\t\t\tcase SQLTokenizer.UNIQUE:\r\n\t\t\t\t\tIndexDescription index = index(cmdCreate, token.value, cmdCreate.name, null, colName);\r\n\t\t\t\t\tcmdCreate.addIndex( index );\r\n\t\t\t\t\tbreak;\r\n                default:\r\n                    throw createSyntaxError(token, MISSING_OPTIONS_DATATYPE);\r\n            }\r\n            token = nextToken();\r\n        }\r\n    }\r\n    \r\n\r\n\t/**\r\n\t * Parse construct like:<br>\r\n\t * <li>PRIMARY KEY (col1)\r\n\t * <li>UNIQUE (col1, col2)\r\n\t * <li>FOREIGN KEY REFERENCES ref_table(col1)\r\n\t * @param cmd\r\n\t * @param constraintType one of SQLTokenizer.PRIMARY, SQLTokenizer.UNIQUE or SQLTokenizer.FOREIGN.\r\n\t * @param if it a constrain of the current column else null\r\n\t * @return a new IndexDescription\r\n\t */\r\n\tprivate IndexDescription index(Command cmd, int constraintType, String tableName, String contrainName, String columnName) throws SQLException{\r\n\t\tif(constraintType != SQLTokenizer.UNIQUE) nextToken( MISSING_KEY );\r\n\t\tSQLToken token = nextToken();\r\n        if(token != null){\r\n    \t\tswitch(token.value){\r\n    \t\t\tcase SQLTokenizer.CLUSTERED:\r\n    \t\t\tcase SQLTokenizer.NONCLUSTERED:\r\n    \t\t\t\t// ignoring, this tokens form MS SQL Server are ignored\r\n    \t\t\t\tbreak;\r\n                default:\r\n                    previousToken();\r\n    \t\t}\r\n        }else{\r\n            previousToken();\r\n        }\r\n\t\tStrings columns = new Strings();\r\n\t\tExpressions expressions = new Expressions();\r\n\t\tif(columnName != null){\r\n\t\t\t//Constraint for a single column together with the column definition\r\n\t\t\tcolumns.add(columnName);\r\n\t\t\texpressions.add(new ExpressionName(columnName));\r\n\t\t}else{\r\n\t\t\t//Constraint as addition definition\r\n            expressionDefList( cmd, expressions, columns );\r\n\t\t}\r\n\t\treturn new IndexDescription( contrainName, tableName, constraintType, expressions, columns);\r\n\t}\r\n\r\n\r\n    /**\r\n     * Read a DataTpe description. This is used for CREATE TABLE and CONVERT function. \r\n     * @param isEscape true then the data types start with \"SQL_\". This is used for the Escape Syntax.\r\n     */\r\n    private Column datatype(boolean isEscape) throws SQLException{\r\n\t\tSQLToken token;\r\n\t\tint dataType;\r\n\t\tif(isEscape){\r\n\t\t\ttoken = nextToken( MISSING_SQL_DATATYPE );\r\n\t\t\tswitch(token.value){\r\n\t\t\t\tcase SQLTokenizer.SQL_BIGINT: \t\t\tdataType = SQLTokenizer.BIGINT;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_BINARY:\t\t\tdataType = SQLTokenizer.BINARY; \tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_BIT:\t\t\t\tdataType = SQLTokenizer.BIT;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_CHAR:\t\t\t\tdataType = SQLTokenizer.CHAR;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_DATE:\t\t\t\tdataType = SQLTokenizer.DATE;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_DECIMAL:\t\t\tdataType = SQLTokenizer.DECIMAL;\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_DOUBLE:\t\t\tdataType = SQLTokenizer.DOUBLE;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_FLOAT:\t\t\tdataType = SQLTokenizer.FLOAT;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_INTEGER:\t\t\tdataType = SQLTokenizer.INT;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_LONGVARBINARY:\tdataType = SQLTokenizer.LONGVARBINARY;break;\r\n\t\t\t\tcase SQLTokenizer.SQL_LONGVARCHAR:\t\tdataType = SQLTokenizer.LONGVARCHAR;break;\r\n\t\t\t\tcase SQLTokenizer.SQL_REAL:\t\t\t\tdataType = SQLTokenizer.REAL;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_SMALLINT:\t\t\tdataType = SQLTokenizer.SMALLINT;\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_TIME:\t\t\t\tdataType = SQLTokenizer.TIME;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_TIMESTAMP:\t\tdataType = SQLTokenizer.TIMESTAMP;\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_TINYINT:\t\t\tdataType = SQLTokenizer.TINYINT;\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_VARBINARY:\t\tdataType = SQLTokenizer.VARBINARY;\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_VARCHAR:\t\t\tdataType = SQLTokenizer.VARCHAR;\tbreak;\r\n\t\t\t\tdefault: throw new Error();\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\ttoken = nextToken( MISSING_DATATYPE );\r\n\t\t\tdataType = token.value;\r\n\t\t}\r\n\t\tColumn col = new Column();\r\n\r\n\t\t// two-part  data type\r\n\t\tif(dataType == SQLTokenizer.LONG){\r\n\t\t\ttoken = nextToken();\r\n\t\t\tif(token != null && token.value == SQLTokenizer.RAW){\r\n\t\t\t\tdataType = SQLTokenizer.LONGVARBINARY;\r\n\t\t\t}else{\r\n\t\t\t\tdataType = SQLTokenizer.LONGVARCHAR;\r\n\t\t\t\tpreviousToken();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tswitch(dataType){\r\n\t\t\tcase SQLTokenizer.RAW:\r\n\t\t\t\tdataType = SQLTokenizer.VARBINARY;\r\n\t\t\t\t// no break;\r\n\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\tcase SQLTokenizer.NCHAR:\r\n\t\t\tcase SQLTokenizer.NVARCHAR:\r\n\t\t\tcase SQLTokenizer.BINARY:\r\n\t\t\tcase SQLTokenizer.VARBINARY:\r\n\t\t\t{\r\n\t\t\t\t// detect the maximum column size\r\n                token = nextToken();\r\n\t\t\t\tint displaySize;\r\n\t\t\t\tif(token == null || token.value != SQLTokenizer.PARENTHESIS_L){\r\n\t\t\t\t\tdisplaySize = 30;\r\n                    previousToken();\r\n\t\t\t\t}else{\r\n\t\t\t\t\ttoken = nextToken( MISSING_EXPRESSION );\r\n\t\t\t\t\ttry{\r\n\t\t\t\t\t\tdisplaySize = Integer.parseInt(token.getName(sql) );\r\n\t\t\t\t\t}catch(Exception e){\r\n\t\t\t\t\t\tthrow createSyntaxError(token, MISSING_NUMBERVALUE );\r\n\t\t\t\t\t}\r\n\t\t\t\t\tnextToken( MISSING_PARENTHESIS_R );\r\n\t\t\t\t}\r\n\t\t\t\tcol.setPrecision( displaySize );\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tcase SQLTokenizer.SYSNAME:\r\n\t\t\t\tcol.setPrecision(255);\r\n\t\t\t\tdataType = SQLTokenizer.VARCHAR;\r\n\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.COUNTER:\r\n\t\t\t\tcol.setAutoIncrement(true);\r\n\t\t\t\tdataType = SQLTokenizer.INT;\r\n\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\tcase SQLTokenizer.DECIMAL:\r\n                token = nextToken();\r\n\t\t\t\tif(token != null && token.value == SQLTokenizer.PARENTHESIS_L){\r\n\t\t\t\t\t// read the precision of the data type\r\n\t\t\t\t\ttoken = nextToken( MISSING_EXPRESSION );\r\n\t\t\t\t\tint value;\r\n\t\t\t\t\ttry{\r\n\t\t\t\t\t\tvalue = Integer.parseInt(token.getName(sql) );\r\n\t\t\t\t\t}catch(Exception e){\r\n\t\t\t\t\t\tthrow createSyntaxError(token, MISSING_NUMBERVALUE );\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcol.setPrecision(value);\r\n\t\t\t\t\ttoken = nextToken( MISSING_COMMA_PARENTHESIS );\r\n\t\t\t\t\tif(token.value == SQLTokenizer.COMMA){\r\n\t\t\t\t\t\t// read the scale of the data type\r\n\t\t\t\t\t\ttoken = nextToken( MISSING_EXPRESSION );\r\n\t\t\t\t\t\ttry{\r\n\t\t\t\t\t\t\tvalue = Integer.parseInt(token.getName(sql) );\r\n\t\t\t\t\t\t}catch(Exception e){\r\n\t\t\t\t\t\t\tthrow createSyntaxError(token, MISSING_NUMBERVALUE );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tcol.setScale(value);\r\n\t\t\t\t\t\tnextToken( MISSING_PARENTHESIS_R );\r\n\t\t\t\t\t}\r\n\t\t\t\t}else{\r\n\t\t\t\t\tcol.setPrecision(18); //default Precision for decimal and numeric\r\n                    previousToken();\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t\tcol.setDataType( dataType );\r\n\t\treturn col;\r\n    }\r\n    \r\n    private CommandCreateView createView() throws SQLException{\r\n    \tString viewName = nextIdentifier();\r\n\r\n\t\tnextToken(MISSING_AS);\r\n\t\tSQLToken token = nextToken(MISSING_SELECT);\r\n\t\tCommandCreateView cmd = new CommandCreateView( con.log, viewName );\r\n\t\t\r\n\t\tcmd.sql = new String(sql, token.offset, sql.length-token.offset );\r\n\t\tselect(); //Parse to check for valid\r\n        return cmd;\r\n    }\r\n\r\n\r\n    private CommandTable createIndex(boolean unique) throws SQLException{\r\n        String indexName = nextIdentifier();\r\n        nextToken(MISSING_ON);\r\n        String catalog;\r\n        String tableName = catalog = nextIdentifier();\r\n        tableName = nextIdentiferPart(tableName);\r\n        if(tableName == catalog) catalog = null;\r\n        CommandTable cmd = new CommandTable( con.log, catalog, tableName, SQLTokenizer.INDEX );\r\n        Expressions expressions = new Expressions();\r\n        Strings columns = new Strings();\r\n        expressionDefList( cmd, expressions, columns );\r\n        IndexDescription indexDesc = new IndexDescription( \r\n                indexName, \r\n                tableName, \r\n                unique ? SQLTokenizer.UNIQUE : SQLTokenizer.INDEX, \r\n                        expressions, \r\n                        columns);\r\n        //TODO Create Index\r\n\t\tObject[] param = { \"Create Index\" };\r\n        throw SmallSQLException.create(Language.UNSUPPORTED_OPERATION, param);\r\n    }\r\n\r\n    private CommandCreateDatabase createProcedure() throws SQLException{\r\n        //TODO Create Procedure\r\n\t\tObject[] param = { \"Create Procedure\" };\r\n    \tthrow SmallSQLException.create(Language.UNSUPPORTED_OPERATION, param);\r\n    }\r\n\r\n    private Command drop() throws SQLException{\r\n        SQLToken tokenType = nextToken(COMMANDS_DROP);\r\n        \r\n\t\tString catalog;\r\n\t\tString name = catalog = nextIdentifier();\r\n        name = nextIdentiferPart( name );\r\n        if(name == catalog) catalog = null;\r\n\r\n        switch(tokenType.value){\r\n            case SQLTokenizer.DATABASE:\r\n            case SQLTokenizer.TABLE:\r\n            case SQLTokenizer.VIEW:\r\n            case SQLTokenizer.INDEX:\r\n            case SQLTokenizer.PROCEDURE:\r\n            \treturn new CommandDrop( con.log, catalog, name, tokenType.value);\r\n            default:\r\n                throw createSyntaxError( tokenType, COMMANDS_DROP );\r\n        }\r\n    }\r\n\r\n\r\n    private Command alter() throws SQLException{\r\n    \tSQLToken tokenType = nextToken(COMMANDS_ALTER);\r\n\t\tString catalog;\r\n\t\tString tableName = catalog = nextIdentifier();\r\n        switch(tokenType.value){\r\n        case SQLTokenizer.TABLE:\r\n        case SQLTokenizer.VIEW:\r\n        case SQLTokenizer.INDEX:\r\n        case SQLTokenizer.PROCEDURE:\r\n            tableName = nextIdentiferPart(tableName);\r\n            if(tableName == catalog) catalog = null;\r\n        }\r\n        switch(tokenType.value){\r\n    \t//case SQLTokenizer.DATABASE:\r\n        case SQLTokenizer.TABLE:\r\n            return alterTable( catalog, tableName );\r\n        //case SQLTokenizer.VIEW:\r\n        //case SQLTokenizer.INDEX:\r\n        //case SQLTokenizer.PROCEDURE:\r\n        default:\r\n    \t\tObject[] param = { \"ALTER \" + tokenType.getName( sql ) };\r\n        \tthrow SmallSQLException.create(Language.UNSUPPORTED_OPERATION, param);\r\n        }\r\n    }\r\n    \r\n    \r\n    Command alterTable( String catalog, String name ) throws SQLException{\r\n    \tSQLToken tokenType = nextToken(MISSING_ADD_ALTER_DROP);\r\n        CommandTable cmd = new CommandTable( con.log, catalog, name, tokenType.value );\r\n    \tswitch(tokenType.value){\r\n    \tcase SQLTokenizer.ADD:\r\n    \t\tSQLToken token;\r\n    \t\tdo{\r\n    \t\t\ttoken = nextToken( MISSING_IDENTIFIER );\r\n    \t\t\ttoken = addColumn( token, cmd );\r\n    \t\t}while(token != null && token.value == SQLTokenizer.COMMA );\r\n\r\n    \t\treturn cmd;\r\n    \tdefault:\r\n    \t\tObject[] param = { \"ALTER TABLE \" + tokenType.getName( sql ) };\r\n            throw SmallSQLException.create(Language.UNSUPPORTED_OPERATION, param);\r\n    \t}\r\n    }\r\n    \r\n\r\n    private CommandSet set() throws SQLException{\r\n        SQLToken token = nextToken( COMMANDS_SET );\r\n        switch(token.value){\r\n            case SQLTokenizer.TRANSACTION:\r\n                return setTransaction();\r\n            default:\r\n                throw new Error();\r\n        }\r\n    }\r\n\r\n    private CommandSet setTransaction() throws SQLException{\r\n        SQLToken token = nextToken( MISSING_ISOLATION );\r\n        token = nextToken( MISSING_LEVEL );\r\n        token = nextToken( COMMANDS_TRANS_LEVEL );\r\n        CommandSet cmd = new CommandSet( con.log, SQLTokenizer.LEVEL );\r\n        switch(token.value){\r\n            case SQLTokenizer.READ:\r\n                token = nextToken( MISSING_COMM_UNCOMM );\r\n                switch(token.value){\r\n                    case SQLTokenizer.COMMITTED:\r\n                        cmd.isolationLevel = Connection.TRANSACTION_READ_COMMITTED;\r\n                        break;\r\n                    case SQLTokenizer.UNCOMMITTED:\r\n                        cmd.isolationLevel = Connection.TRANSACTION_READ_UNCOMMITTED;\r\n                        break;\r\n                    default:\r\n                        throw new Error();\r\n                }\r\n                return cmd;\r\n            case SQLTokenizer.REPEATABLE:\r\n                token = nextToken( MISSING_READ );\r\n                cmd.isolationLevel = Connection.TRANSACTION_REPEATABLE_READ;\r\n                return cmd;\r\n            case SQLTokenizer.SERIALIZABLE:\r\n                cmd.isolationLevel = Connection.TRANSACTION_SERIALIZABLE;\r\n                return cmd;\r\n            default:\r\n                throw new Error();\r\n        }\r\n\r\n\r\n    }\r\n\r\n    private Command execute() throws SQLException{\r\n        //TODO Execute\r\n        throw SmallSQLException.create(Language.UNSUPPORTED_OPERATION, \"Execute\");\r\n    }\r\n\r\n    /**\r\n     * Read a Expression list in parenthesis like of VALUES() or functions. \r\n     * The left parenthesis is already consumed.\r\n     * \r\n     * @param cmd is needed to add parameters \"?\" with addParameter() \r\n     * @see #expressionDefList\r\n     */ \r\n    private Expressions expressionParenthesisList(Command cmd) throws SQLException{\r\n\t\tExpressions list = new Expressions();\r\n\t\t{\r\n\t\t\tSQLToken token = nextToken();\r\n\t\t\tif(token != null && token.value == SQLTokenizer.PARENTHESIS_R){\r\n\t\t\t\t// empty list like functions without parameters\r\n\t\t\t\treturn list;\r\n\t\t\t}\r\n\t\t\tpreviousToken();\r\n\t\t}\r\n        while(true){\r\n            list.add( expression(cmd, 0) );\r\n            SQLToken token = nextToken(MISSING_COMMA_PARENTHESIS);\r\n            switch(token.value){\r\n                case SQLTokenizer.PARENTHESIS_R:\r\n                    return list;\r\n                case SQLTokenizer.COMMA:\r\n                    continue;\r\n                default:\r\n                    throw new Error();\r\n            }\r\n        }\r\n    }\r\n\r\n    \r\n    /**\r\n     * Read a list of expressions. The list is limit from specific SQL keywords like SELECT, GROUP BY, ORDER BY\r\n     */\r\n    private Expressions expressionTokenList(Command cmd, int listType) throws SQLException{\r\n\t\tExpressions list = new Expressions();\r\n        while(true){\r\n        \tExpression expr = expression(cmd, 0);\r\n            list.add( expr );\r\n            SQLToken token = nextToken();\r\n            \r\n\t\t\tif(listType == SQLTokenizer.ORDER && token != null){\r\n\t\t\t\tswitch(token.value){\r\n\t\t\t\t\tcase SQLTokenizer.DESC:\r\n\t\t\t\t\t\texpr.setAlias(SQLTokenizer.DESC_STR);\r\n\t\t\t\t\t\t//no break;\r\n\t\t\t\t\tcase SQLTokenizer.ASC:\r\n\t\t\t\t\t\ttoken = nextToken();\r\n\t\t\t\t}\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(token == null) {\r\n\t\t\t\tpreviousToken();\r\n\t\t\t\treturn list;\r\n\t\t\t}\r\n\r\n\t\t\tswitch(token.value){\r\n                case SQLTokenizer.COMMA:\r\n                    continue;\r\n                default:\r\n\t\t\t\t\tif(isKeyword(token) ){\r\n\t\t\t\t\t\tpreviousToken();\r\n\t\t\t\t\t\treturn list;\r\n\t\t\t\t\t}\r\n                    throw createSyntaxError( token, MISSING_TOKEN_LIST);\r\n            }\r\n        }\r\n    }\r\n    \r\n    \r\n    private void expressionDefList(Command cmd, Expressions expressions, Strings columns) throws SQLException{\r\n        SQLToken token = nextToken();\r\n        if(token.value != SQLTokenizer.PARENTHESIS_L) throw createSyntaxError(token, MISSING_PARENTHESIS_L );\r\n        Loop:\r\n        while(true){\r\n            int offset = token.offset + token.length;\r\n            token = nextToken();\r\n            if(token != null) offset = token.offset;\r\n            previousToken();  \r\n            \r\n            expressions.add( expression(cmd, 0) );\r\n            SQLToken last = lastToken();\r\n            int length = last.offset + last.length - offset;\r\n            columns.add( new String( sql, offset, length ) );\r\n\r\n            token = nextToken(MISSING_COMMA_PARENTHESIS);\r\n            switch(token.value){\r\n                case SQLTokenizer.PARENTHESIS_R:\r\n                    break Loop;\r\n                case SQLTokenizer.COMMA:\r\n                    continue;\r\n                default:\r\n                    throw new Error();\r\n            }\r\n        }\r\n    }\r\n    \r\n\r\n\t/**\r\n\t * Read a complex expression that can be build from multiple atomic expressions.\r\n     * @param cmd is needed to add parameters \"?\" with addParameter() \r\n\t * @param previousOperationLevel the level of the left operation.\r\n\t */\r\n    private Expression expression(Command cmd, int previousOperationLevel) throws SQLException{\r\n        SQLToken token = nextToken(MISSING_EXPRESSION);\r\n        Expression leftExpr;\r\n        switch(token.value){\r\n            case SQLTokenizer.NOT:\r\n            \tleftExpr =  new ExpressionArithmetic( expression( cmd, ExpressionArithmetic.NOT      / 10), ExpressionArithmetic.NOT);\r\n            \tbreak;\r\n            case SQLTokenizer.MINUS:\r\n            \tleftExpr =  new ExpressionArithmetic( expression( cmd, ExpressionArithmetic.NEGATIVE / 10), ExpressionArithmetic.NEGATIVE);\r\n            \tbreak;\r\n            case SQLTokenizer.TILDE:\r\n            \tleftExpr =  new ExpressionArithmetic( expression( cmd, ExpressionArithmetic.BIT_NOT  / 10), ExpressionArithmetic.BIT_NOT);\r\n            \tbreak;\r\n            case SQLTokenizer.PARENTHESIS_L:\r\n                leftExpr = expression( cmd, 0);\r\n                token = nextToken(MISSING_PARENTHESIS_R);\r\n                break;\r\n            default:\r\n                leftExpr = expressionSingle( cmd, token);\r\n        }\r\n        boolean isNot = false;\r\n        while((token = nextToken()) != null){\r\n            Expression rightExpr;\r\n            int operation = ExpressionArithmetic.getOperationFromToken(token.value);\r\n            int level = operation / 10;\r\n            if(previousOperationLevel >= level){\r\n                previousToken();\r\n                return leftExpr;\r\n            }\r\n            switch(token.value){\r\n                case SQLTokenizer.PLUS:\r\n                case SQLTokenizer.MINUS:\r\n                case SQLTokenizer.ASTERISK:\r\n                case SQLTokenizer.SLACH:\r\n                case SQLTokenizer.PERCENT:\r\n                case SQLTokenizer.EQUALS:\r\n                case SQLTokenizer.LESSER:\r\n                case SQLTokenizer.LESSER_EQU:\r\n                case SQLTokenizer.GREATER:\r\n                case SQLTokenizer.GREATER_EQU:\r\n                case SQLTokenizer.UNEQUALS:\r\n                case SQLTokenizer.LIKE:\r\n                case SQLTokenizer.OR:\r\n                case SQLTokenizer.AND:\r\n                case SQLTokenizer.BIT_AND:\r\n                case SQLTokenizer.BIT_OR:\r\n                case SQLTokenizer.BIT_XOR:\r\n                    rightExpr = expression( cmd, level );\r\n                    leftExpr = new ExpressionArithmetic( leftExpr, rightExpr, operation );\r\n                    break;\r\n                case SQLTokenizer.BETWEEN:\r\n                    rightExpr = expression( cmd, ExpressionArithmetic.AND );\r\n                    nextToken( MISSING_AND );\r\n                    Expression rightExpr2 = expression( cmd, level );\r\n                    leftExpr = new ExpressionArithmetic( leftExpr, rightExpr, rightExpr2, operation );\r\n                    break;\r\n                case SQLTokenizer.IN:\r\n            \t\tnextToken(MISSING_PARENTHESIS_L);\r\n                \ttoken = nextToken(MISSING_EXPRESSION);\r\n                \tif(token.value == SQLTokenizer.SELECT){\r\n                \t\tCommandSelect cmdSel = select();\r\n\t\t\t\t\t\tleftExpr = new ExpressionInSelect( con, leftExpr, cmdSel, operation );\r\n\t\t\t\t\t\tnextToken(MISSING_PARENTHESIS_R);\r\n                \t}else{\r\n                \t\tpreviousToken();\r\n                \t\tExpressions list = expressionParenthesisList( cmd );\r\n                \t\tleftExpr = new ExpressionArithmetic( leftExpr, list, operation );\r\n                \t}\r\n                    break;\r\n                case SQLTokenizer.IS:\r\n                \ttoken = nextToken(MISSING_NOT_NULL);\r\n                \tif(token.value == SQLTokenizer.NOT){\r\n                \t\tnextToken(MISSING_NULL);\r\n\t\t\t\t\t\toperation++;\r\n                \t}\r\n                \tleftExpr = new ExpressionArithmetic( leftExpr, operation );\r\n                \tbreak;\r\n                case SQLTokenizer.NOT:\r\n                \ttoken = nextToken(MISSING_BETWEEN_IN);\r\n                \tpreviousToken();\r\n                \tisNot = true;\r\n                \tcontinue;\r\n                default:\r\n                        previousToken();\r\n                        return leftExpr;\r\n            }\r\n            if(isNot){\r\n            \tisNot = false;\r\n\t\t\t\tleftExpr =  new ExpressionArithmetic( leftExpr, ExpressionArithmetic.NOT);\r\n            }\r\n        }\r\n        previousToken();\r\n        return leftExpr;\r\n    }\r\n\r\n    /**\r\n     * This method parse a single expression like 12, 'qwert', 0x3F or a column name.\r\n     * \r\n     * @param cmd is needed to add parameters \"?\" with addParameter() \r\n     */\r\n    private Expression expressionSingle(Command cmd, SQLToken token) throws SQLException{\r\n        boolean isMinus = false;\r\n        if(token != null){\r\n            switch(token.value){\r\n                case SQLTokenizer.NULL:\r\n                        return new ExpressionValue( null, SQLTokenizer.NULL );\r\n                case SQLTokenizer.STRING:\r\n                        return new ExpressionValue( token.getName(null), SQLTokenizer.VARCHAR );\r\n                case SQLTokenizer.IDENTIFIER:\r\n                        {\r\n                        String name = getIdentifier( token );\r\n                        ExpressionName expr =  new ExpressionName( name );\r\n                        SQLToken token2 = nextToken();\r\n                        if(token2 != null && token2.value == SQLTokenizer.POINT){\r\n                            expr.setNameAfterTableAlias( nextIdentifier() );\r\n                        }else{\r\n                            previousToken();\r\n                        }\r\n                        return expr;\r\n                        }\r\n                case SQLTokenizer.TRUE:\r\n                        return new ExpressionValue( Boolean.TRUE, SQLTokenizer.BOOLEAN );\r\n                case SQLTokenizer.FALSE:\r\n                        return new ExpressionValue( Boolean.FALSE, SQLTokenizer.BOOLEAN );\r\n                case SQLTokenizer.ESCAPE_L:{\r\n                        token = nextToken(COMMANDS_ESCAPE);\r\n                        SQLToken para = nextToken(MISSING_EXPRESSION);\r\n                        Expression expr;\r\n                        switch(token.value){\r\n                            case SQLTokenizer.D: // date escape sequence\r\n                            \texpr = new ExpressionValue( DateTime.valueOf(para.getName(sql), SQLTokenizer.DATE), SQLTokenizer.DATE );\r\n                            \tbreak;\r\n                            case SQLTokenizer.T: // time escape sequence\r\n                                expr = new ExpressionValue( DateTime.valueOf(para.getName(sql), SQLTokenizer.TIME), SQLTokenizer.TIME );\r\n                            \tbreak;\r\n                            case SQLTokenizer.TS: // timestamp escape sequence\r\n                                expr = new ExpressionValue( DateTime.valueOf(para.getName(sql), SQLTokenizer.TIMESTAMP), SQLTokenizer.TIMESTAMP );\r\n                            \tbreak;\r\n                            case SQLTokenizer.FN: // function escape sequence\r\n                            \tnextToken(MISSING_PARENTHESIS_L);\r\n                            \texpr = function(cmd, para, true);\r\n                            \tbreak;\r\n                            case SQLTokenizer.CALL: // call escape sequence\r\n                                throw new java.lang.UnsupportedOperationException(\"call escape sequence\");\r\n                            default: throw new Error();\r\n                        }\r\n                        token = nextToken( ESCAPE_MISSING_CLOSE );\r\n                        return expr;\r\n                }\r\n                case SQLTokenizer.QUESTION:\r\n                        ExpressionValue param = new ExpressionValue();\r\n                        cmd.addParameter( param );\r\n                        return param;\r\n                case SQLTokenizer.CASE:\r\n                \t\treturn caseExpr(cmd);\r\n                case SQLTokenizer.MINUS:\r\n                case SQLTokenizer.PLUS:\r\n                        // sign detection\r\n                        do{\r\n                            if(token.value == SQLTokenizer.MINUS)\r\n                                    isMinus = !isMinus;\r\n                            token = nextToken();\r\n                            if(token == null) throw createSyntaxError( token, MISSING_EXPRESSION );\r\n                        }while(token.value == SQLTokenizer.MINUS || token.value == SQLTokenizer.PLUS);\r\n                        // no Break\r\n                default:\r\n                        SQLToken token2 = nextToken();\r\n                        if(token2 != null && token2.value == SQLTokenizer.PARENTHESIS_L){\r\n                            if(isMinus)\r\n                                return new ExpressionArithmetic( function( cmd, token, false ),  ExpressionArithmetic.NEGATIVE );\r\n                            return function( cmd, token, false );\r\n                        }else{\r\n                            // constant expression or identifier\r\n                            char chr1 = sql[ token.offset ];\r\n\t\t\t\t\t\t\tif(chr1 == '$'){\r\n\t\t\t\t\t\t\t\tpreviousToken();\r\n\t                            String tok = new String(sql, token.offset+1, token.length-1);\r\n                                if(isMinus) tok = \"-\" + tok;\r\n\t\t\t\t\t\t\t\treturn new ExpressionValue( new Money(Double.parseDouble(tok)), SQLTokenizer.MONEY );\r\n\t\t\t\t\t\t\t}\r\n                            String tok = new String(sql, token.offset, token.length);\r\n                            if((chr1 >= '0' && '9' >= chr1) || chr1 == '.'){\r\n                                previousToken();\r\n                                // first character is a digit\r\n                                if(token.length>1 && (sql[ token.offset +1 ] | 0x20) == 'x'){\r\n                                    // binary data as hex\r\n                                    if(isMinus) {\r\n                \t\t\t\t\t\tthrow createSyntaxError(token, Language.STXADD_OPER_MINUS);\r\n                                    }\r\n                                    return new ExpressionValue( Utils.hex2bytes( sql, token.offset+2, token.length-2), SQLTokenizer.VARBINARY );\r\n                                }\r\n                                if(isMinus) tok = \"-\" + tok;\r\n                                if(Utils.indexOf( '.', sql, token.offset, token.length ) >= 0 ||\r\n                                   Utils.indexOf( 'e', sql, token.offset, token.length ) >= 0){\r\n                                    return new ExpressionValue( new Double(tok), SQLTokenizer.DOUBLE );\r\n                                }else{\r\n                                    try{\r\n                                        return new ExpressionValue( new Integer(tok), SQLTokenizer.INT );\r\n                                    }catch(NumberFormatException e){\r\n                                        return new ExpressionValue( new Long(tok), SQLTokenizer.BIGINT );\r\n                                    }\r\n                                }\r\n                            }else{\r\n                                // identifier\r\n                                checkValidIdentifier( tok, token );\r\n                                ExpressionName expr = new ExpressionName(tok);\r\n                                if(token2 != null && token2.value == SQLTokenizer.POINT){\r\n                                    expr.setNameAfterTableAlias( nextIdentifier() );\r\n                                }else{\r\n                                    previousToken();\r\n                                }\r\n                                if(isMinus)\r\n                                    return new ExpressionArithmetic( expr,  ExpressionArithmetic.NEGATIVE );\r\n                                return expr;\r\n                            }\r\n                        }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    \r\n    \r\n    ExpressionFunctionCase caseExpr(final Command cmd) throws SQLException{\r\n\t\tExpressionFunctionCase expr = new ExpressionFunctionCase();\r\n\t\tSQLToken token = nextToken(MISSING_EXPRESSION);\r\n\t\t\r\n\t\tExpression input = null;\r\n\t\tif(token.value != SQLTokenizer.WHEN){\r\n\t\t\t// simple CASE Syntax\r\n\t\t\tpreviousToken();\r\n\t\t\tinput = expression(cmd, 0);\r\n\t\t\ttoken = nextToken(MISSING_WHEN_ELSE_END);\r\n\t\t}\t\t\t\r\n\t\t\t\r\n\t\twhile(true){\r\n\t\t\tswitch(token.value){\r\n\t\t\t\tcase SQLTokenizer.WHEN:\t\t\t\t\r\n\t\t\t\t\tExpression condition = expression(cmd, 0);\r\n\t\t\t\t\tif(input != null){\r\n\t\t\t\t\t\t// simple CASE Syntax\r\n\t\t\t\t\t\tcondition = new ExpressionArithmetic( input, condition, ExpressionArithmetic.EQUALS);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tnextToken(MISSING_THEN);\r\n\t\t\t\t\tExpression result = expression(cmd, 0);\r\n\t\t\t\t\texpr.addCase(condition, result);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.ELSE:\r\n\t\t\t\t\texpr.setElseResult(expression(cmd, 0));\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.END:\r\n\t\t\t\t\texpr.setEnd();\r\n\t\t\t\t\treturn expr;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tthrow new Error();\r\n\t\t\t}\r\n\t\t\ttoken = nextToken(MISSING_WHEN_ELSE_END);\r\n\t\t}\r\n    }\r\n    \r\n\r\n    /**\r\n     * Parse any functions. The left parenthesis is already consumed from token list.\r\n     * @param token the SQLToken of the function\r\n     * @param isEscape If the function is a FN ESCAPE sequence\r\n     */ \r\n    private Expression function( Command cmd, SQLToken token, boolean isEscape ) throws SQLException{\r\n        Expression expr;\r\n        switch(token.value){\r\n        \tcase SQLTokenizer.CONVERT:{\r\n        \t\tColumn col;\r\n        \t\tExpression style = null;\r\n        \t\tif(isEscape){\r\n        \t\t\texpr = expression( cmd, 0);\r\n\t\t\t\t\tnextToken(MISSING_COMMA);\r\n\t\t\t\t\tcol = datatype(isEscape);\r\n        \t\t}else{\r\n\t        \t\tcol = datatype(isEscape);\r\n\t        \t\tnextToken(MISSING_COMMA);\r\n\t\t\t\t\texpr = expression( cmd, 0);\r\n\t\t\t\t\ttoken = nextToken(MISSING_COMMA_PARENTHESIS);\r\n\t\t\t\t\tif(token.value == SQLTokenizer.COMMA){\r\n\t\t\t\t\t\tstyle = expression( cmd, 0);\r\n\t\t\t\t\t}else\r\n\t\t\t\t\t\tpreviousToken();\r\n        \t\t}\r\n        \t\tnextToken(MISSING_PARENTHESIS_R);\r\n        \t\treturn new ExpressionFunctionConvert( col, expr, style );\r\n        \t}\r\n        \tcase SQLTokenizer.CAST:\r\n        \t\texpr = expression( cmd, 0);\r\n        \t\tnextToken(MISSING_AS);\r\n        \t\tColumn col = datatype(false);\r\n        \t\tnextToken(MISSING_PARENTHESIS_R);\r\n        \t\treturn new ExpressionFunctionConvert( col, expr, null );\r\n\t\t\tcase SQLTokenizer.TIMESTAMPDIFF:\r\n\t\t\t\ttoken = nextToken(MISSING_INTERVALS);\r\n\t\t\t\tnextToken(MISSING_COMMA);\r\n\t\t\t\texpr = expression( cmd, 0);\r\n\t\t\t\tnextToken(MISSING_COMMA);\r\n\t\t\t\texpr = new ExpressionFunctionTimestampDiff( token.value, expr, expression( cmd, 0));\r\n\t\t\t\tnextToken(MISSING_PARENTHESIS_R);\r\n\t\t\t\treturn expr;\r\n\t\t\tcase SQLTokenizer.TIMESTAMPADD:\r\n\t\t\t\ttoken = nextToken(MISSING_INTERVALS);\r\n\t\t\t\tnextToken(MISSING_COMMA);\r\n\t\t\t\texpr = expression( cmd, 0);\r\n\t\t\t\tnextToken(MISSING_COMMA);\r\n\t\t\t\texpr = new ExpressionFunctionTimestampAdd( token.value, expr, expression( cmd, 0));\r\n\t\t\t\tnextToken(MISSING_PARENTHESIS_R);\r\n\t\t\t\treturn expr;\r\n        }\r\n\t\tExpressions paramList = expressionParenthesisList(cmd);\r\n        int paramCount = paramList.size();\r\n        Expression[] params = paramList.toArray();\r\n        boolean invalidParamCount;\r\n        switch(token.value){\r\n        // numeric functions:\r\n            case SQLTokenizer.ABS:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionAbs();\r\n                break;\r\n            case SQLTokenizer.ACOS:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionACos();\r\n                break;\r\n            case SQLTokenizer.ASIN:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionASin();\r\n                break;\r\n            case SQLTokenizer.ATAN:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionATan();\r\n                break;\r\n            case SQLTokenizer.ATAN2:\r\n                invalidParamCount = (paramCount != 2);\r\n                expr = new ExpressionFunctionATan2();\r\n                break;\r\n            case SQLTokenizer.CEILING:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionCeiling();\r\n                break;\r\n            case SQLTokenizer.COS:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionCos();\r\n                break;\r\n            case SQLTokenizer.COT:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionCot();\r\n                break;\r\n            case SQLTokenizer.DEGREES:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionDegrees();\r\n                break;\r\n            case SQLTokenizer.EXP:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionExp();\r\n                break;\r\n            case SQLTokenizer.FLOOR:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionFloor();\r\n                break;\r\n            case SQLTokenizer.LOG:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionLog();\r\n                break;\r\n            case SQLTokenizer.LOG10:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionLog10();\r\n                break;\r\n            case SQLTokenizer.MOD:\r\n                invalidParamCount = (paramCount != 2);\r\n                expr = new ExpressionFunctionMod();\r\n                break;\r\n            case SQLTokenizer.PI:\r\n                invalidParamCount = (paramCount != 0);\r\n                expr = new ExpressionFunctionPI();\r\n                break;\r\n            case SQLTokenizer.POWER:\r\n                invalidParamCount = (paramCount != 2);\r\n                expr = new ExpressionFunctionPower();\r\n                break;\r\n            case SQLTokenizer.RADIANS:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionRadians();\r\n                break;\r\n            case SQLTokenizer.RAND:\r\n                invalidParamCount =  (paramCount != 0) && (paramCount != 1);\r\n                expr = new ExpressionFunctionRand();\r\n                break;\r\n            case SQLTokenizer.ROUND:\r\n                invalidParamCount =  (paramCount != 2);\r\n                expr = new ExpressionFunctionRound();\r\n                break;\r\n            case SQLTokenizer.SIN:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionSin();\r\n                break;\r\n            case SQLTokenizer.SIGN:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionSign();\r\n                break;\r\n            case SQLTokenizer.SQRT:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionSqrt();\r\n                break;\r\n            case SQLTokenizer.TAN:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionTan();\r\n                break;\r\n            case SQLTokenizer.TRUNCATE:\r\n                invalidParamCount =  (paramCount != 2);\r\n                expr = new ExpressionFunctionTruncate();\r\n                break;\r\n         \r\n        // string functions:\r\n\t\t\tcase SQLTokenizer.ASCII:\r\n\t\t\t\tinvalidParamCount = (paramCount != 1);\r\n\t\t\t\texpr = new ExpressionFunctionAscii();\r\n\t\t\t\tbreak;\r\n            case SQLTokenizer.BITLEN:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionBitLen();\r\n                break;\r\n            case SQLTokenizer.CHARLEN:\r\n            case SQLTokenizer.CHARACTLEN:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionCharLen();\r\n                break;\r\n\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\tinvalidParamCount = (paramCount != 1);\r\n\t\t\t\texpr = new ExpressionFunctionChar();\r\n\t\t\t\tbreak;\r\n            case SQLTokenizer.CONCAT:\r\n                if(paramCount != 2){\r\n                    invalidParamCount = true;\r\n                    expr = null;//only for compiler\r\n                    break;\r\n                }\r\n                invalidParamCount = false;\r\n                expr = new ExpressionArithmetic( params[0], params[1], ExpressionArithmetic.ADD);\r\n                break;\r\n            case SQLTokenizer.DIFFERENCE:\r\n                invalidParamCount = (paramCount != 2);\r\n                expr = new ExpressionFunctionDifference();\r\n                break;\r\n            case SQLTokenizer.INSERT:\r\n                invalidParamCount = (paramCount != 4);\r\n                expr = new ExpressionFunctionInsert();\r\n                break;\r\n            case SQLTokenizer.LCASE:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionLCase();\r\n                break;\r\n            case SQLTokenizer.LEFT:\r\n                invalidParamCount = (paramCount != 2);\r\n                expr = new ExpressionFunctionLeft();\r\n                break;\r\n\t\t\tcase SQLTokenizer.LENGTH:\r\n\t\t\t\tinvalidParamCount = (paramCount != 1);\r\n\t\t\t\texpr = new ExpressionFunctionLength();\r\n\t\t\t\tbreak;\r\n            case SQLTokenizer.LOCATE:\r\n            \tinvalidParamCount = (paramCount != 2) && (paramCount != 3);\r\n            \texpr = new ExpressionFunctionLocate();\r\n            \tbreak;\r\n            case SQLTokenizer.LTRIM:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionLTrim();\r\n                break;\r\n            case SQLTokenizer.OCTETLEN:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionOctetLen();\r\n                break;\r\n            case SQLTokenizer.REPEAT:\r\n                invalidParamCount = (paramCount != 2);\r\n                expr = new ExpressionFunctionRepeat();\r\n                break;\r\n            case SQLTokenizer.REPLACE:\r\n                invalidParamCount = (paramCount != 3);\r\n                expr = new ExpressionFunctionReplace();\r\n                break;\r\n\t\t\tcase SQLTokenizer.RIGHT:\r\n\t\t\t\tinvalidParamCount = (paramCount != 2);\r\n\t\t\t\texpr = new ExpressionFunctionRight();\r\n\t\t\t\tbreak;\r\n            case SQLTokenizer.RTRIM:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionRTrim();\r\n                break;\r\n            case SQLTokenizer.SPACE:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionSpace();\r\n                break;\r\n            case SQLTokenizer.SOUNDEX:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionSoundex();\r\n                break;\r\n\t\t\tcase SQLTokenizer.SUBSTRING:\r\n\t\t\t\tinvalidParamCount = (paramCount != 3);\r\n\t\t\t\texpr = new ExpressionFunctionSubstring();\r\n\t\t\t\tbreak;\r\n            case SQLTokenizer.UCASE:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionUCase();\r\n                break;\r\n                \r\n        // date time functions\r\n            case SQLTokenizer.CURDATE:\r\n            case SQLTokenizer.CURRENTDATE:\r\n            \tinvalidParamCount = (paramCount != 0);\r\n\t\t\t\texpr = new ExpressionValue( new DateTime(DateTime.now(), SQLTokenizer.DATE), SQLTokenizer.DATE);\r\n\t\t\t\tbreak;\r\n            case SQLTokenizer.CURTIME:\r\n            \tinvalidParamCount = (paramCount != 0);\r\n\t\t\t\texpr = new ExpressionValue( new DateTime(DateTime.now(), SQLTokenizer.TIME), SQLTokenizer.TIME);\r\n\t\t\t\tbreak;\r\n            case SQLTokenizer.DAYOFMONTH:\r\n            \tinvalidParamCount = (paramCount != 1);\r\n\t\t\t\texpr = new ExpressionFunctionDayOfMonth();\r\n\t\t\t\tbreak;\r\n            case SQLTokenizer.DAYOFWEEK:\r\n            \tinvalidParamCount = (paramCount != 1);\r\n\t\t\t\texpr = new ExpressionFunctionDayOfWeek();\r\n\t\t\t\tbreak;\r\n            case SQLTokenizer.DAYOFYEAR:\r\n            \tinvalidParamCount = (paramCount != 1);\r\n\t\t\t\texpr = new ExpressionFunctionDayOfYear();\r\n\t\t\t\tbreak;\r\n            case SQLTokenizer.HOUR:\r\n            \tinvalidParamCount = (paramCount != 1);\r\n\t\t\t\texpr = new ExpressionFunctionHour();\r\n\t\t\t\tbreak;\r\n            case SQLTokenizer.MINUTE:\r\n            \tinvalidParamCount = (paramCount != 1);\r\n\t\t\t\texpr = new ExpressionFunctionMinute();\r\n\t\t\t\tbreak;\r\n            case SQLTokenizer.MONTH:\r\n            \tinvalidParamCount = (paramCount != 1);\r\n\t\t\t\texpr = new ExpressionFunctionMonth();\r\n\t\t\t\tbreak;\r\n            case SQLTokenizer.NOW:\r\n            \tinvalidParamCount = (paramCount != 0);\r\n\t\t\t\texpr = new ExpressionValue( new DateTime(DateTime.now(), SQLTokenizer.TIMESTAMP), SQLTokenizer.TIMESTAMP);\r\n\t\t\t\tbreak;\r\n            case SQLTokenizer.YEAR:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionYear();\r\n                break;\r\n            \t\r\n        // system functions:\r\n            case SQLTokenizer.IIF:\r\n        \t\tinvalidParamCount = (paramCount != 3);\r\n            \texpr = new ExpressionFunctionIIF();\r\n        \t\tbreak;\r\n        \tcase SQLTokenizer.SWITCH:\r\n        \t\tinvalidParamCount = (paramCount % 2 != 0);\r\n        \t\tExpressionFunctionCase exprCase = new ExpressionFunctionCase();\r\n        \t\tfor(int i=0; i < paramCount-1; i +=2)\r\n        \t\t\texprCase.addCase(params[i], params[i+1] );\r\n        \t\texprCase.setEnd();\r\n        \t\texpr = exprCase;\r\n        \t\tbreak;\r\n        \tcase SQLTokenizer.IFNULL:\r\n        \t\tswitch(paramCount){\r\n        \t\t\tcase 1:\r\n        \t\t\t\treturn new ExpressionArithmetic( params[0], ExpressionArithmetic.ISNULL );\r\n        \t\t\tcase 2:        \t\t\t\t\r\n        \t\t\t\tinvalidParamCount = false;\r\n        \t\t\t\texpr = new ExpressionFunctionIIF();\r\n        \t\t\t\tExpression[] newParams = new Expression[3];\r\n        \t\t\t\tnewParams[0] = new ExpressionArithmetic( params[0], ExpressionArithmetic.ISNULL );\r\n        \t\t\t\tnewParams[1] = params[1];\r\n        \t\t\t\tnewParams[2] = params[0];        \t\t\t\t\r\n        \t\t\t\tparams = newParams;\r\n        \t\t\t\tparamCount = 3;\r\n        \t\t\t\tbreak;\r\n        \t\t\tdefault:\r\n        \t\t\t\tinvalidParamCount = true;\r\n        \t\t\t\texpr = null; // only for Compiler\r\n        \t\t}\r\n        \t\tbreak;\r\n                    \r\n        // now come the aggregate functions\r\n            case SQLTokenizer.COUNT:\r\n\t\t\t\t\tinvalidParamCount = (paramCount != 1);\r\n\t\t\t\t\tif(params[0].getType() == Expression.NAME){\r\n\t\t\t\t\t\t//detect special case COUNT(*)\r\n\t\t\t\t\t\tExpressionName param = (ExpressionName)params[0];\r\n\t\t\t\t\t\tif(\"*\".equals(param.getName()) && param.getTableAlias() == null){\r\n                            //set any not NULL value as parameter\r\n\t\t\t\t\t\t\tparams[0] = new ExpressionValue(\"*\", SQLTokenizer.VARCHAR);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\texpr = new ExpressionName( Expression.COUNT );\r\n\t\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.SUM:\r\n\t\t\t\t\tinvalidParamCount = (paramCount != 1);\r\n\t\t\t\t\texpr = new ExpressionName( Expression.SUM );\r\n\t\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.MAX:\r\n\t\t\t\t\tinvalidParamCount = (paramCount != 1);\r\n\t\t\t\t\texpr = new ExpressionName( Expression.MAX );\r\n\t\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.MIN:\r\n\t\t\t\t\tinvalidParamCount = (paramCount != 1);\r\n\t\t\t\t\texpr = new ExpressionName( Expression.MIN );\r\n\t\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.FIRST:\r\n\t\t\t\t\tinvalidParamCount = (paramCount != 1);\r\n\t\t\t\t\texpr = new ExpressionName( Expression.FIRST );\r\n\t\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.LAST:\r\n\t\t\t\t\tinvalidParamCount = (paramCount != 1);\r\n\t\t\t\t\texpr = new ExpressionName( Expression.LAST );\r\n\t\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.AVG:\r\n\t\t\t\t\tif(paramCount != 1){\r\n                        invalidParamCount = true;\r\n                        expr = null;//Only for the compiler\r\n                        break;\r\n                    }\r\n\t\t\t\t\texpr = new ExpressionName( Expression.SUM );\r\n\t\t\t\t\texpr.setParams( params );\r\n\t\t\t\t\tExpression expr2 = new ExpressionName( Expression.COUNT );\r\n\t\t\t\t\texpr2.setParams( params );\r\n\t\t\t\t\texpr = new ExpressionArithmetic( expr, expr2, ExpressionArithmetic.DIV );\r\n\t\t\t\t\treturn expr;\r\n            default:\r\n            \tthrow createSyntaxError(token, Language.STXADD_FUNC_UNKNOWN);\r\n        }\r\n        if(invalidParamCount) {\r\n        \tthrow createSyntaxError(token, Language.STXADD_PARAM_INVALID_COUNT);\r\n        }\r\n        expr.setParams( params );\r\n        return expr;\r\n    }\r\n\r\n    /**\r\n     * read a table or view name in a FROM clause. If the keyword AS exists then read it also the alias\r\n     */\r\n    private RowSource tableSource( Command cmd, DataSources tables) throws SQLException{\r\n        SQLToken token = nextToken(MISSING_EXPRESSION);\r\n        switch(token.value){\r\n            case SQLTokenizer.PARENTHESIS_L: // (\r\n                    return rowSource( cmd, tables, SQLTokenizer.PARENTHESIS_R );\r\n            case SQLTokenizer.ESCAPE_L: // {\r\n                    token = nextToken(MISSING_OJ);\r\n                    return rowSource( cmd, tables, SQLTokenizer.ESCAPE_R );\r\n            case SQLTokenizer.SELECT:\r\n            \t\t// inner select\r\n            \t\tViewResult viewResult = new ViewResult( con, select() );\r\n            \t\ttables.add(viewResult);\r\n            \t\treturn viewResult;\r\n        }\r\n        String catalog = null;\r\n        String name = getIdentifier( token );\r\n\t\ttoken = nextToken();\r\n\t\t//check if the table name include a database name\r\n\t\tif(token != null && token.value == SQLTokenizer.POINT){\r\n\t\t\tcatalog = name;\r\n\t\t\tname = nextIdentifier();\r\n\t\t\ttoken = nextToken();\r\n\t\t}\r\n\t\t//TableResult table = new TableResult();\r\n\t\t//table.setName( catalog, name );\r\n\t\tTableView tableView = Database.getTableView( con, catalog, name);\r\n\t\tTableViewResult table = TableViewResult.createResult(tableView);\r\n        tables.add( table );\r\n\r\n        if(token != null && token.value == SQLTokenizer.AS){\r\n            // skip AS keyword, if exists\r\n            token = nextToken(MISSING_EXPRESSION);\r\n            table.setAlias( token.getName( sql ) );\r\n        }else{\r\n            previousToken();\r\n        }\r\n        return table;\r\n    }\r\n    \r\n\r\n    /**\r\n     * read a join in a from clause.\r\n     */\r\n    private Join join(Command cmd, DataSources tables, RowSource left, int type) throws SQLException{\r\n        RowSource right = rowSource(cmd, tables, 0);\r\n        SQLToken token = nextToken();\r\n\r\n        while(true){\r\n            if(token == null) {\r\n            \tthrow createSyntaxError(token, Language.STXADD_JOIN_INVALID);\r\n            }\r\n\r\n            switch(token.value){\r\n            \tcase SQLTokenizer.ON:\r\n\t            \tif(type == Join.RIGHT_JOIN)\r\n\t\t\t\t\t\treturn new Join( Join.LEFT_JOIN, right, left, expression( cmd, 0 ) );\r\n\t                return new Join( type, left, right, expression( cmd, 0 ) );\r\n\t            default:\r\n\t                if(!right.hasAlias()){\r\n\t                    right.setAlias( token.getName( sql ) );\r\n\t                    token = nextToken();\r\n\t                    continue;\r\n\t                }\r\n\t                throw createSyntaxError( token, MISSING_ON );\t                \r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * returns a row source. A row source is a Table, Join, View or a row function.\r\n     *\r\n     */\r\n    private RowSource rowSource(Command cmd, DataSources tables, int parenthesis) throws SQLException{\r\n        RowSource fromSource = null;\r\n        fromSource = tableSource(cmd, tables);\r\n\r\n        while(true){\r\n            SQLToken token = nextToken();\r\n            if(token == null) return fromSource;\r\n            switch(token.value){\r\n                case SQLTokenizer.ON:\r\n                    previousToken();\r\n                    return fromSource;\r\n                case SQLTokenizer.CROSS:\r\n                    nextToken(MISSING_JOIN);\r\n                    //no break\r\n                case SQLTokenizer.COMMA:\r\n                    fromSource = new Join( Join.CROSS_JOIN, fromSource, rowSource(cmd, tables, 0), null);\r\n                    break;\r\n                case SQLTokenizer.INNER:\r\n                    nextToken(MISSING_JOIN);\r\n                    //no break;\r\n                case SQLTokenizer.JOIN:\r\n                    fromSource = join( cmd, tables, fromSource, Join.INNER_JOIN );\r\n                    break;\r\n                case SQLTokenizer.LEFT:\r\n                    token = nextToken(MISSING_OUTER_JOIN);\r\n                \tif(token.value == SQLTokenizer.OUTER)\r\n                \t\ttoken = nextToken(MISSING_JOIN);\r\n                    fromSource = join( cmd, tables, fromSource, Join.LEFT_JOIN );\r\n                    break;\r\n                case SQLTokenizer.RIGHT:\r\n                \ttoken = nextToken(MISSING_OUTER_JOIN);\r\n                \tif(token.value == SQLTokenizer.OUTER)\r\n                \t\ttoken = nextToken(MISSING_JOIN);\r\n\t\t\t\t\tfromSource = join( cmd, tables, fromSource, Join.RIGHT_JOIN );\r\n\t\t\t\t\tbreak;                \t\r\n\t\t\t\tcase SQLTokenizer.FULL:\r\n\t\t\t\t\ttoken = nextToken(MISSING_OUTER_JOIN);\r\n\t\t\t\t\tif(token.value == SQLTokenizer.OUTER)\r\n\t\t\t\t\t\ttoken = nextToken(MISSING_JOIN);\r\n\t\t\t\t\tfromSource = join( cmd, tables, fromSource, Join.FULL_JOIN );\r\n\t\t\t\t\tbreak;                \t\r\n                case SQLTokenizer.PARENTHESIS_R:\r\n                case SQLTokenizer.ESCAPE_R:\r\n                    if(parenthesis == token.value) return fromSource;\r\n                    if(parenthesis == 0){\r\n                    \tpreviousToken();\r\n\t\t\t\t\t\treturn fromSource;\r\n                    }\r\n                    throw createSyntaxError( token, Language.STXADD_FROM_PAR_CLOSE );\r\n                default:\r\n                \tif(isKeyword(token)){\r\n\t\t\t\t\t\tpreviousToken();\r\n\t\t\t\t\t\treturn fromSource;\r\n                \t}\r\n                    if(!fromSource.hasAlias()){\r\n                        fromSource.setAlias( token.getName( sql ) );\r\n                        break;\r\n                    }\r\n                    throw createSyntaxError( token, new int[]{SQLTokenizer.COMMA, SQLTokenizer.GROUP, SQLTokenizer.ORDER, SQLTokenizer.HAVING} );\r\n            }\r\n        }\r\n    }\r\n\r\n    private void from(CommandSelect cmd) throws SQLException{\r\n\t\tDataSources tables = new DataSources();\r\n        cmd.setTables(tables);\r\n        cmd.setSource( rowSource( cmd, tables, 0 ) );\r\n\r\n\t\tSQLToken token;\r\n        while(null != (token = nextToken())){\r\n            switch(token.value){\r\n                case SQLTokenizer.WHERE:\r\n                    where( cmd );\r\n                    break;\r\n                case SQLTokenizer.GROUP:\r\n                    group( cmd );\r\n                    break;\r\n                case SQLTokenizer.HAVING:\r\n                    having( cmd );\r\n                    break;\r\n                default:\r\n                \tpreviousToken();\r\n                    return;\r\n            }\r\n        }\r\n    }\r\n\r\n    private void order(CommandSelect cmd) throws SQLException{\r\n        nextToken(MISSING_BY);\r\n        cmd.setOrder(expressionTokenList(cmd, SQLTokenizer.ORDER));\r\n    }\r\n    \r\n    private void limit(CommandSelect selCmd) throws SQLException{\r\n        SQLToken token = nextToken(MISSING_EXPRESSION);\r\n        try{\r\n            int maxRows = Integer.parseInt(token.getName(sql));\r\n            selCmd.setMaxRows(maxRows);\r\n        }catch(NumberFormatException e){\r\n            throw createSyntaxError(token, Language.STXADD_NOT_NUMBER, token.getName(sql));\r\n        }\r\n    }\r\n\r\n    private void group(CommandSelect cmd) throws SQLException{\r\n        nextToken(MISSING_BY);\r\n        cmd.setGroup( expressionTokenList(cmd, SQLTokenizer.GROUP) );\r\n    }\r\n\r\n    private void where(CommandSelect cmd) throws SQLException{\r\n        cmd.setWhere( expression(cmd, 0) );\r\n    }\r\n\r\n    private void having(CommandSelect cmd) throws SQLException{\r\n        cmd.setHaving( expression(cmd, 0) );\r\n    }\r\n\r\n\r\n    private static final int[] COMMANDS = {SQLTokenizer.SELECT, SQLTokenizer.DELETE, SQLTokenizer.INSERT, SQLTokenizer.UPDATE, SQLTokenizer.CREATE, SQLTokenizer.DROP, SQLTokenizer.ALTER, SQLTokenizer.SET, SQLTokenizer.USE, SQLTokenizer.EXECUTE, SQLTokenizer.TRUNCATE};\r\n    private static final int[] COMMANDS_ESCAPE = {SQLTokenizer.D, SQLTokenizer.T, SQLTokenizer.TS, SQLTokenizer.FN, SQLTokenizer.CALL};\r\n    private static final int[] COMMANDS_ALTER = {SQLTokenizer.DATABASE, SQLTokenizer.TABLE, SQLTokenizer.VIEW,  SQLTokenizer.PROCEDURE, };\r\n    private static final int[] COMMANDS_CREATE = {SQLTokenizer.DATABASE, SQLTokenizer.TABLE, SQLTokenizer.VIEW, SQLTokenizer.INDEX, SQLTokenizer.PROCEDURE, SQLTokenizer.UNIQUE, SQLTokenizer.CLUSTERED, SQLTokenizer.NONCLUSTERED};\r\n    private static final int[] COMMANDS_DROP = {SQLTokenizer.DATABASE, SQLTokenizer.TABLE, SQLTokenizer.VIEW, SQLTokenizer.INDEX, SQLTokenizer.PROCEDURE};\r\n    private static final int[] COMMANDS_SET = {SQLTokenizer.TRANSACTION};\r\n    private static final int[] COMMANDS_CREATE_UNIQUE = {SQLTokenizer.INDEX, SQLTokenizer.CLUSTERED, SQLTokenizer.NONCLUSTERED};\r\n\tprivate static final int[] MISSING_TABLE = {SQLTokenizer.TABLE};\r\n    private static final int[] ESCAPE_MISSING_CLOSE = {SQLTokenizer.ESCAPE_R};\r\n    private static final int[] MISSING_EXPRESSION = {SQLTokenizer.VALUE};\r\n    private static final int[] MISSING_IDENTIFIER = {SQLTokenizer.IDENTIFIER};\r\n    private static final int[] MISSING_BY = {SQLTokenizer.BY};\r\n    private static final int[] MISSING_PARENTHESIS_L = {SQLTokenizer.PARENTHESIS_L};\r\n    private static final int[] MISSING_PARENTHESIS_R = {SQLTokenizer.PARENTHESIS_R};\r\n    private static final int[] MISSING_DATATYPE  = {SQLTokenizer.BIT, SQLTokenizer.BOOLEAN, SQLTokenizer.BINARY, SQLTokenizer.VARBINARY, SQLTokenizer.RAW, SQLTokenizer.LONGVARBINARY, SQLTokenizer.BLOB, SQLTokenizer.TINYINT, SQLTokenizer.SMALLINT, SQLTokenizer.INT, SQLTokenizer.COUNTER, SQLTokenizer. BIGINT, SQLTokenizer.SMALLMONEY, SQLTokenizer.MONEY, SQLTokenizer.DECIMAL, SQLTokenizer.NUMERIC, SQLTokenizer.REAL, SQLTokenizer.FLOAT, SQLTokenizer.DOUBLE, SQLTokenizer.DATE, SQLTokenizer.TIME, SQLTokenizer.TIMESTAMP, SQLTokenizer.SMALLDATETIME, SQLTokenizer.CHAR, SQLTokenizer.NCHAR, SQLTokenizer.VARCHAR, SQLTokenizer.NVARCHAR, SQLTokenizer.LONG, SQLTokenizer.LONGNVARCHAR, SQLTokenizer.LONGVARCHAR, SQLTokenizer.CLOB, SQLTokenizer.NCLOB, SQLTokenizer.UNIQUEIDENTIFIER, SQLTokenizer.JAVA_OBJECT, SQLTokenizer.SYSNAME};\r\n\tprivate static final int[] MISSING_SQL_DATATYPE = { SQLTokenizer.SQL_BIGINT , SQLTokenizer.SQL_BINARY , SQLTokenizer.SQL_BIT , SQLTokenizer.SQL_CHAR , SQLTokenizer.SQL_DATE , SQLTokenizer.SQL_DECIMAL , SQLTokenizer.SQL_DOUBLE , SQLTokenizer.SQL_FLOAT , SQLTokenizer.SQL_INTEGER , SQLTokenizer.SQL_LONGVARBINARY , SQLTokenizer.SQL_LONGVARCHAR , SQLTokenizer.SQL_REAL , SQLTokenizer.SQL_SMALLINT , SQLTokenizer.SQL_TIME , SQLTokenizer.SQL_TIMESTAMP , SQLTokenizer.SQL_TINYINT , SQLTokenizer.SQL_VARBINARY , SQLTokenizer.SQL_VARCHAR };\r\n    private static final int[] MISSING_INTO = {SQLTokenizer.INTO};\r\n\tprivate static final int[] MISSING_BETWEEN_IN = {SQLTokenizer.BETWEEN, SQLTokenizer.IN};\r\n\tprivate static final int[] MISSING_NOT_NULL = {SQLTokenizer.NOT, SQLTokenizer.NULL};\r\n    private static final int[] MISSING_NULL = {SQLTokenizer.NULL};\r\n\tprivate static final int[] MISSING_COMMA = {SQLTokenizer.COMMA};\r\n    private static final int[] MISSING_COMMA_PARENTHESIS = {SQLTokenizer.COMMA, SQLTokenizer.PARENTHESIS_R};\r\n    private static final int[] MISSING_PARENTHESIS_VALUES_SELECT = {SQLTokenizer.PARENTHESIS_L, SQLTokenizer.VALUES, SQLTokenizer.SELECT};\r\n    private static final int[] MISSING_TOKEN_LIST = {SQLTokenizer.COMMA, SQLTokenizer.FROM, SQLTokenizer.GROUP, SQLTokenizer.HAVING, SQLTokenizer.ORDER};\r\n\tprivate static final int[] MISSING_FROM = {SQLTokenizer.FROM};\r\n\tprivate static final int[] MISSING_SET = {SQLTokenizer.SET};\r\n\tprivate static final int[] MISSING_EQUALS = {SQLTokenizer.EQUALS};\r\n\tprivate static final int[] MISSING_WHERE = {SQLTokenizer.WHERE};\r\n\tprivate static final int[] MISSING_WHERE_COMMA = {SQLTokenizer.WHERE, SQLTokenizer.COMMA};\r\n    private static final int[] MISSING_ISOLATION = {SQLTokenizer.ISOLATION};\r\n    private static final int[] MISSING_LEVEL = {SQLTokenizer.LEVEL};\r\n    private static final int[] COMMANDS_TRANS_LEVEL = {SQLTokenizer.READ, SQLTokenizer.REPEATABLE, SQLTokenizer.SERIALIZABLE};\r\n    private static final int[] MISSING_READ = {SQLTokenizer.READ};\r\n    private static final int[] MISSING_COMM_UNCOMM = {SQLTokenizer.COMMITTED, SQLTokenizer.UNCOMMITTED};\r\n    private static final int[] MISSING_OPTIONS_DATATYPE = { SQLTokenizer.DEFAULT, SQLTokenizer.IDENTITY, SQLTokenizer.NOT, SQLTokenizer.NULL, SQLTokenizer.PRIMARY, SQLTokenizer.UNIQUE, SQLTokenizer.COMMA, SQLTokenizer.PARENTHESIS_R};\r\n    private static final int[] MISSING_NUMBERVALUE = {SQLTokenizer.NUMBERVALUE};\r\n    private static final int[] MISSING_AND = {SQLTokenizer.AND};\r\n    private static final int[] MISSING_JOIN = {SQLTokenizer.JOIN};\r\n    private static final int[] MISSING_OUTER_JOIN = {SQLTokenizer.OUTER, SQLTokenizer.JOIN};\r\n    private static final int[] MISSING_OJ = {SQLTokenizer.OJ};\r\n    private static final int[] MISSING_ON = {SQLTokenizer.ON};\r\n\tprivate static final int[] MISSING_KEYTYPE = {SQLTokenizer.PRIMARY, SQLTokenizer.UNIQUE, SQLTokenizer.FOREIGN};\r\n\tprivate static final int[] MISSING_KEY = {SQLTokenizer.KEY};\r\n    private static final int[] MISSING_REFERENCES = {SQLTokenizer.REFERENCES};\r\n\tprivate static final int[] MISSING_AS = {SQLTokenizer.AS};\r\n\tprivate static final int[] MISSING_SELECT = {SQLTokenizer.SELECT};\r\n\tprivate static final int[] MISSING_INTERVALS = {SQLTokenizer.SQL_TSI_FRAC_SECOND, SQLTokenizer.SQL_TSI_SECOND, SQLTokenizer.SQL_TSI_MINUTE, SQLTokenizer.SQL_TSI_HOUR, SQLTokenizer.SQL_TSI_DAY, SQLTokenizer.SQL_TSI_WEEK, SQLTokenizer.SQL_TSI_MONTH, SQLTokenizer.SQL_TSI_QUARTER, SQLTokenizer.SQL_TSI_YEAR, SQLTokenizer.MILLISECOND, SQLTokenizer.SECOND, SQLTokenizer.MINUTE, SQLTokenizer.HOUR, SQLTokenizer.DAY, SQLTokenizer.WEEK, SQLTokenizer.MONTH, SQLTokenizer.QUARTER, SQLTokenizer.YEAR, SQLTokenizer.D};\r\n\tprivate static final int[] MISSING_ALL = {SQLTokenizer.ALL};\r\n\tprivate static final int[] MISSING_THEN = {SQLTokenizer.THEN};\r\n\tprivate static final int[] MISSING_WHEN_ELSE_END = {SQLTokenizer.WHEN, SQLTokenizer.ELSE, SQLTokenizer.END};\r\n\tprivate static final int[] MISSING_ADD_ALTER_DROP = {SQLTokenizer.ADD, SQLTokenizer.ALTER, SQLTokenizer.DROP};\r\n\t\r\n\t\r\n}"},{"path":"/src/smallsql/database/SSDatabaseMetaData.java","source":"/* =============================================================\r\n * SmallSQL : a free Java DBMS library for the Java(tm) platform\r\n * =============================================================\r\n *\r\n * (C) Copyright 2004-2007, by Volker Berlin.\r\n *\r\n * Project Info:  http://www.smallsql.de/\r\n *\r\n * This library is free software; you can redistribute it and/or modify it \r\n * under the terms of the GNU Lesser General Public License as published by \r\n * the Free Software Foundation; either version 2.1 of the License, or \r\n * (at your option) any later version.\r\n *\r\n * This library is distributed in the hope that it will be useful, but \r\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \r\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public \r\n * License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, \r\n * USA.  \r\n *\r\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc. \r\n * in the United States and other countries.]\r\n *\r\n * ---------------\r\n * SSDatabaseMetaData.java\r\n * ---------------\r\n * Author: Volker Berlin\r\n * \r\n */\r\npackage smallsql.database;\r\n\r\nimport java.sql.*;\r\nimport java.util.ArrayList;\r\n\r\n\r\nfinal class SSDatabaseMetaData implements DatabaseMetaData {\r\n\tfinal private SSConnection con;\r\n\tfinal private SSStatement st;\r\n\t\r\n\t\r\n    /**\r\n     * @throws SQLException Exception can be throw if the Connection already closed.\r\n     */\r\n    SSDatabaseMetaData(SSConnection con) throws SQLException{\r\n\t\tthis.con = con;\r\n\t\tst = new SSStatement(con);\r\n\t}\r\n\t\r\n    public boolean allProceduresAreCallable() {\r\n    \treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean allTablesAreSelectable() {\r\n    \treturn true;\r\n    }\r\n\t\r\n\t\r\n    public String getURL() throws SQLException {\r\n    \tDatabase database = con.getDatabase(true);\r\n    \tif(database == null)\r\n\t\t\treturn SSDriver.URL_PREFIX;\r\n    \treturn SSDriver.URL_PREFIX + ':' + database.getName();\r\n    }\r\n\t\r\n\t\r\n    public String getUserName() {\r\n    \treturn \"\";\r\n    }\r\n\t\r\n\t\r\n    public boolean isReadOnly() {\r\n    \treturn false;\r\n    }\r\n\t\r\n\t\r\n    public boolean nullsAreSortedHigh() {\r\n\t\treturn false;\r\n    }\r\n\t\r\n\t\r\n    public boolean nullsAreSortedLow() {\r\n\t\treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean nullsAreSortedAtStart() {\r\n\t\treturn false;\r\n    }\r\n\t\r\n\t\r\n    public boolean nullsAreSortedAtEnd() {\r\n\t\treturn false;\r\n    }\r\n\t\r\n\t\r\n    public String getDatabaseProductName() {\r\n    \treturn \"SmallSQL Database\";\r\n    }\r\n\t\r\n\t\r\n    public String getDatabaseProductVersion() {\r\n    \treturn getDriverVersion();\r\n    }\r\n\t\r\n\t\r\n    public String getDriverName(){\r\n    \treturn \"SmallSQL Driver\";\r\n    }\r\n\t\r\n\t\r\n    public String getDriverVersion() {\r\n    \treturn getDriverMajorVersion() + \".\" + SSDriver.drv.getMinorVersion();\r\n    }\r\n\t\r\n\t\r\n    public int getDriverMajorVersion() {\r\n    \treturn SSDriver.drv.getMajorVersion();\r\n    }\r\n\t\r\n\t\r\n    public int getDriverMinorVersion() {\r\n\t\treturn SSDriver.drv.getMinorVersion();\r\n    }\r\n\t\r\n\t\r\n    public boolean usesLocalFiles() {\r\n    \treturn false;\r\n    }\r\n\t\r\n\t\r\n    public boolean usesLocalFilePerTable() {\r\n    \treturn false;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsMixedCaseIdentifiers() {\r\n    \treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean storesUpperCaseIdentifiers() {\r\n    \treturn false;\r\n    }\r\n\t\r\n\t\r\n    public boolean storesLowerCaseIdentifiers() {\r\n    \treturn false;\r\n    }\r\n\t\r\n\t\r\n    public boolean storesMixedCaseIdentifiers() {\r\n    \treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsMixedCaseQuotedIdentifiers() {\r\n    \treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean storesUpperCaseQuotedIdentifiers() {\r\n    \treturn false;\r\n    }\r\n\t\r\n\t\r\n    public boolean storesLowerCaseQuotedIdentifiers() {\r\n    \treturn false;\r\n    }\r\n\t\r\n\t\r\n    public boolean storesMixedCaseQuotedIdentifiers() {\r\n    \treturn true;\r\n    }\r\n\t\r\n\t\r\n    public String getIdentifierQuoteString() {\r\n    \treturn \"\\\"\";\r\n    }\r\n\t\r\n\t\r\n    public String getSQLKeywords() {\r\n    \treturn \"database,use\";\r\n    }\r\n    \r\n    \r\n    private String getFunctions(int from, int to){\r\n\t\tStringBuffer buf = new StringBuffer();\r\n\t\tfor(int i=from; i<=to; i++){\r\n\t\t\tif(i != from) buf.append(',');\r\n\t\t\tbuf.append( SQLTokenizer.getKeyWord(i) );\r\n\t\t}\r\n\t\treturn buf.toString();\r\n    }\r\n    \r\n    \r\n    public String getNumericFunctions() {\r\n    \treturn getFunctions(SQLTokenizer.ABS, SQLTokenizer.TRUNCATE);\r\n    }\r\n    \r\n    \r\n    public String getStringFunctions() {\r\n\t\treturn getFunctions(SQLTokenizer.ASCII, SQLTokenizer.UCASE);\r\n    }\r\n    \r\n    \r\n    public String getSystemFunctions() {\r\n\t\treturn getFunctions(SQLTokenizer.IFNULL, SQLTokenizer.IIF);\r\n    }\r\n    \r\n    \r\n    public String getTimeDateFunctions() {\r\n\t\treturn getFunctions(SQLTokenizer.CURDATE, SQLTokenizer.YEAR);\r\n    }\r\n    \r\n    \r\n    public String getSearchStringEscape() {\r\n    \treturn \"\\\\\";\r\n    }\r\n    \r\n    \r\n    public String getExtraNameCharacters() {\r\n    \treturn \"#$Ã€Ã�Ã‚ÃƒÃ„Ã…Ã†Ã‡ÃˆÃ‰ÃŠÃ‹ÃŒÃ�ÃŽÃ�Ã�Ã‘Ã’Ã“Ã”Ã•Ã–Ã˜Ã™ÃšÃ›ÃœÃ�ÃžÃŸÃ Ã¡Ã¢Ã£Ã¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯Ã°Ã±Ã²Ã³Ã´ÃµÃ¶Ã¸Ã¹ÃºÃ»Ã¼Ã½Ã¾Ã¿\";\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsAlterTableWithAddColumn() {\r\n        /**@todo: Implement this java.sql.DatabaseMetaData method*/\r\n        throw new java.lang.UnsupportedOperationException(\"Method supportsAlterTableWithAddColumn() not yet implemented.\");\r\n    }\r\n    public boolean supportsAlterTableWithDropColumn() {\r\n        /**@todo: Implement this java.sql.DatabaseMetaData method*/\r\n        throw new java.lang.UnsupportedOperationException(\"Method supportsAlterTableWithDropColumn() not yet implemented.\");\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsColumnAliasing() {\r\n    \treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean nullPlusNonNullIsNull() {\r\n    \treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsConvert() {\r\n    \treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsConvert(int fromType, int toType) {\r\n    \treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsTableCorrelationNames() {\r\n    \treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsDifferentTableCorrelationNames() {\r\n    \treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsExpressionsInOrderBy() {\r\n    \treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsOrderByUnrelated() {\r\n    \treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsGroupBy() {\r\n    \treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsGroupByUnrelated() {\r\n    \treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsGroupByBeyondSelect() {\r\n    \treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsLikeEscapeClause() {\r\n    \treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsMultipleResultSets() {\r\n    \treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsMultipleTransactions() {\r\n    \treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsNonNullableColumns() {\r\n    \treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsMinimumSQLGrammar() {\r\n    \treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsCoreSQLGrammar() {\r\n\t\treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsExtendedSQLGrammar() {\r\n    \treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsANSI92EntryLevelSQL() {\r\n    \treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsANSI92IntermediateSQL() {\r\n    \treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsANSI92FullSQL() {\r\n    \treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsIntegrityEnhancementFacility() {\r\n    \treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsOuterJoins() {\r\n    \treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsFullOuterJoins() {\r\n    \treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsLimitedOuterJoins() {\r\n    \treturn true;\r\n    }\r\n\t\r\n\t\r\n    public String getSchemaTerm() {\r\n    \treturn \"owner\";\r\n    }\r\n\t\r\n\t\r\n    public String getProcedureTerm() {\r\n    \treturn \"procedure\";\r\n    }\r\n\t\r\n\t\r\n    public String getCatalogTerm() {\r\n    \treturn \"database\";\r\n    }\r\n\t\r\n\t\r\n    public boolean isCatalogAtStart() {\r\n    \treturn true;\r\n    }\r\n\t\r\n\t\r\n    public String getCatalogSeparator() {\r\n    \treturn \".\";\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsSchemasInDataManipulation() {\r\n    \treturn false;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsSchemasInProcedureCalls() {\r\n    \treturn false;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsSchemasInTableDefinitions() {\r\n    \treturn false;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsSchemasInIndexDefinitions() {\r\n    \treturn false;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsSchemasInPrivilegeDefinitions() {\r\n    \treturn false;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsCatalogsInDataManipulation() {\r\n\t\treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsCatalogsInProcedureCalls() {\r\n    \treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsCatalogsInTableDefinitions() {\r\n    \treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsCatalogsInIndexDefinitions() {\r\n\t\treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsCatalogsInPrivilegeDefinitions() {\r\n\t\treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsPositionedDelete() {\r\n    \treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsPositionedUpdate() {\r\n\t\treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsSelectForUpdate() {\r\n\t\treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsStoredProcedures() {\r\n    \treturn false;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsSubqueriesInComparisons() {\r\n\t\treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsSubqueriesInExists() {\r\n\t\treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsSubqueriesInIns() {\r\n\t\treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsSubqueriesInQuantifieds() {\r\n\t\treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsCorrelatedSubqueries() {\r\n\t\treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsUnion() {\r\n\t\treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsUnionAll() {\r\n\t\treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsOpenCursorsAcrossCommit() {\r\n    \treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsOpenCursorsAcrossRollback() {\r\n    \treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsOpenStatementsAcrossCommit() {\r\n    \treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsOpenStatementsAcrossRollback() {\r\n    \treturn true;\r\n    }\r\n\t\r\n\t\r\n    public int getMaxBinaryLiteralLength() {\r\n    \treturn 0;\r\n    }\r\n\t\r\n\t\r\n    public int getMaxCharLiteralLength() {\r\n    \treturn 0;\r\n    }\r\n\t\r\n\t\r\n    public int getMaxColumnNameLength() {\r\n    \treturn 255;\r\n    }\r\n\t\r\n\t\r\n    public int getMaxColumnsInGroupBy() {\r\n    \treturn 0;\r\n    }\r\n\t\r\n\t\r\n    public int getMaxColumnsInIndex() {\r\n    \treturn 0;\r\n    }\r\n\t\r\n\t\r\n    public int getMaxColumnsInOrderBy() {\r\n    \treturn 0;\r\n    }\r\n\t\r\n\t\r\n    public int getMaxColumnsInSelect() {\r\n    \treturn 0;\r\n    }\r\n\t\r\n\t\r\n    public int getMaxColumnsInTable() {\r\n    \treturn 0;\r\n    }\r\n\t\r\n\t\r\n    public int getMaxConnections() {\r\n    \treturn 0;\r\n    }\r\n\t\r\n\t\r\n    public int getMaxCursorNameLength() {\r\n    \treturn 0;\r\n    }\r\n\t\r\n\t\r\n    public int getMaxIndexLength() {\r\n    \treturn 0;\r\n    }\r\n\t\r\n\t\r\n    public int getMaxSchemaNameLength() {\r\n    \treturn 255;\r\n    }\r\n\t\r\n\t\r\n    public int getMaxProcedureNameLength() {\r\n    \treturn 255;\r\n    }\r\n\t\r\n\t\r\n    public int getMaxCatalogNameLength() {\r\n    \treturn 255;\r\n    }\r\n\t\r\n\t\r\n    public int getMaxRowSize() {\r\n    \treturn 0;\r\n    }\r\n\t\r\n\t\r\n    public boolean doesMaxRowSizeIncludeBlobs() {\r\n    \treturn false;\r\n    }\r\n\t\r\n\t\r\n    public int getMaxStatementLength() {\r\n    \treturn 0;\r\n    }\r\n\t\r\n\t\r\n    public int getMaxStatements() {\r\n    \treturn 0;\r\n    }\r\n\t\r\n\t\r\n    public int getMaxTableNameLength() {\r\n    \treturn 255;\r\n    }\r\n\t\r\n\t\r\n    public int getMaxTablesInSelect() {\r\n    \treturn 0;\r\n    }\r\n\t\r\n\t\r\n    public int getMaxUserNameLength() {\r\n    \treturn 0;\r\n    }\r\n\t\r\n\t\r\n    public int getDefaultTransactionIsolation() {\r\n    \treturn Connection.TRANSACTION_READ_COMMITTED;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsTransactions() {\r\n    \treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsTransactionIsolationLevel(int level) {\r\n    \tswitch(level){\r\n\t\t\tcase Connection.TRANSACTION_NONE:\r\n\t\t\tcase Connection.TRANSACTION_READ_UNCOMMITTED:\r\n    \t\tcase Connection.TRANSACTION_READ_COMMITTED:\r\n\t\t\tcase Connection.TRANSACTION_REPEATABLE_READ:\r\n\t\t\tcase Connection.TRANSACTION_SERIALIZABLE:\r\n\t\t\t\treturn true;\r\n    \t}\r\n    \treturn false;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsDataDefinitionAndDataManipulationTransactions() {\r\n    \treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsDataManipulationTransactionsOnly() {\r\n    \treturn false;\r\n    }\r\n\t\r\n\t\r\n    public boolean dataDefinitionCausesTransactionCommit() {\r\n    \treturn false;\r\n    }\r\n\t\r\n\t\r\n    public boolean dataDefinitionIgnoredInTransactions() {\r\n    \treturn false;\r\n    }\r\n\t\r\n\t\r\n    public ResultSet getProcedures(String catalog, String schemaPattern, String procedureNamePattern) throws SQLException {\r\n\t\tString[] colNames = {\"PROCEDURE_CAT\", \"PROCEDURE_SCHEM\", \"PROCEDURE_NAME\", \"\", \"\", \"\", \"REMARKS\", \"PROCEDURE_TYPE\"};  \r\n\t\tObject[][] data   = new Object[0][];\r\n\t\treturn new SSResultSet( st, Utils.createMemoryCommandSelect( con, colNames, data));\r\n    }\r\n\t\r\n\t\r\n    public ResultSet getProcedureColumns(String catalog, String schemaPattern, String procedureNamePattern, String columnNamePattern) throws SQLException {\r\n\t\tString[] colNames = {\"PROCEDURE_CAT\", \"PROCEDURE_SCHEM\", \"PROCEDURE_NAME\", \"COLUMN_NAME\", \"COLUMN_TYPE\", \"DATA_TYPE\", \"TYPE_NAME\", \"PRECISION\", \"LENGTH\", \"SCALE\", \"RADIX\", \"NULLABLE\", \"REMARKS\" };\r\n\t\tObject[][] data   = new Object[0][];\r\n\t\treturn new SSResultSet( st, Utils.createMemoryCommandSelect( con, colNames, data));\r\n    }\r\n\t\r\n\t\r\n    public ResultSet getTables(String catalog, String schemaPattern, String tableNamePattern, String[] types) throws SQLException {\r\n\t\tString[] colNames = {\"TABLE_CAT\",\"TABLE_SCHEM\",\"TABLE_NAME\",\"TABLE_TYPE\",\"REMARKS\",\"TYPE_CAT\",\"TYPE_SCHEM\",\"TYPE_NAME\",\"SELF_REFERENCING_COL_NAME\",\"REF_GENERATION\"};\r\n\t\tDatabase database;\r\n\t\tif(catalog == null){ \r\n\t\t\tdatabase = con.getDatabase(true);\r\n\t\t\tif(database != null)\r\n\t\t\t\tcatalog = database.getName();\r\n    \t}else{\r\n\t\t\tdatabase = Database.getDatabase(catalog, con, false);\r\n    \t}\r\n\t\tArrayList rows = new ArrayList();\r\n\t\tboolean isTypeTable = types == null;\r\n\t\tboolean isTypeView = types == null;\r\n\t\tfor(int i=0; types != null && i<types.length; i++){\r\n\t\t\tif(\"TABLE\".equalsIgnoreCase(types[i])) isTypeTable = true;\r\n\t\t\tif(\"VIEW\" .equalsIgnoreCase(types[i])) isTypeView  = true;\r\n\t\t}\r\n\t\t\r\n\t\tif(database != null){\r\n\t\t\tStrings tables = database.getTables(tableNamePattern);\r\n\t\t\tfor(int i=0; i<tables.size(); i++){\r\n\t\t\t\tString table = tables.get(i);\r\n\t\t\t\tObject[] row = new Object[10];\r\n\t\t\t\trow[0] = catalog;\r\n\t\t\t\trow[2] = table;\r\n\t\t\t\ttry{\r\n\t\t\t\t\tif(database.getTableView( con, table) instanceof View){\r\n\t\t\t\t\t\tif(isTypeView){\r\n\t\t\t\t\t\t\trow[3] = \"VIEW\";\r\n\t\t\t\t\t\t\trows.add(row);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tif(isTypeTable){\r\n\t\t\t\t\t\t\trow[3] = \"TABLE\";\t\t\t\t\t\r\n\t\t\t\t\t\t\trows.add(row);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}catch(Exception e){\r\n\t\t\t\t\t//TODO invalid VIEWS does not show because it can't load.\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tObject[][] data = new Object[rows.size()][];\r\n\t\trows.toArray(data);\r\n\t\tCommandSelect cmdSelect = Utils.createMemoryCommandSelect( con, colNames, data);\r\n\t\tExpressions order = new Expressions();\r\n\t\torder.add( new ExpressionName(\"TABLE_TYPE\") );\r\n\t\torder.add( new ExpressionName(\"TABLE_NAME\") );\r\n\t\tcmdSelect.setOrder( order );\r\n\t\treturn new SSResultSet( st, cmdSelect);\r\n    }\r\n\t\r\n\t\r\n    public ResultSet getSchemas() throws SQLException {\r\n\t\tString[] colNames = {\"TABLE_SCHEM\"};\r\n\t\tObject[][] data   = new Object[0][];\r\n\t\treturn new SSResultSet( st, Utils.createMemoryCommandSelect( con, colNames, data));\r\n    }\r\n\t\r\n    \r\n    public ResultSet getCatalogs() throws SQLException {\r\n    \tString[] colNames = {\"TABLE_CAT\"};\r\n    \tObject[][] data   = Database.getCatalogs(con.getDatabase(true));\r\n    \treturn new SSResultSet( st, Utils.createMemoryCommandSelect( con, colNames, data));\r\n    }\r\n\t\r\n    \r\n    public ResultSet getTableTypes() throws SQLException {\r\n\t\tString[] colNames = {\"TABLE_TYPE\"};\r\n\t\tObject[][] data   = {{\"SYSTEM TABLE\"}, {\"TABLE\"}, {\"VIEW\"}};\r\n\t\treturn new SSResultSet( st, Utils.createMemoryCommandSelect( con, colNames, data));\r\n    }\r\n\t\r\n    \r\n    public ResultSet getColumns(String catalog, String schemaPattern, String tableNamePattern, String columnNamePattern) throws SQLException {\r\n\t\ttry {\r\n\t\t\tString[] colNames = {\"TABLE_CAT\", \"TABLE_SCHEM\", \"TABLE_NAME\", \"COLUMN_NAME\", \"DATA_TYPE\", \"TYPE_NAME\", \"COLUMN_SIZE\", \"BUFFER_LENGTH\", \"DECIMAL_DIGITS\", \"NUM_PREC_RADIX\", \"NULLABLE\", \"REMARKS\", \"COLUMN_DEF\", \"SQL_DATA_TYPE\", \"SQL_DATETIME_SUB\", \"CHAR_OCTET_LENGTH\", \"ORDINAL_POSITION\", \"IS_NULLABLE\"};\r\n\t\t\tObject[][] data   = con.getDatabase(false).getColumns(con, tableNamePattern, columnNamePattern);\r\n\t\t\treturn new SSResultSet( st, Utils.createMemoryCommandSelect( con, colNames, data));\r\n\t\t} catch (Exception e) {\r\n\t\t\tthrow SmallSQLException.createFromException(e);\r\n\t\t}\r\n    }\r\n\t\r\n\t\r\n    public ResultSet getColumnPrivileges(String catalog, String schema, String table, String columnNamePattern) throws SQLException {\r\n        String[] colNames = {\"TABLE_CAT\", \"TABLE_SCHEM\", \"TABLE_NAME\", \"COLUMN_NAME\", \"GRANTOR\", \"GRANTEE\", \"PRIVILEGE\", \"IS_GRANTABLE\"};\r\n        /**@todo: Implement this java.sql.DatabaseMetaData method*/\r\n        throw new java.lang.UnsupportedOperationException(\"Method getColumnPrivileges() not yet implemented.\");\r\n    }\r\n    \r\n    \r\n    public ResultSet getTablePrivileges(String catalog, String schemaPattern, String tableNamePattern) throws SQLException {\r\n        String[] colNames = {\"TABLE_CAT\", \"TABLE_SCHEM\", \"TABLE_NAME\", \"GRANTOR\", \"GRANTEE\", \"PRIVILEGE\", \"IS_GRANTABLE\"};\r\n        /**@todo: Implement this java.sql.DatabaseMetaData method*/\r\n        throw new java.lang.UnsupportedOperationException(\"Method getTablePrivileges() not yet implemented.\");\r\n    }\r\n\t\r\n\t\r\n    public ResultSet getBestRowIdentifier(String catalog, String schema, String table, int scope, boolean nullable) throws SQLException {\r\n\t\ttry {\r\n\t\t\tString[] colNames = {\"SCOPE\", \"COLUMN_NAME\", \"DATA_TYPE\", \"TYPE_NAME\", \"COLUMN_SIZE\", \"BUFFER_LENGTH\", \"DECIMAL_DIGITS\", \"PSEUDO_COLUMN\"};\r\n\t\t\tObject[][] data   = con.getDatabase(false).getBestRowIdentifier(con, table);\r\n\t\t\treturn new SSResultSet( st, Utils.createMemoryCommandSelect( con, colNames, data));\r\n\t\t} catch (Exception e) {\r\n\t\t\tthrow SmallSQLException.createFromException(e);\r\n\t\t}\r\n    }\r\n\t\r\n\t\r\n    public ResultSet getVersionColumns(String catalog, String schema, String table) throws SQLException {\r\n\t\ttry {\r\n\t\t\tString[] colNames = {\"SCOPE\", \"COLUMN_NAME\", \"DATA_TYPE\", \"TYPE_NAME\", \"COLUMN_SIZE\", \"BUFFER_LENGTH\", \"DECIMAL_DIGITS\", \"PSEUDO_COLUMN\"};\r\n\t\t\tObject[][] data   = new Object[0][0];\r\n\t\t\treturn new SSResultSet( st, Utils.createMemoryCommandSelect( con, colNames, data));\r\n\t\t} catch (Exception e) {\r\n\t\t\tthrow SmallSQLException.createFromException(e);\r\n\t\t}\r\n    }\r\n\t\r\n\t\r\n    public ResultSet getPrimaryKeys(String catalog, String schema, String table) throws SQLException {\r\n\t\ttry {\r\n\t\t\tString[] colNames = {\"TABLE_CAT\", \"TABLE_SCHEM\", \"TABLE_NAME\", \"COLUMN_NAME\", \"KEY_SEQ\", \"PK_NAME\"};\r\n\t\t\tObject[][] data   = con.getDatabase(false).getPrimaryKeys(con, table);\r\n\t\t\treturn new SSResultSet( st, Utils.createMemoryCommandSelect( con, colNames, data));\r\n\t\t} catch (Exception e) {\r\n\t\t\tthrow SmallSQLException.createFromException(e);\r\n\t\t}\r\n    }\r\n\t\r\n\t\r\n    public ResultSet getImportedKeys(String catalog, String schema, String table) throws SQLException {\r\n\t\treturn getCrossReference( null, null, null, null, null, table );\r\n    }\r\n\t\r\n\t\r\n    public ResultSet getExportedKeys(String catalog, String schema, String table) throws SQLException {\r\n\t\treturn getCrossReference( null, null, table, null, null, null );\r\n    }\r\n\t\r\n\t\r\n    public ResultSet getCrossReference(String primaryCatalog, String primarySchema, String primaryTable, String foreignCatalog, String foreignSchema, String foreignTable) throws SQLException {\r\n\t\ttry {\r\n\t\t\tString[] colNames = {\"PKTABLE_CAT\", \"PKTABLE_SCHEM\", \"PKTABLE_NAME\", \"PKCOLUMN_NAME\", \"FKTABLE_CAT\", \"FKTABLE_SCHEM\", \"FKTABLE_NAME\", \"FKCOLUMN_NAME\", \"KEY_SEQ\", \"UPDATE_RULE\", \"DELETE_RULE\", \"FK_NAME\", \"PK_NAME\", \"DEFERRABILITY\"};\r\n\t\t\tObject[][] data   = con.getDatabase(false).getReferenceKeys(con, primaryTable, foreignTable);\r\n\t\t\treturn new SSResultSet( st, Utils.createMemoryCommandSelect( con, colNames, data));\r\n\t\t} catch (Exception e) {\r\n\t\t\tthrow SmallSQLException.createFromException(e);\r\n\t\t}\r\n    }\r\n\t\r\n\t\r\n    public ResultSet getTypeInfo() throws SQLException {\r\n\t\tString[] colNames = {\t\t\"TYPE_NAME\", \t\t\t\t\"DATA_TYPE\", \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"PRECISION\", \t\"LITERAL_PREFIX\", \"LITERAL_SUFFIX\", \t\t\"CREATE_PARAMS\", \"NULLABLE\", \t \"CASE_SENSITIVE\", \"SEARCHABLE\", \"UNSIGNED_ATTRIBUTE\", \"FIXED_PREC_SCALE\", \"AUTO_INCREMENT\", \"LOCAL_TYPE_NAME\", \"MINIMUM_SCALE\", \"MAXIMUM_SCALE\", \"SQL_DATA_TYPE\", \"SQL_DATETIME_SUB\", \"NUM_PREC_RADIX\"};\r\n\t\tObject[][] data   = {\r\n\t\t {SQLTokenizer.getKeyWord(SQLTokenizer.UNIQUEIDENTIFIER),Utils.getShort(SQLTokenizer.getSQLDataType( SQLTokenizer.UNIQUEIDENTIFIER)), Utils.getInteger(36),      \t\"'\",  \"'\",  null, \t\t\t\tUtils.getShort(typeNullable), Boolean.FALSE, Utils.getShort(typeSearchable), null,          Boolean.FALSE, Boolean.FALSE, null, null,                null,                null, null, null},\r\n\t\t {SQLTokenizer.getKeyWord(SQLTokenizer.BIT),             Utils.getShort(SQLTokenizer.getSQLDataType( SQLTokenizer.BIT) ),             Utils.getInteger(1),      \tnull, null, null, \t\t\t\tUtils.getShort(typeNullable), Boolean.FALSE, Utils.getShort(typeSearchable), null,          Boolean.FALSE, Boolean.FALSE, null, Utils.getInteger(0), Utils.getInteger(0), null, null, null},\r\n\t\t {SQLTokenizer.getKeyWord(SQLTokenizer.TINYINT),         Utils.getShort(SQLTokenizer.getSQLDataType( SQLTokenizer.TINYINT) ),         Utils.getInteger(3),      \tnull, null, null, \t\t\t\tUtils.getShort(typeNullable), Boolean.FALSE, Utils.getShort(typeSearchable), Boolean.TRUE,  Boolean.FALSE, Boolean.FALSE, null, Utils.getInteger(0), Utils.getInteger(0), null, null, null},\r\n\t\t {SQLTokenizer.getKeyWord(SQLTokenizer.BIGINT),          Utils.getShort(SQLTokenizer.getSQLDataType( SQLTokenizer.BIGINT) ),          Utils.getInteger(19),     \tnull, null, null, \t\t\t\tUtils.getShort(typeNullable), Boolean.FALSE, Utils.getShort(typeSearchable), Boolean.FALSE, Boolean.FALSE, Boolean.FALSE, null, Utils.getInteger(0), Utils.getInteger(0), null, null, null},\r\n\t\t {SQLTokenizer.getKeyWord(SQLTokenizer.LONGVARBINARY),   Utils.getShort(SQLTokenizer.getSQLDataType( SQLTokenizer.LONGVARBINARY) ),   Utils.getInteger(2147483647),\t\"0x\", null, null, \t\t \t\tUtils.getShort(typeNullable), Boolean.FALSE, Utils.getShort(typeSearchable), null, \t\t\tBoolean.FALSE, Boolean.FALSE, null, null, \t\t\t\t null, \t\t\t\t  null, null, null},\r\n\t\t {SQLTokenizer.getKeyWord(SQLTokenizer.VARBINARY),   \t Utils.getShort(SQLTokenizer.getSQLDataType( SQLTokenizer.VARBINARY) ),   \t  Utils.getInteger(65535),\t    \"0x\", null, \"max length\", \t\tUtils.getShort(typeNullable), Boolean.FALSE, Utils.getShort(typeSearchable), null, \t\t\tBoolean.FALSE, Boolean.FALSE, null, null, \t\t\t\t null, \t\t\t\t  null, null, null},\r\n\t\t {SQLTokenizer.getKeyWord(SQLTokenizer.BINARY),   \t \t Utils.getShort(SQLTokenizer.getSQLDataType( SQLTokenizer.BINARY) ),   \t  \t  Utils.getInteger(65535),\t    \"0x\", null, \"length\", \t\t\tUtils.getShort(typeNullable), Boolean.FALSE, Utils.getShort(typeSearchable), null, \t\t\tBoolean.FALSE, Boolean.FALSE, null, null, \t\t\t\t null, \t\t\t\t  null, null, null},\r\n\t\t {SQLTokenizer.getKeyWord(SQLTokenizer.LONGVARCHAR),     Utils.getShort(SQLTokenizer.getSQLDataType( SQLTokenizer.LONGVARCHAR) ),     Utils.getInteger(2147483647),\t\"'\",  \"'\",  null, \t\t \t\tUtils.getShort(typeNullable), Boolean.FALSE, Utils.getShort(typeSearchable), null, \t\t\tBoolean.FALSE, Boolean.FALSE, null, null, \t\t\t\t null, \t\t\t\t  null, null, null},\r\n\t\t {SQLTokenizer.getKeyWord(SQLTokenizer.LONGNVARCHAR),    Utils.getShort(SQLTokenizer.getSQLDataType( SQLTokenizer.LONGNVARCHAR) ),    Utils.getInteger(2147483647),\t\"'\",  \"'\",  null, \t\t \t\tUtils.getShort(typeNullable), Boolean.FALSE, Utils.getShort(typeSearchable), null, \t\t\tBoolean.FALSE, Boolean.FALSE, null, null, \t\t\t\t null, \t\t\t\t  null, null, null},\r\n\t\t {SQLTokenizer.getKeyWord(SQLTokenizer.CHAR),         \t Utils.getShort(SQLTokenizer.getSQLDataType( SQLTokenizer.CHAR) ),         \t  Utils.getInteger(65535),   \t\"'\",  \"'\",  \"length\", \t\t\tUtils.getShort(typeNullable), Boolean.FALSE, Utils.getShort(typeSearchable), null, \t\t\tBoolean.FALSE, Boolean.FALSE, null, null, \t\t\t\t null, \t\t\t\t  null, null, null},\r\n\t\t {SQLTokenizer.getKeyWord(SQLTokenizer.NCHAR),         \t Utils.getShort(SQLTokenizer.getSQLDataType( SQLTokenizer.NCHAR) ),           Utils.getInteger(65535),   \t\"'\",  \"'\",  \"length\", \t\t\tUtils.getShort(typeNullable), Boolean.FALSE, Utils.getShort(typeSearchable), null, \t\t\tBoolean.FALSE, Boolean.FALSE, null, null, \t\t\t\t null, \t\t\t\t  null, null, null},\r\n\t\t {SQLTokenizer.getKeyWord(SQLTokenizer.NUMERIC),         Utils.getShort(SQLTokenizer.getSQLDataType( SQLTokenizer.NUMERIC) ),         Utils.getInteger(38),     \tnull, null, \"precision,scale\", \tUtils.getShort(typeNullable), Boolean.FALSE, Utils.getShort(typeSearchable), Boolean.FALSE, Boolean.FALSE, Boolean.FALSE, null, Utils.getInteger(0), Utils.getInteger(38),null, null, null},\r\n\t\t {SQLTokenizer.getKeyWord(SQLTokenizer.DECIMAL),         Utils.getShort(SQLTokenizer.getSQLDataType( SQLTokenizer.DECIMAL) ),         Utils.getInteger(38),     \tnull, null, \"precision,scale\", \tUtils.getShort(typeNullable), Boolean.FALSE, Utils.getShort(typeSearchable), Boolean.FALSE, Boolean.FALSE, Boolean.FALSE, null, Utils.getInteger(0), Utils.getInteger(38),null, null, null},\r\n\t\t {SQLTokenizer.getKeyWord(SQLTokenizer.MONEY),           Utils.getShort(SQLTokenizer.getSQLDataType( SQLTokenizer.MONEY) ),           Utils.getInteger(19),     \tnull, null, null, \t\t\t\tUtils.getShort(typeNullable), Boolean.FALSE, Utils.getShort(typeSearchable), Boolean.FALSE, Boolean.FALSE, Boolean.FALSE, null, Utils.getInteger(4), Utils.getInteger(4), null, null, null},\r\n\t\t {SQLTokenizer.getKeyWord(SQLTokenizer.SMALLMONEY),      Utils.getShort(SQLTokenizer.getSQLDataType( SQLTokenizer.SMALLMONEY) ),      Utils.getInteger(10),     \tnull, null, null, \t\t\t\tUtils.getShort(typeNullable), Boolean.FALSE, Utils.getShort(typeSearchable), Boolean.FALSE, Boolean.FALSE, Boolean.FALSE, null, Utils.getInteger(4), Utils.getInteger(4), null, null, null},\r\n\t\t {SQLTokenizer.getKeyWord(SQLTokenizer.INT),             Utils.getShort(SQLTokenizer.getSQLDataType( SQLTokenizer.INT) ),             Utils.getInteger(10),     \tnull, null, null, \t\t\t\tUtils.getShort(typeNullable), Boolean.FALSE, Utils.getShort(typeSearchable), Boolean.FALSE, Boolean.FALSE, Boolean.FALSE, null, Utils.getInteger(0), Utils.getInteger(0), null, null, null},\r\n\t\t {SQLTokenizer.getKeyWord(SQLTokenizer.SMALLINT),        Utils.getShort(SQLTokenizer.getSQLDataType( SQLTokenizer.SMALLINT) ),        Utils.getInteger(5),      \tnull, null, null, \t\t\t\tUtils.getShort(typeNullable), Boolean.FALSE, Utils.getShort(typeSearchable), Boolean.FALSE, Boolean.FALSE, Boolean.FALSE, null, Utils.getInteger(0), Utils.getInteger(0), null, null, null},\r\n\t\t {SQLTokenizer.getKeyWord(SQLTokenizer.FLOAT),        \t Utils.getShort(SQLTokenizer.getSQLDataType( SQLTokenizer.FLOAT) ),           Utils.getInteger(15),      \tnull, null, null, \t\t\t\tUtils.getShort(typeNullable), Boolean.FALSE, Utils.getShort(typeSearchable), Boolean.FALSE, Boolean.FALSE, Boolean.FALSE, null, Utils.getInteger(0), Utils.getInteger(0), null, null, null},\r\n\t\t {SQLTokenizer.getKeyWord(SQLTokenizer.REAL),        \t Utils.getShort(SQLTokenizer.getSQLDataType( SQLTokenizer.REAL) ),        \t  Utils.getInteger(7),      \tnull, null, null, \t\t\t\tUtils.getShort(typeNullable), Boolean.FALSE, Utils.getShort(typeSearchable), Boolean.FALSE, Boolean.FALSE, Boolean.FALSE, null, Utils.getInteger(0), Utils.getInteger(0), null, null, null},\r\n\t\t {SQLTokenizer.getKeyWord(SQLTokenizer.DOUBLE),          Utils.getShort(SQLTokenizer.getSQLDataType( SQLTokenizer.DOUBLE) ),          Utils.getInteger(15),      \tnull, null, null, \t\t\t\tUtils.getShort(typeNullable), Boolean.FALSE, Utils.getShort(typeSearchable), Boolean.FALSE, Boolean.FALSE, Boolean.FALSE, null, Utils.getInteger(0), Utils.getInteger(0), null, null, null},\r\n\t\t {SQLTokenizer.getKeyWord(SQLTokenizer.VARCHAR),         Utils.getShort(SQLTokenizer.getSQLDataType( SQLTokenizer.VARCHAR) ),         Utils.getInteger(65535),   \t\"'\",  \"'\",  \"max length\", \t\tUtils.getShort(typeNullable), Boolean.FALSE, Utils.getShort(typeSearchable), null, \t\t\tBoolean.FALSE, Boolean.FALSE, null, null, \t\t\t\t null, \t\t\t\t  null, null, null},\r\n\t\t {SQLTokenizer.getKeyWord(SQLTokenizer.NVARCHAR),        Utils.getShort(SQLTokenizer.getSQLDataType( SQLTokenizer.NVARCHAR) ),        Utils.getInteger(65535),   \t\"'\",  \"'\",  \"max length\", \t\tUtils.getShort(typeNullable), Boolean.FALSE, Utils.getShort(typeSearchable), null, \t\t\tBoolean.FALSE, Boolean.FALSE, null, null, \t\t\t\t null, \t\t\t\t  null, null, null},\r\n\t\t {SQLTokenizer.getKeyWord(SQLTokenizer.BOOLEAN),         Utils.getShort(SQLTokenizer.getSQLDataType( SQLTokenizer.BOOLEAN) ),         Utils.getInteger(1),      \tnull, null, null, \t\t\t\tUtils.getShort(typeNullable), Boolean.FALSE, Utils.getShort(typeSearchable), null,          Boolean.FALSE, Boolean.FALSE, null, Utils.getInteger(0), Utils.getInteger(0), null, null, null},\r\n\t\t {SQLTokenizer.getKeyWord(SQLTokenizer.DATE),   \t \t Utils.getShort(SQLTokenizer.getSQLDataType( SQLTokenizer.DATE) ), \t  \t\t  Utils.getInteger(10),\t    \t\"'\",  \"'\",  null, \t\t\t\tUtils.getShort(typeNullable), Boolean.FALSE, Utils.getShort(typeSearchable), null, \t\t\tBoolean.FALSE, Boolean.FALSE, null, null, \t\t\t\t null, \t\t\t\t  null, null, null},\r\n\t\t {SQLTokenizer.getKeyWord(SQLTokenizer.TIME),   \t \t Utils.getShort(SQLTokenizer.getSQLDataType( SQLTokenizer.TIME) ), \t  \t\t  Utils.getInteger(8),\t    \t\"'\",  \"'\",  null, \t\t\t\tUtils.getShort(typeNullable), Boolean.FALSE, Utils.getShort(typeSearchable), null, \t\t\tBoolean.FALSE, Boolean.FALSE, null, null, \t\t\t\t null, \t\t\t\t  null, null, null},\r\n\t\t {SQLTokenizer.getKeyWord(SQLTokenizer.TIMESTAMP),   \t Utils.getShort(SQLTokenizer.getSQLDataType( SQLTokenizer.TIMESTAMP) ), \t  Utils.getInteger(23),\t    \t\"'\",  \"'\",  null, \t\t\t\tUtils.getShort(typeNullable), Boolean.FALSE, Utils.getShort(typeSearchable), null, \t\t\tBoolean.FALSE, Boolean.FALSE, null, Utils.getInteger(3), Utils.getInteger(3), null, null, null},\r\n\t\t {SQLTokenizer.getKeyWord(SQLTokenizer.SMALLDATETIME),   Utils.getShort(SQLTokenizer.getSQLDataType( SQLTokenizer.SMALLDATETIME) ),   Utils.getInteger(16),\t    \t\"'\",  \"'\",  null, \t\t\t\tUtils.getShort(typeNullable), Boolean.FALSE, Utils.getShort(typeSearchable), null, \t\t\tBoolean.FALSE, Boolean.FALSE, null, null, \t\t\t\t null, \t\t\t\t  null, null, null},\r\n\t\t {SQLTokenizer.getKeyWord(SQLTokenizer.JAVA_OBJECT),   \t Utils.getShort(SQLTokenizer.getSQLDataType( SQLTokenizer.JAVA_OBJECT) ),     Utils.getInteger(65535),\t    null, null, null, \t\t\t\tUtils.getShort(typeNullable), Boolean.FALSE, Utils.getShort(typeSearchable), null, \t\t\tBoolean.FALSE, Boolean.FALSE, null, null, \t\t\t\t null, \t\t\t\t  null, null, null},\r\n\t\t {SQLTokenizer.getKeyWord(SQLTokenizer.BLOB),   \t\t Utils.getShort(SQLTokenizer.getSQLDataType( SQLTokenizer.BLOB) ),   \t\t  Utils.getInteger(2147483647),\t\"0x\", null, null, \t\t \t\tUtils.getShort(typeNullable), Boolean.FALSE, Utils.getShort(typeSearchable), null, \t\t\tBoolean.FALSE, Boolean.FALSE, null, null, \t\t\t\t null, \t\t\t\t  null, null, null},\r\n\t\t {SQLTokenizer.getKeyWord(SQLTokenizer.CLOB),     \t\t Utils.getShort(SQLTokenizer.getSQLDataType( SQLTokenizer.CLOB) ),     \t\t  Utils.getInteger(2147483647),\t\"'\",  \"'\",  null, \t\t \t\tUtils.getShort(typeNullable), Boolean.FALSE, Utils.getShort(typeSearchable), null, \t\t\tBoolean.FALSE, Boolean.FALSE, null, null, \t\t\t\t null, \t\t\t\t  null, null, null},\r\n\t\t {SQLTokenizer.getKeyWord(SQLTokenizer.NCLOB),     \t\t Utils.getShort(SQLTokenizer.getSQLDataType( SQLTokenizer.NCLOB) ),     \t  Utils.getInteger(2147483647),\t\"'\",  \"'\",  null, \t\t \t\tUtils.getShort(typeNullable), Boolean.FALSE, Utils.getShort(typeSearchable), null, \t\t\tBoolean.FALSE, Boolean.FALSE, null, null, \t\t\t\t null, \t\t\t\t  null, null, null},\r\n\t\t};\r\n\t\t//TODO add more data types to the list\r\n\t\treturn new SSResultSet( st, Utils.createMemoryCommandSelect( con, colNames, data));\r\n    }\r\n\t\r\n\t\r\n    public ResultSet getIndexInfo(String catalog, String schema, String table, boolean unique, boolean approximate) throws SQLException {\r\n\t\ttry {\r\n\t\t\tString[] colNames = {\"TABLE_CAT\", \"TABLE_SCHEM\", \"TABLE_NAME\", \"NON_UNIQUE\", \"INDEX_QUALIFIER\", \"INDEX_NAME\", \"TYPE\", \"ORDINAL_POSITION\", \"COLUMN_NAME\", \"ASC_OR_DESC\", \"CARDINALITY\", \"PAGES\", \"FILTER_CONDITION\"};\r\n\t\t\tObject[][] data   = con.getDatabase(false).getIndexInfo(con, table, unique);\r\n\t\t\treturn new SSResultSet( st, Utils.createMemoryCommandSelect( con, colNames, data));\r\n\t\t} catch (Exception e) {\r\n\t\t\tthrow SmallSQLException.createFromException(e);\r\n\t\t}\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsResultSetType(int type) {\r\n\t\tswitch(type){\r\n\t\t\tcase ResultSet.TYPE_FORWARD_ONLY:\r\n\t\t\tcase ResultSet.TYPE_SCROLL_INSENSITIVE:\r\n\t\t\tcase ResultSet.TYPE_SCROLL_SENSITIVE:\r\n\t\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsResultSetConcurrency(int type, int concurrency) {\r\n\t\tif(type >= ResultSet.TYPE_FORWARD_ONLY && type <= ResultSet.TYPE_SCROLL_SENSITIVE &&\r\n\t\t\tconcurrency >= ResultSet.CONCUR_READ_ONLY && concurrency <= ResultSet.CONCUR_UPDATABLE)\r\n\t\t\treturn true;\r\n\t\treturn false;\r\n    }\r\n\t\r\n\t\r\n    public boolean ownUpdatesAreVisible(int type) {\r\n\t\treturn supportsResultSetType(type);\r\n    }\r\n\t\r\n\t\r\n    public boolean ownDeletesAreVisible(int type) {\r\n\t\treturn supportsResultSetType(type);\r\n    }\r\n\r\n\t\r\n\tpublic boolean ownInsertsAreVisible(int type) {\r\n\t\treturn supportsResultSetType(type);\r\n    }\r\n\t\r\n\t\r\n    public boolean othersUpdatesAreVisible(int type) {\r\n\t\treturn supportsResultSetType(type);\r\n    }\r\n\t\r\n\t\r\n    public boolean othersDeletesAreVisible(int type) {\r\n\t\treturn supportsResultSetType(type);\r\n    }\r\n\t\r\n\t\r\n    public boolean othersInsertsAreVisible(int type) {\r\n\t\treturn supportsResultSetType(type);\r\n    }\r\n\t\r\n\t\r\n    public boolean updatesAreDetected(int type) {\r\n\t\treturn false;\r\n    }\r\n\t\r\n\t\r\n    public boolean deletesAreDetected(int type) {\r\n\t\treturn supportsResultSetType(type);\r\n    }\r\n\t\r\n\t\r\n    public boolean insertsAreDetected(int type) {\r\n\t\treturn supportsResultSetType(type);\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsBatchUpdates() {\r\n\t\treturn true;\r\n    }\r\n\t\r\n\t\r\n    public ResultSet getUDTs(String catalog, String schemaPattern, String typeNamePattern, int[] types) throws SQLException {\r\n\t\tString[] colNames = {\"TYPE_CAT\", \"TYPE_SCHEM\", \"TYPE_NAME\", \"CLASS_NAME\", \"DATA_TYPE\", \"REMARKS\"};        \r\n\t\tObject[][] data   = new Object[0][];\r\n\t\treturn new SSResultSet( st, Utils.createMemoryCommandSelect( con, colNames, data));\r\n    }\r\n\t\r\n\t\r\n    public Connection getConnection() {\r\n    \treturn con;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsSavepoints() {\r\n    \treturn false;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsNamedParameters() {\r\n\t\treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsMultipleOpenResults() {\r\n\t\treturn true;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsGetGeneratedKeys() {\r\n\t\treturn true;\r\n    }\r\n\t\r\n\t\r\n    public ResultSet getSuperTypes(String catalog, String schemaPattern, String typeNamePattern) throws SQLException {\r\n        /**@todo: Implement this java.sql.DatabaseMetaData method*/\r\n        throw new java.lang.UnsupportedOperationException(\"Method getSuperTypes() not yet implemented.\");\r\n    }\r\n    public ResultSet getSuperTables(String catalog, String schemaPattern, String tableNamePattern) throws SQLException {\r\n        /**@todo: Implement this java.sql.DatabaseMetaData method*/\r\n        throw new java.lang.UnsupportedOperationException(\"Method getSuperTables() not yet implemented.\");\r\n    }\r\n    public ResultSet getAttributes(String catalog, String schemaPattern, String typeNamePattern, String attributeNamePattern) throws SQLException {\r\n        /**@todo: Implement this java.sql.DatabaseMetaData method*/\r\n        throw new java.lang.UnsupportedOperationException(\"Method getAttributes() not yet implemented.\");\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsResultSetHoldability(int holdability) {\r\n\t\treturn true;\r\n    }\r\n\t\r\n\t\r\n    public int getResultSetHoldability() {\r\n\t\treturn ResultSet.HOLD_CURSORS_OVER_COMMIT;\r\n    }\r\n\t\r\n\t\r\n    public int getDatabaseMajorVersion() {\r\n    \treturn getDriverMajorVersion();\r\n    }\r\n\t\r\n\t\r\n    public int getDatabaseMinorVersion() {\r\n\t\treturn getDriverMinorVersion();\r\n    }\r\n\t\r\n\t\r\n    public int getJDBCMajorVersion() {\r\n    \treturn 3;\r\n    }\r\n\t\r\n\t\r\n    public int getJDBCMinorVersion() {\r\n    \treturn 0;\r\n    }\r\n\t\r\n\t\r\n    public int getSQLStateType() {\r\n\t\treturn sqlStateSQL99;\r\n    }\r\n\t\r\n\t\r\n    public boolean locatorsUpdateCopy() {\r\n\t\treturn false;\r\n    }\r\n\t\r\n\t\r\n    public boolean supportsStatementPooling() {\r\n\t\treturn false;\r\n    }\r\n}"},{"path":"/src/smallsql/database/Table.java","source":"/* =============================================================\r\n * SmallSQL : a free Java DBMS library for the Java(tm) platform\r\n * =============================================================\r\n *\r\n * (C) Copyright 2004-2011, by Volker Berlin.\r\n *\r\n * Project Info:  http://www.smallsql.de/\r\n *\r\n * This library is free software; you can redistribute it and/or modify it \r\n * under the terms of the GNU Lesser General Public License as published by \r\n * the Free Software Foundation; either version 2.1 of the License, or \r\n * (at your option) any later version.\r\n *\r\n * This library is distributed in the hope that it will be useful, but \r\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \r\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public \r\n * License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, \r\n * USA.  \r\n *\r\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc. \r\n * in the United States and other countries.]\r\n *\r\n * ---------------\r\n * Table.java\r\n * ---------------\r\n * Author: Volker Berlin\r\n * \r\n */\r\npackage smallsql.database;\r\n\r\nimport java.io.*;\r\nimport java.nio.ByteBuffer;\r\nimport java.nio.channels.FileChannel;\r\nimport java.sql.*;\r\nimport java.util.ArrayList;\r\nimport java.util.HashMap;\r\nimport java.util.Iterator;\r\nimport java.util.List;\r\nimport smallsql.database.language.Language;\r\n\r\nclass Table extends TableView{\r\n\t\r\n\tprivate static final int INDEX = 1;\r\n\r\n    final Database database;\r\n    FileChannel raFile; // file handle of the table\r\n\tprivate Lobs lobs; // file handle of lob data for this table\r\n    long firstPage; // offset of the first page\r\n\r\n\tfinal private HashMap locks = new HashMap();\r\n\tprivate SSConnection tabLockConnection; // if set then it is the Connection with a LOCK_TAB\r\n\tprivate int tabLockCount;\r\n\t/** if set then it is the Connection with a LOCK_WRITE_TAB */\r\n\tfinal private ArrayList locksInsert = new ArrayList(); // liste der LOCK_INSERT\r\n\tfinal private HashMap serializeConnections = new HashMap();\r\n\tfinal IndexDescriptions indexes;\r\n\tfinal ForeignKeys references;\r\n\r\n\r\n\t/**\r\n\t * Constructor for read existing tables.\r\n\t */\r\n    Table( Database database, SSConnection con, String name, FileChannel raFile, long offset, int tableFormatVersion) throws Exception{\r\n        super( name, new Columns() );\r\n        this.database = database;\r\n        this.raFile   = raFile;\r\n\t\tthis.firstPage = offset;\r\n\t\tStoreImpl store = getStore(con, firstPage, SQLTokenizer.SELECT);\r\n        if(store == null){\r\n            throw SmallSQLException.create(Language.TABLE_FILE_INVALID, getFile(database));\r\n        }\r\n\t\tint count = store.readInt();\r\n\r\n\t\tfor(int i=0; i<count; i++){\r\n\t\t\tcolumns.add( store.readColumn(tableFormatVersion) );\r\n\t\t}\r\n\t\tindexes = new IndexDescriptions();\r\n        references = new ForeignKeys();\r\n\t\t\r\n\t\t// read additional informations\r\n\t\tint type;\r\n\t\twhile((type = store.readInt()) != 0){\r\n\t\t\tint offsetInPage = store.getCurrentOffsetInPage();\r\n\t\t\tint size = store.readInt();\r\n\t\t\tswitch(type){\r\n\t\t\t\tcase INDEX:\r\n\t\t\t\t\tindexes.add( IndexDescription.load( database, this, store) );\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tstore.setCurrentOffsetInPage(offsetInPage + size);\r\n\t\t}\r\n\t\t\r\n\t\tfirstPage = store.getNextPagePos();\r\n    }\r\n    \r\n\r\n    /**\r\n     * Constructor for creating of new tables.\r\n     */\r\n    Table(Database database, SSConnection con, String name, Columns columns, IndexDescriptions indexes, ForeignKeys foreignKeys) throws Exception{\r\n        this(database, con, name, columns, null, indexes, foreignKeys);\r\n    }\r\n    \r\n    /**\r\n     * Constructor for alter an existing tables.\r\n     */\r\n    Table(Database database, SSConnection con, String name, Columns columns, IndexDescriptions existIndexes, IndexDescriptions newIndexes, ForeignKeys foreignKeys) throws Exception{\r\n        super( name, columns );\r\n        this.database = database;\r\n        this.references = foreignKeys;\r\n        newIndexes.create(con, database, this);\r\n        if(existIndexes == null){\r\n            this.indexes = newIndexes;\r\n        }else{\r\n            this.indexes = existIndexes;\r\n            existIndexes.add(newIndexes);\r\n        }\r\n        \r\n        write(con);\r\n        for(int i=0; i<foreignKeys.size(); i++){\r\n            ForeignKey foreignKey = foreignKeys.get(i);\r\n            Table pkTable = (Table)database.getTableView(con, foreignKey.pkTable);\r\n            pkTable.references.add(foreignKey);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Constructor for extends class Lobs.\r\n     */\r\n    Table(Database database, String name){\r\n    \tsuper( name, null);\r\n    \tthis.database = database;\r\n\t\tindexes = null;\r\n        references = null;\r\n    }\r\n\r\n\t/**\r\n\t * Drop the Table. This method is static that the file does not need to load and also corrupt files can be dropped.\r\n\t */ \r\n    static void drop(Database database, String name) throws Exception{\r\n        boolean ok = new File( Utils.createTableViewFileName( database, name ) ).delete();\r\n        if(!ok) throw SmallSQLException.create(Language.TABLE_CANT_DROP, name);\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Drop a loaded table.\r\n     *\r\n     */\r\n    void drop(SSConnection con) throws Exception{\r\n\t\tTableStorePage storePage = requestLock( con, SQLTokenizer.CREATE, -1 );\r\n\t\tif(storePage == null){\r\n\t\t\tthrow SmallSQLException.create(Language.TABLE_CANT_DROP_LOCKED, name);\r\n        }\r\n\t\t// remove the all commits that point to this table\r\n\t\tcon.rollbackFile(raFile);\r\n\t\tclose();\r\n\t\tif(lobs != null)\r\n\t\t\tlobs.drop(con);\r\n\t\tif(indexes != null)\r\n\t\t\tindexes.drop(database);\r\n\t\tboolean ok = getFile(database).delete();\r\n\t\tif(!ok) throw SmallSQLException.create(Language.TABLE_CANT_DROP, name);\r\n    }\r\n    \r\n\r\n    /**\r\n     * Closed the file handle that the object can be garbaged.\r\n     */\r\n    @Override\r\n    void close() throws Exception{\r\n        if(indexes != null)\r\n            indexes.close();\r\n        raFile.close();\r\n        raFile = null;\r\n        if( lobs != null ){\r\n            lobs.close();\r\n            lobs = null;\r\n        }\r\n    }\r\n\r\n\r\n    private void write(SSConnection con) throws Exception{\r\n        raFile = createFile( con, database );\r\n        firstPage = 8;\r\n        StoreImpl store = getStore( con, firstPage, SQLTokenizer.CREATE);\r\n        int count = columns.size();\r\n        store.writeInt( count );\r\n        for(int i=0; i<count; i++){\r\n            store.writeColumn(columns.get(i));\r\n        }\r\n\r\n\t\t// write additional informations\r\n\t\tfor(int i=0; i<indexes.size(); i++){\r\n\t\t\tIndexDescription indexDesc = indexes.get(i);\r\n\t\t\tstore.writeInt( INDEX );\r\n\t\t\tint offsetStart = store.getCurrentOffsetInPage();\r\n\t\t\tstore.setCurrentOffsetInPage( offsetStart + 4 ); // place holder for length\r\n\t\t\t\r\n\t\t\t// write the IndexDescription\r\n\t\t\tindexDesc.save(store);\r\n\t\t\t\r\n\t\t\t// write the length information\r\n\t\t\tint offsetEnd = store.getCurrentOffsetInPage();\r\n\t\t\tstore.setCurrentOffsetInPage( offsetStart );\r\n\t\t\tstore.writeInt( offsetEnd - offsetStart);\r\n\t\t\tstore.setCurrentOffsetInPage( offsetEnd );\r\n\t\t}\r\n\t\tstore.writeInt( 0 ); // no more additional informations\r\n\t\t\r\n\t\tstore.writeFinsh(null); //The connection parameter is null because the table header is written immediately.\r\n        firstPage = store.getNextPagePos();\r\n    }\r\n    \r\n\r\n\t@Override\r\n    void writeMagic(FileChannel raFile) throws Exception{\r\n        ByteBuffer buffer = ByteBuffer.allocate(8);\r\n        buffer.putInt(MAGIC_TABLE);\r\n        buffer.putInt(TABLE_VIEW_VERSION);\r\n        buffer.position(0);\r\n        raFile.write(buffer);\r\n\t}\r\n\t\r\n\r\n    /*StoreImpl getStoreCreate( SSConnection con, long filePos ) throws Exception{\r\n        return StoreImpl.createStore( con, raFile, SQLTokenizer.CREATE, filePos );\r\n    }*/\r\n\r\n    StoreImpl getStore( SSConnection con, long filePos, int pageOperation ) throws Exception{\r\n\t\tTableStorePage storePage = requestLock( con, pageOperation, filePos );\r\n        return StoreImpl.createStore( this, storePage, pageOperation, filePos );\r\n    }\r\n\r\n    \r\n\tStoreImpl getStore( TableStorePage storePage, int pageOperation ) throws Exception{\r\n\t\t// is used for not committed INSERT pages, a new lock is not needed\r\n\t\treturn StoreImpl.recreateStore( this, storePage, pageOperation );\r\n\t}\r\n\t\r\n    /*StoreImpl getStoreUpdate( SSConnection con, long filePos ) throws Exception{\r\n        return StoreImpl.createStore( con, raFile, SQLTokenizer.UPDATE, filePos );\r\n    }\r\n\r\n    StoreImpl getStoreDelete( SSConnection con, long filePos ) throws Exception{\r\n        return StoreImpl.createStore( con, raFile, SQLTokenizer.DELETE, filePos );\r\n    }*/\r\n\t\r\n\r\n    StoreImpl getStoreInsert( SSConnection con ) throws Exception{\r\n\t\tTableStorePage storePage = requestLock( con, SQLTokenizer.INSERT, -1 );\r\n        return StoreImpl.createStore( this, storePage, SQLTokenizer.INSERT, -1 );\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Create a Store that is not invoke in a transaction for copy of data.\r\n     */\r\n\tStoreImpl getStoreTemp( SSConnection con ) throws Exception{\r\n\t\tTableStorePage storePage = new TableStorePage( con, this, LOCK_NONE, -2);\r\n\t\treturn StoreImpl.createStore( this, storePage, SQLTokenizer.INSERT, -2 );\r\n\t}\r\n        \r\n\r\n\tStoreImpl getLobStore(SSConnection con, long filePos, int pageOperation) throws Exception{\r\n\t\tif(lobs == null){\r\n\t\t\tlobs = new Lobs( this );\r\n\t\t}\r\n\t\treturn lobs.getStore( con, filePos, pageOperation );\r\n\t}\r\n    \r\n\r\n\t\r\n\t/**\r\n\t * Return the file offset of the first page with data after the table declaration.\r\n\t * This is equals to the first row.\r\n\t */\r\n    final long getFirstPage(){\r\n        return firstPage;\r\n    }\r\n\r\n\r\n    /**\r\n     * Return a list of Links to not commited rows. The list include only the rows that are visible for \r\n     * the current isolation level.\r\n     */\r\n    List getInserts(SSConnection con){\r\n\t\tsynchronized(locks){\r\n\t\t\tArrayList inserts = new ArrayList();\r\n\t\t\tif(con.isolationLevel <= Connection.TRANSACTION_READ_UNCOMMITTED){\r\n\t\t\t\tfor(int i=0; i<locksInsert.size(); i++){\r\n\t\t\t\t\tTableStorePageInsert lock = (TableStorePageInsert)locksInsert.get(i);\r\n\t\t\t\t\tinserts.add(lock.getLink());\r\n\t\t\t\t}\r\n\t\t\t}else{\r\n\t\t\t\tfor(int i=0; i<locksInsert.size(); i++){\r\n\t\t\t\t\tTableStorePageInsert lock = (TableStorePageInsert)locksInsert.get(i);\r\n\t\t\t\t\tif(lock.con == con)\r\n\t\t\t\t\t\tinserts.add(lock.getLink());\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn inserts;\r\n\t\t}    \t\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Request a page lock. If the request is valid then it return the StorePage. \r\n     * If the lock can not be created within 5 seconds then it throw an exception.\r\n     * @param con The connection that request the lock\r\n     * @param pageOperation The operation that should be perform\r\n     * @param page The offset of the page\r\n     * @return a valid StorePage\r\n     * @throws Exception if a timeout occurs\r\n     */\r\n    final TableStorePage requestLock(SSConnection con, int pageOperation, long page) throws Exception{\r\n    \tsynchronized(locks){\r\n            if(raFile == null){\r\n                throw SmallSQLException.create(Language.TABLE_MODIFIED, name);\r\n            }\r\n\t\t\tlong endTime = 0;\r\n\t\t\twhile(true){\r\n\t\t\t\tTableStorePage storePage = requestLockImpl( con, pageOperation, page);\r\n\t\t\t\tif(storePage != null) \r\n\t\t\t\t\treturn storePage; // the normal case should be the fasted\r\n\t\t\t\tif(endTime == 0)\r\n\t\t\t\t\tendTime = System.currentTimeMillis() + 5000;\r\n\t\t\t\tlong waitTime = endTime - System.currentTimeMillis();\r\n\t\t\t\tif(waitTime <= 0)\r\n\t\t\t\t\tthrow SmallSQLException.create(Language.TABLE_DEADLOCK, name);\r\n\t\t\t\tlocks.wait(waitTime);\r\n\t\t\t}\r\n    \t}\r\n    }\r\n    \r\n    /**\r\n     * Request a page lock. If the request is valid then it return the StorePage. \r\n     * In the other case it return null.\r\n     * @param page The fileOffset or -1 for a new page\r\n     * @throws SQLException \r\n     */\r\n\tfinal private TableStorePage requestLockImpl(SSConnection con, int pageOperation, long page) throws SQLException{\r\n\t\tsynchronized(locks){\r\n\t\t\tif(tabLockConnection != null && tabLockConnection != con) return null;\r\n\t\t\tswitch(con.isolationLevel){\r\n\t\t\t\tcase Connection.TRANSACTION_SERIALIZABLE:\r\n\t\t\t\t\tserializeConnections.put( con, con);\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\r\n\t\t\tswitch(pageOperation){\r\n\t\t\t\tcase SQLTokenizer.CREATE:{\r\n\t\t\t\t\t\t// first check if another connection has a lock before creating a table lock\r\n\t\t\t\t\t\tif(locks.size() > 0){\r\n\t\t\t\t\t\t\tIterator values = locks.values().iterator();\r\n\t\t\t\t\t\t\twhile(values.hasNext()){\r\n\t\t\t\t\t\t\t\tTableStorePage lock = (TableStorePage)values.next();\r\n\t\t\t\t\t\t\t\tif(lock.con != con) return null;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tfor(int i=0; i<locksInsert.size(); i++){\r\n\t\t\t\t\t\t\t//the first StorePage in the linked list must be ever TableStorePageInsert\r\n\t\t\t\t\t\t\tTableStorePageInsert lock = (TableStorePageInsert)locksInsert.get(i);\r\n\t\t\t\t\t\t\tif(lock.con != con) return null;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif(serializeConnections.size() > 0){\r\n\t\t\t\t\t\t\tIterator values = locks.values().iterator();\r\n\t\t\t\t\t\t\twhile(values.hasNext()){\r\n\t\t\t\t\t\t\t\tTableStorePage lock = (TableStorePage)values.next();\r\n\t\t\t\t\t\t\t\tif(lock.con != con) return null;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\ttabLockConnection = con;\r\n\t\t\t\t\t\ttabLockCount++;\r\n\t\t\t\t\t\tTableStorePage lock = new TableStorePage(con, this, LOCK_TAB, page);\r\n\t\t\t\t\t\tcon.add(lock);\r\n\t\t\t\t\t\treturn lock;\r\n\t\t\t\t\t}\r\n                case SQLTokenizer.ALTER:{\r\n                    // first check if there is any lock before creating a table lock\r\n                    if(locks.size() > 0 || locksInsert.size() > 0){\r\n                        return null;\r\n                    }\r\n                    if(serializeConnections.size() > 0){\r\n                        Iterator values = locks.values().iterator();\r\n                        while(values.hasNext()){\r\n                            TableStorePage lock = (TableStorePage)values.next();\r\n                            if(lock.con != con) return null;\r\n                        }\r\n                    }\r\n                    tabLockConnection = con;\r\n                    tabLockCount++;\r\n                    TableStorePage lock = new TableStorePage(con, this, LOCK_TAB, page);\r\n                    lock.rollback();\r\n                    return lock;\r\n                }\r\n\t\t\t\tcase SQLTokenizer.INSERT:{\r\n\t\t\t\t\t\t// if there are more as one Connection with a serializable lock then an INSERT is not valid\r\n\t\t\t\t\t\tif(serializeConnections.size() > 1) return null;\r\n\t\t\t\t\t\tif(serializeConnections.size() == 1 && serializeConnections.get(con) == null) return null;\r\n\t\t\t\t\t\tTableStorePageInsert lock = new TableStorePageInsert(con, this, LOCK_INSERT);\r\n\t\t\t\t\t\tlocksInsert.add( lock );\r\n\t\t\t\t\t\tcon.add(lock);\r\n\t\t\t\t\t\treturn lock;\r\n\t\t\t\t\t}\r\n\t\t\t\tcase SQLTokenizer.SELECT:\r\n\t\t\t\tcase SQLTokenizer.UPDATE:{\r\n\t\t\t\t\t\tLong pageKey = new Long(page); //TODO performance\r\n\t\t\t\t\t\tTableStorePage prevLock = null;\r\n\t\t\t\t\t\tTableStorePage lock = (TableStorePage)locks.get( pageKey );\r\n\t\t\t\t\t\tTableStorePage usableLock = null;\r\n\t\t\t\t\t\twhile(lock != null){\r\n\t\t\t\t\t\t\tif(lock.con == con || \r\n\t\t\t\t\t\t\t   con.isolationLevel <= Connection.TRANSACTION_READ_UNCOMMITTED){\r\n\t\t\t\t\t\t\t    usableLock = lock;\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t    if(lock.lockType == LOCK_WRITE){\r\n\t\t\t\t\t\t\t        return null; // write lock of another Connection\r\n\t\t\t\t\t\t\t    }\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tprevLock = lock;\r\n\t\t\t\t\t\t\tlock = lock.nextLock;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif(usableLock != null){\r\n\t\t\t\t\t\t    return usableLock;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tlock = new TableStorePage( con, this, LOCK_NONE, page);\r\n\t\t\t\t\t\tif(con.isolationLevel >= Connection.TRANSACTION_REPEATABLE_READ || pageOperation == SQLTokenizer.UPDATE){\r\n\t\t\t\t\t\t\tlock.lockType = pageOperation == SQLTokenizer.UPDATE ? LOCK_WRITE : LOCK_READ;\r\n\t\t\t\t\t\t\tif(prevLock != null){\r\n\t\t\t\t\t\t\t    prevLock.nextLock = lock.nextLock;\r\n\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t    locks.put( pageKey, lock );\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tcon.add(lock);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn lock;\t\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\tcase SQLTokenizer.LONGVARBINARY:\r\n\t\t\t\t\t// is used for written BLOB and CLOB\r\n\t\t\t\t\t// the difference to INSERT is that page described the size of the byte buffer\r\n\t\t\t\t\treturn new TableStorePage( con, this, LOCK_INSERT, -1);\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tthrow new Error(\"pageOperation:\"+pageOperation);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * Request a write lock for a page that is read. It add the resulting StorePage to the list of commits.\r\n     * @throws SQLException\r\n     *             if the connection was closed.\r\n\t */\r\n\tTableStorePage requestWriteLock(SSConnection con, TableStorePage readlock) throws SQLException{\r\n\t\tif(readlock.lockType == LOCK_INSERT){\r\n\t\t\tTableStorePage lock = new TableStorePage( con, this, LOCK_INSERT, -1);\r\n\t\t\treadlock.nextLock = lock;\r\n\t\t\tcon.add(lock);\r\n\t\t\treturn lock;\t\t\t\t\t\t\t\t\t\r\n\t\t}\r\n\t\tLong pageKey = new Long(readlock.fileOffset); //TODO performance\r\n\t\tTableStorePage prevLock = null;\r\n\t\tTableStorePage lock = (TableStorePage)locks.get( pageKey );\r\n\t\twhile(lock != null){\r\n\t\t\tif(lock.con != con) return null; // there is already any lock from another connection, we can not start write\r\n\t\t\tif(lock.lockType < LOCK_WRITE){\r\n\t\t\t\t// if there is only a read lock we can transfer it\r\n\t\t\t\t// this is required for rollback to a savepoint\r\n\t\t\t\tlock.lockType = LOCK_WRITE;\r\n\t\t\t\treturn lock;\r\n\t\t\t}\r\n\t\t\tprevLock = lock;\r\n\t\t\tlock = lock.nextLock;\r\n\t\t}\r\n\t\tlock = new TableStorePage( con, this, LOCK_WRITE, readlock.fileOffset);\r\n\t\tif(prevLock != null){\r\n\t\t    prevLock.nextLock = lock;\r\n\t\t} else {\r\n\t\t    locks.put( pageKey, lock );\r\n\t\t}\r\n\t\tcon.add(lock);\r\n\t\treturn lock;\t\t\t\t\t\t\t\t\t\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * Remove the lock from this table.\r\n\t */\r\n\tvoid freeLock(TableStorePage storePage){\r\n\t\tfinal int lockType = storePage.lockType;\r\n\t\tfinal long fileOffset = storePage.fileOffset;\r\n\t\tsynchronized(locks){\r\n\t\t\ttry{\r\n\t\t\t\tTableStorePage lock;\r\n\t\t\t\tTableStorePage prev;\r\n\t\t\t\tswitch(lockType){\r\n\t\t\t\t\tcase LOCK_INSERT:\r\n\t\t\t\t\t\tfor(int i=0; i<locksInsert.size(); i++){\r\n\t\t\t\t\t\t\tprev = lock = (TableStorePage)locksInsert.get(i);\r\n\t\t\t\t\t\t\twhile(lock != null){\r\n\t\t\t\t\t\t\t\tif(lock == storePage){\r\n\t\t\t\t\t\t\t\t\t//remove lock\r\n\t\t\t\t\t\t\t\t\tif(lock == prev){\r\n\t\t\t\t\t\t\t\t\t\tif(lock.nextLock == null){\r\n\t\t\t\t\t\t\t\t\t\t\t// the first lock is the only lock in the list\r\n\t\t\t\t\t\t\t\t\t\t\tlocksInsert.remove(i--);\r\n\t\t\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t\t\t// only the first lock of the list is remove\r\n\t\t\t\t\t\t\t\t\t\t\tlocksInsert.set( i, lock.nextLock );\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t\t// a lock in the mid or end is removed\r\n\t\t\t\t\t\t\t\t\t\tprev.nextLock = lock.nextLock;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tprev = lock;\r\n\t\t\t\t\t\t\t\tlock = lock.nextLock;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase LOCK_READ:\r\n\t\t\t\t\tcase LOCK_WRITE:\r\n\t\t\t\t\t\tLong pageKey = new Long(fileOffset); //TODO performance\r\n\t\t\t\t\t\tlock = (TableStorePage)locks.get( pageKey );\r\n\t\t\t\t\t\tprev = lock;\r\n\t\t\t\t\t\twhile(lock != null){\r\n\t\t\t\t\t\t\tif(lock == storePage){\r\n\t\t\t\t\t\t\t\t//lock entfernen\r\n\t\t\t\t\t\t\t\tif(lock == prev){\r\n\t\t\t\t\t\t\t\t\tif(lock.nextLock == null){\r\n\t\t\t\t\t\t\t\t\t\t// erste und einzige Lock in Liste\r\n\t\t\t\t\t\t\t\t\t\tlocks.remove(pageKey);\r\n\t\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t\t// the first lock in the list is removed\r\n\t\t\t\t\t\t\t\t\t\tlocks.put( pageKey, lock.nextLock );\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t// a lock in the middle or end of the list is removed\r\n\t\t\t\t\t\t\t\t\tprev.nextLock = lock.nextLock;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tprev = lock;\r\n\t\t\t\t\t\t\tlock = lock.nextLock;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// a run through can occur if a lock was step high and the type does not compare\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase LOCK_TAB:\r\n\t\t\t\t\t\tassert storePage.con == tabLockConnection : \"Internal Error with TabLock\";\r\n\t\t\t\t\t\tif(--tabLockCount == 0) tabLockConnection = null;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tthrow new Error();\r\n\t\t\t\t}\r\n\t\t\t}finally{\r\n\t\t\t\tlocks.notifyAll();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n}\r\n\r\n"},{"path":"/src/smallsql/junit/TestMoneyRounding.java","source":"/* =============================================================\r\n * SmallSQL : a free Java DBMS library for the Java(tm) platform\r\n * =============================================================\r\n *\r\n * (C) Copyright 2004-2006, by Volker Berlin.\r\n *\r\n * Project Info:  http://www.smallsql.de/\r\n *\r\n * This library is free software; you can redistribute it and/or modify it \r\n * under the terms of the GNU Lesser General Public License as published by \r\n * the Free Software Foundation; either version 2.1 of the License, or \r\n * (at your option) any later version.\r\n *\r\n * This library is distributed in the hope that it will be useful, but \r\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \r\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public \r\n * License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, \r\n * USA.  \r\n *\r\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc. \r\n * in the United States and other countries.]\r\n *\r\n * ---------------\r\n * TestMoneyRounding.java\r\n * ---------------\r\n * Author: Volker Berlin\r\n * \r\n */\r\npackage smallsql.junit;\r\n\r\nimport junit.framework.*;\r\n\r\nimport java.math.BigDecimal;\r\nimport java.sql.*;\r\n\r\nimport smallsql.database.Money;\r\n\r\npublic class TestMoneyRounding extends TestCase{\r\n\r\n    static final String table = \"TestMoneyRounding\";\r\n\r\n    public void setUp() throws SQLException{\r\n        tearDown();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tst.execute(\"create table \" + table + \"(a money, b smallmoney)\");\r\n    }\r\n\r\n    public void tearDown(){\r\n        try{\r\n            Connection con = AllTests.getConnection();\r\n            Statement st = con.createStatement();\r\n            st.execute(\"drop table \" + table);\r\n            st.close();\r\n        }catch(Throwable e){\r\n            //e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    public void testMoney1() throws Exception{\r\n            Connection con = AllTests.getConnection();\r\n            Statement st = con.createStatement();\r\n            int firstValue = -10000;\r\n            for(int i=firstValue; i<10000; i++){\r\n                st.execute(\"Insert into \" + table + \"(a,b) values(\" + (i/10000.0) + \",\" +(i/10000.0) +\")\");\r\n            }\r\n            st.close();\r\n            verify(firstValue);\r\n    }\r\n    \r\n    \r\n    private void verify(int firstValue) throws Exception{\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs = st.executeQuery(\"Select * FROM \" + table);\r\n\t\tlong i = firstValue;\r\n\t\twhile(rs.next()){\r\n\t\t\tObject obj1 = rs.getObject(1);\r\n\t\t\tObject obj2 = rs.getObject(2);\r\n\t\t\tif(obj1 instanceof Money){\r\n\t\t\t\tMoney mon1 = (Money)obj1;\r\n\t\t\t\tMoney mon2 = (Money)obj2;\r\n\t\t\t\tassertEquals(\"Roundungsfehler money:\", i, mon1.unscaledValue());\r\n\t\t\t\tassertEquals(\"Roundungsfehler smallmoney:\", i, mon2.unscaledValue());\r\n\t\t\t}else{\r\n\t\t\t\tBigDecimal mon1 = (BigDecimal)obj1;\r\n\t\t\t\tBigDecimal mon2 = (BigDecimal)obj2;\r\n\t\t\t\tassertEquals(\"Roundungsfehler money:\", i, mon1.unscaledValue().longValue());\r\n\t\t\t\tassertEquals(\"Roundungsfehler smallmoney:\", i, mon2.unscaledValue().longValue());\r\n\t\t\t}\r\n\t\t\ti++;\r\n\t\t}\r\n\t\tst.close();\r\n    }\r\n    \r\n    \r\n\tpublic void testMoney2() throws Exception{\r\n\t\t\tConnection con = AllTests.getConnection();\r\n\t\t\tStatement st = con.createStatement();\r\n\t\t\tint firstValue = -10000;\r\n\t\t\tfor(int i=firstValue; i<10000; i++){\r\n\t\t\t\tst.execute(\"Insert into \" + table + \"(a,b) values( (\" + i + \"/10000.0), (\" + i + \"/10000.0) )\");\r\n\t\t\t}\r\n\t\t\tst.close();\r\n\t\t\tverify(firstValue);\r\n\t}\r\n    \r\n}"},{"path":"/src/smallsql/junit/TestDataTypes.java","source":"/* =============================================================\r\n * SmallSQL : a free Java DBMS library for the Java(tm) platform\r\n * =============================================================\r\n *\r\n * (C) Copyright 2004-2007, by Volker Berlin.\r\n *\r\n * Project Info:  http://www.smallsql.de/\r\n *\r\n * This library is free software; you can redistribute it and/or modify it \r\n * under the terms of the GNU Lesser General Public License as published by \r\n * the Free Software Foundation; either version 2.1 of the License, or \r\n * (at your option) any later version.\r\n *\r\n * This library is distributed in the hope that it will be useful, but \r\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \r\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public \r\n * License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, \r\n * USA.  \r\n *\r\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc. \r\n * in the United States and other countries.]\r\n *\r\n * ---------------\r\n * TestDataTypes.java\r\n * ---------------\r\n * Author: Volker Berlin\r\n * \r\n */\r\npackage smallsql.junit;\r\n\r\nimport junit.framework.*;\r\nimport java.sql.*;\r\nimport java.math.*;\r\n\r\npublic class TestDataTypes extends BasicTestCase{\r\n\r\n    static final String[] DATATYPES = { \"varchar(100)\",\r\n                                                \"varchar2(130)\", \"nvarchar(137)\", \"nvarchar2(137)\", \"sysname\",\r\n                                                \"char(100)\", \"CHARACTER(99)\",\r\n                                                \"nchar(80)\",\r\n                                                \"int\", \"smallint\", \"tinyint\", \"bigint\", \"byte\",\r\n                                                \"real\", \"float\", \"double\",\r\n                                                \"bit\", \"Boolean\",\r\n                                                \"binary( 125 )\", \"varbinary(57)\", \"raw(88)\",\r\n                                                \"java_object\", \"sql_variant\",\r\n                                                \"image\", \"LONGvarbinary\", \"long raw\",\r\n                                                \"blob\", \"clob\",\"nclob\",\r\n                                                \"text\", \"ntext\", \"LongVarchar\", \"long\",\r\n                                                \"time\", \"date\", \"datetime\", \"timestamp\", \"SMALLDATETIME\",\r\n                                                \"UNIQUEIDENTIFIER\",\r\n                                                \"numeric(28,4)\", \"decimal(29,4)\",\"number(29,4)\", \"varnum(29,4)\",\r\n                                                \"COUNTER\",\r\n                                                \"money\", \"smallmoney\"};\r\n\r\n    private static final String table = \"table_datatypes\";\r\n\r\n    private String datatype;\r\n\r\n    TestDataTypes( String datatype ){\r\n        super( datatype );\r\n        this.datatype = datatype;\r\n    }\r\n\r\n    public void tearDown(){\r\n        try{\r\n            Connection con = AllTests.getConnection();\r\n            Statement st = con.createStatement();\r\n            st.execute(\"drop table \" + table);\r\n            st.close();\r\n        }catch(Throwable e){\r\n            //e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    public void setUp(){\r\n        tearDown();\r\n    }\r\n\r\n    public void runTest() throws Throwable {\r\n        Connection con = AllTests.getConnection();\r\n        Statement st = con.createStatement();\r\n        st.execute(\"Create Table \" + table +\"(abc \" + datatype + \")\");\r\n        String name = \"abc\";\r\n\r\n        Object[] values = null;\r\n        String   quote = \"\";\r\n        String escape1 = \"\";\r\n        String escape2 = \"\";\r\n        boolean needTrim = false;\r\n\r\n        ResultSet rs = st.executeQuery(\"SELECT * From \" + table);\r\n\t\tResultSetMetaData md = rs.getMetaData();\r\n        switch(md.getColumnType(1)){\r\n            case Types.CHAR:\r\n                needTrim = true;\r\n            case Types.VARCHAR:\r\n            case Types.LONGVARCHAR:\r\n            case Types.CLOB:\r\n                values = new Object[]{null,\"qwert\", \"asdfg\", \"hjhjhj\", \"1234567890 qwertzuiop 1234567890 asdfghjklÃ¶ 1234567890 yxcvbnm,.- 1234567890 \"};\r\n                quote  = \"\\'\";\r\n                break;\r\n            case Types.BIGINT:\r\n                values = new Object[]{null,new Long(123), new Long(-2123), new Long(392839283)};\r\n                break;\r\n            case Types.INTEGER:\r\n                values = new Object[]{null,new Integer(123), new Integer(-2123), new Integer(392839283)};\r\n                break;\r\n            case Types.SMALLINT:\r\n                values = new Object[]{null,new Integer(123), new Integer(-2123), new Integer(32000)};\r\n                break;\r\n            case Types.TINYINT:\r\n                values = new Object[]{null,new Integer(0), new Integer(12), new Integer(228)};\r\n                break;\r\n            case Types.REAL:\r\n                values = new Object[]{null,new Float(0.0), new Float(-12.123), new Float(22812345234.9)};\r\n                break;\r\n            case Types.FLOAT:\r\n            case Types.DOUBLE:\r\n                values = new Object[]{null,new Double(0.0), new Double(-12.123), new Double(22812345234.9)};\r\n                break;\r\n            case Types.NUMERIC:\r\n            case Types.DECIMAL:\r\n                needTrim = true;\r\n            \tif(md.getPrecision(1)<16){//smallmoney\r\n\t\t\t\t\tvalues = new Object[]{null,new BigDecimal(\"0.0\"), new BigDecimal(\"-2\"), new BigDecimal(\"-12.123\")};\r\n                /*if(rs.getMetaData().isCurrency(1)){\r\n                    values = new Object[]{null, new Money(0.0), new Money(-12.123), new Money(202812.9)};*/\r\n                }else{\r\n                    values = new Object[]{null,new BigDecimal(\"0.0\"), new BigDecimal(\"-2\"), new BigDecimal(\"-12.123\"), new BigDecimal(\"22812345234.9\")};\r\n                }\r\n                break;\r\n            case Types.BIT:\r\n            case Types.BOOLEAN:\r\n                values = new Object[]{null, Boolean.TRUE, Boolean.FALSE};\r\n                break;\r\n            case Types.TIME:\r\n                values = new Object[]{null, new Time(10,17,56), new Time(0,0,0),new Time(23,59,59)};\r\n                escape1 = \"{t '\";\r\n                escape2 = \"'}\";\r\n                break;\r\n\t\t\tcase Types.DATE:\r\n\t\t\t\tvalues = new Object[]{null, new java.sql.Date(10,10,1), new java.sql.Date(0,0,1),new java.sql.Date(70,0,1)};\r\n\t\t\t\tescape1 = \"{d '\";\r\n\t\t\t\tescape2 = \"'}\";\r\n\t\t\t\tbreak;\r\n\t\t\tcase Types.TIMESTAMP:\r\n\t\t\t\tif(md.getPrecision(1) >16)\r\n\t\t\t\t\tvalues = new Object[]{null, new Timestamp(10,10,1, 10,17,56, 0), new Timestamp(0,0,1, 0,0,0, 0),new Timestamp( 120,1,1, 23,59,59, 500000000),new Timestamp(0),new Timestamp( -120,1,1, 23,59,59, 500000000)};\r\n\t\t\t\telse//smalldatetime\r\n\t\t\t\t\tvalues = new Object[]{null, new Timestamp(10,10,1, 10,17,0, 0), new Timestamp(0,0,1, 0,0,0, 0),new Timestamp(0)};\r\n\t\t\t\tescape1 = \"{ts '\";\r\n\t\t\t\tescape2 = \"'}\";\r\n\t\t\t\tbreak;\r\n            case Types.BINARY:\r\n                needTrim = true;\r\n            case Types.VARBINARY:\r\n            case Types.LONGVARBINARY:\r\n            case Types.BLOB:\r\n                values = new Object[]{null, new byte[]{1, 127, -23}};\r\n                break;\r\n            case Types.JAVA_OBJECT:\r\n                values = new Object[]{null, new Integer(-123), new Double(1.2), new byte[]{1, 127, -23}};\r\n                break;\r\n            case -11: //UNIQUEIDENTIFER\r\n                values = new Object[]{null, \"342734E3-D9AC-408F-8724-B7A257C4529E\", \"342734E3-D9AC-408F-8724-B7A257C4529E\"};\r\n                quote  = \"\\'\";\r\n                break;\r\n            default: fail(\"Unknown column type: \" + rs.getMetaData().getColumnType(1));\r\n        }\r\n        rs.close();\r\n\t\t\r\n\t\t// remove all resource for reloading the tables from file\r\n\t\tcon.close();\r\n\t\tcon = AllTests.getConnection();\r\n\t\tst = con.createStatement();\r\n\r\n        for(int i=0; i<values.length; i++){\r\n            Object val = values[i];\r\n            String q = (val == null) ? \"\" : quote;\r\n            String e1 = (val == null) ? \"\" : escape1;\r\n            String e2 = (val == null) ? \"\" : escape2;\r\n            if(val instanceof byte[]){\r\n                StringBuffer buf = new StringBuffer( \"0x\" );\r\n                for(int k=0; k<((byte[])val).length; k++){\r\n                    String digit = \"0\" + Integer.toHexString( ((byte[])val)[k] );\r\n                    buf.append( digit.substring( digit.length()-2 ) );\r\n                }\r\n                val = buf.toString();\r\n            }\r\n            st.execute(\"Insert into \" + table + \"(abc) Values(\" + e1 + q + val + q + e2 + \")\");\r\n        }\r\n\t\tcheckValues( st, values, needTrim);\r\n\t\t\r\n\t\tst.execute(\"Delete From \"+ table);\r\n\t\tCallableStatement cal = con.prepareCall(\"Insert Into \" + table + \"(abc) Values(?)\");\r\n        for(int i=0; i<values.length; i++){\r\n            Object val = values[i];\r\n\t\t\tcal.setObject( 1, val);\r\n\t\t\tcal.execute();\r\n        }\r\n\t\tcal.close();\r\n\t\tcheckValues( st, values, needTrim);\r\n\t\t\r\n\t\tst.execute(\"Delete From \"+ table);\r\n\t\tcal = con.prepareCall(\"Insert Into \" + table + \"(abc) Values(?)\");\r\n        for(int i=0; i<values.length; i++){\r\n            Object val = values[i];\r\n\t\t\tif(val == null){\r\n\t\t\t\tcal.setNull( 1, Types.NULL );\r\n\t\t\t}else\r\n\t\t\tif(val instanceof Time){\r\n\t\t\t\tcal.setTime( 1, (Time)val );\r\n\t\t\t}else\r\n\t\t\tif(val instanceof Timestamp){\r\n\t\t\t\tcal.setTimestamp( 1, (Timestamp)val );\r\n\t\t\t}else\r\n\t\t\tif(val instanceof Date){\r\n\t\t\t\tcal.setDate( 1, (Date)val );\r\n\t\t\t}else\r\n\t\t\tif(val instanceof String){\r\n\t\t\t\tcal.setString( 1, (String)val );\r\n\t\t\t}else\r\n\t\t\tif(val instanceof Boolean){\r\n\t\t\t\tcal.setBoolean( 1, ((Boolean)val).booleanValue() );\r\n\t\t\t}else\r\n\t\t\tif(val instanceof Byte){\r\n\t\t\t\tcal.setByte( 1, ((Byte)val).byteValue() );\r\n\t\t\t}else\r\n\t\t\tif(val instanceof Short){\r\n\t\t\t\tcal.setShort( 1, ((Short)val).shortValue() );\r\n\t\t\t}else\r\n\t\t\tif(val instanceof Integer){\r\n\t\t\t\tcal.setInt( 1, ((Integer)val).intValue() );\r\n\t\t\t}else\r\n\t\t\tif(val instanceof Long){\r\n\t\t\t\tcal.setLong( 1, ((Long)val).longValue() );\r\n\t\t\t}else\r\n\t\t\tif(val instanceof Float){\r\n\t\t\t\tcal.setFloat( 1, ((Float)val).floatValue() );\r\n\t\t\t}else\r\n\t\t\tif(val instanceof Double){\r\n\t\t\t\tcal.setDouble( 1, ((Double)val).doubleValue() );\r\n\t\t\t}else\r\n\t\t\tif(val instanceof BigDecimal){\r\n\t\t\t\tcal.setBigDecimal( 1, (BigDecimal)val );\r\n\t\t\t}else\r\n\t\t\tif(val instanceof byte[]){\r\n\t\t\t\tcal.setBytes( 1, (byte[])val );\r\n\t\t\t}\r\n\t\t\tcal.execute();\r\n        }\r\n\t\tcal.close();\r\n\t\tcheckValues( st, values, needTrim);\r\n\r\n        \r\n        st.execute(\"Delete From \"+ table);\r\n        Statement st2 = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);\r\n        ResultSet rs2 = st2.executeQuery(\"SELECT * From \" + table);\r\n        for(int i=0; i<values.length; i++){\r\n            rs2.moveToInsertRow();\r\n            Object val = values[i];\r\n            if(val == null){\r\n                rs2.updateNull( name );\r\n            }else\r\n            if(val instanceof Time){\r\n                rs2.updateTime( name, (Time)val );\r\n            }else\r\n            if(val instanceof Timestamp){\r\n                rs2.updateTimestamp( name, (Timestamp)val );\r\n            }else\r\n            if(val instanceof Date){\r\n                rs2.updateDate( name, (Date)val );\r\n            }else\r\n            if(val instanceof String){\r\n                rs2.updateString( name, (String)val );\r\n            }else\r\n            if(val instanceof Boolean){\r\n                rs2.updateBoolean( name, ((Boolean)val).booleanValue() );\r\n            }else\r\n            if(val instanceof Byte){\r\n                rs2.updateByte( name, ((Byte)val).byteValue() );\r\n            }else\r\n            if(val instanceof Short){\r\n                rs2.updateShort( name, ((Short)val).shortValue() );\r\n            }else\r\n            if(val instanceof Integer){\r\n                rs2.updateInt( name, ((Integer)val).intValue() );\r\n            }else\r\n            if(val instanceof Long){\r\n                rs2.updateLong( name, ((Long)val).longValue() );\r\n            }else\r\n            if(val instanceof Float){\r\n                rs2.updateFloat( name, ((Float)val).floatValue() );\r\n            }else\r\n            if(val instanceof Double){\r\n                rs2.updateDouble( name, ((Double)val).doubleValue() );\r\n            }else\r\n            if(val instanceof BigDecimal){\r\n                rs2.updateBigDecimal( name, (BigDecimal)val );\r\n            }else\r\n            if(val instanceof byte[]){\r\n                rs2.updateBytes( name, (byte[])val );\r\n            }\r\n            rs2.insertRow();\r\n        }\r\n        st2.close();\r\n        checkValues( st, values, needTrim);\r\n    }\r\n\t\r\n\t\r\n\tprivate void checkValues(Statement st, Object[] values, boolean needTrim) throws Exception{\r\n        ResultSet rs = st.executeQuery(\"SELECT * From \" + table);\r\n\r\n        int i = 0;\r\n        while(rs.next()){\r\n            assertEqualsRsValue(values[i], rs, needTrim);\r\n            i++;\r\n        }\r\n        rs.close();\r\n\t}\r\n\r\n\r\n    public static Test suite() throws Exception{\r\n        TestSuite theSuite = new TestSuite(\"Data Types\");\r\n        for(int i=0; i<DATATYPES.length; i++){\r\n            theSuite.addTest(new TestDataTypes( DATATYPES[i] ) );\r\n        }\r\n        return theSuite;\r\n    }\r\n\r\n    public static void main(String[] argv) {\r\n        junit.swingui.TestRunner.main(new String[]{TestDataTypes.class.getName()});\r\n    }\r\n}"},{"path":"/src/smallsql/junit/TestOrderBy.java","source":"/* =============================================================\r\n * SmallSQL : a free Java DBMS library for the Java(tm) platform\r\n * =============================================================\r\n *\r\n * (C) Copyright 2004-2006, by Volker Berlin.\r\n *\r\n * Project Info:  http://www.smallsql.de/\r\n *\r\n * This library is free software; you can redistribute it and/or modify it \r\n * under the terms of the GNU Lesser General Public License as published by \r\n * the Free Software Foundation; either version 2.1 of the License, or \r\n * (at your option) any later version.\r\n *\r\n * This library is distributed in the hope that it will be useful, but \r\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \r\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public \r\n * License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, \r\n * USA.  \r\n *\r\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc. \r\n * in the United States and other countries.]\r\n *\r\n * ---------------\r\n * TestOrderBy.java\r\n * ---------------\r\n * Author: Volker Berlin\r\n * \r\n */\r\npackage smallsql.junit;\r\n\r\nimport java.sql.*;\r\nimport java.util.ArrayList;\r\n\r\n/**\r\n * @author Administrator\r\n *\r\n * To change the template for this generated type comment go to\r\n * Window - Preferences - Java - Code Generation - Code and Comments\r\n */\r\npublic class TestOrderBy extends BasicTestCase {\r\n\r\n\tstatic private boolean init;\r\n\tprivate static final String table1 = \"table_OrderBy1\";\r\n\tprivate static final String table2 = \"table_OrderBy2\";\r\n\tprivate static final String table3 = \"table_OrderBy3\";\r\n\tstatic private int valueCount;\r\n\t\r\n\tpublic void init(){\r\n\t\tif(init) return;\r\n\t\ttry{\r\n\t\t\tConnection con = AllTests.getConnection();\r\n\t\t\tdropTable( con, table1 );\r\n\t\t\tdropTable( con, table2 );\r\n\t\t\tdropTable( con, table3 );\r\n\t\t\tStatement st = con.createStatement();\r\n\t\t\tst.execute(\"create table \" + table1 + \"(v varchar(30), c char(30), nv nvarchar(30),i int, d float, r real, bi bigint, b boolean)\");\r\n\t\t\tst.execute(\"create table \" + table2 + \"(c2 char(30))\");\r\n\t\t\tst.execute(\"create table \" + table3 + \"(vc varchar(30), vb varbinary(30))\");\r\n\t\t\tst.close();\r\n\t\t\t\r\n\t\t\tPreparedStatement pr = con.prepareStatement(\"INSERT into \" + table1 + \"(v,c,nv,i,d,r,bi,b) Values(?,?,?,?,?,?,?,?)\");\r\n\t\t\tPreparedStatement pr2= con.prepareStatement(\"INSERT into \" + table2 + \"(c2) Values(?)\");\r\n\t\t\tfor(int i=150; i>-10; i--){\r\n\t\t\t\tpr.setString( 1, String.valueOf(i));\r\n\t\t\t\tpr.setString( 2, String.valueOf(i));\r\n\t\t\t\tpr.setString( 3, String.valueOf( (char)i ));\r\n\t\t\t\tpr.setInt   ( 4, i );\r\n\t\t\t\tpr.setDouble( 5, i );\r\n\t\t\t\tpr.setFloat ( 6, i );\r\n\t\t\t\tpr.setInt   ( 7, i );\r\n\t\t\t\tpr.setBoolean( 8, i == 0 );\r\n\t\t\t\tpr.execute();\r\n\t\t\t\tpr2.setString( 1, String.valueOf(i));\r\n\t\t\t\tpr2.execute();\r\n\t\t\t\tvalueCount++;\r\n\t\t\t}\r\n\t\t\tpr.setObject( 1, null, Types.VARCHAR);\r\n\t\t\tpr.setObject( 2, null, Types.VARCHAR);\r\n\t\t\tpr.setObject( 3, null, Types.VARCHAR);\r\n\t\t\tpr.setObject( 4, null, Types.VARCHAR);\r\n\t\t\tpr.setObject( 5, null, Types.VARCHAR);\r\n\t\t\tpr.setObject( 6, null, Types.VARCHAR);\r\n\t\t\tpr.setObject( 7, null, Types.VARCHAR);\r\n\t\t\tpr.setObject( 8, null, Types.VARCHAR);\r\n\t\t\tpr.execute();\r\n\t\t\tpr2.setObject( 1, null, Types.VARCHAR);\r\n\t\t\tpr2.execute();\r\n\t\t\tpr2.setString( 1, \"\");\r\n\t\t\tpr2.execute();\r\n\r\n\t\t\tpr.close();\r\n\r\n\t\t\tpr = con.prepareStatement(\"INSERT into \" + table3 + \"(vc, vb) Values(?,?)\");\r\n\t\t\tpr.setString( 1, table3);\r\n\t\t\tpr.setBytes( 2, table3.getBytes());\r\n\t\t\tpr.execute();\r\n\t\t\tpr.setString( 1, \"\");\r\n\t\t\tpr.setBytes( 2, new byte[0]);\r\n\t\t\tpr.execute();\r\n\t\t\tpr.setString( 1, null);\r\n\t\t\tpr.setBytes( 2, null);\r\n\t\t\tpr.execute();\r\n\t\t\t\r\n\t\t\tinit = true;\r\n\t\t}catch(Throwable e){\r\n\t\t\te.printStackTrace();\r\n\t\t}\r\n\t}\r\n\t\r\n\t\r\n\tpublic void testOrderBy_char() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tString oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by c\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = rs.getString(\"c\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"c\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tString newValue = rs.getString(\"c\");\r\n\t\t\tassertTrue( oldValue + \"<\" + newValue, oldValue.compareTo( newValue ) < 0 );\r\n\t\t\toldValue = newValue;\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\trs.close();\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void testOrderBy_varchar() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tString oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by v\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tString newValue = rs.getString(\"v\");\r\n\t\t\tassertTrue( oldValue + \"<\" + newValue, oldValue.compareTo( newValue ) < 0 );\r\n\t\t\toldValue = newValue;\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void testOrderBy_varchar_asc() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tString oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by v ASC\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tString newValue = rs.getString(\"v\");\r\n\t\t\tassertTrue( oldValue.compareTo( newValue ) < 0 );\r\n\t\t\toldValue = newValue;\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\trs.close();\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void testOrderBy_varchar_desc() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tString oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by v desc\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(oldValue != null && rs.next()){\r\n\t\t\tString newValue = rs.getString(\"v\");\r\n\t\t\tif(newValue != null){\r\n\t\t\t\tassertTrue( oldValue.compareTo( newValue ) > 0 );\r\n\t\t\t\tcount++;\r\n\t\t\t}\r\n\t\t\toldValue = newValue;\r\n\t\t}\r\n\t\tassertNull(oldValue);\r\n\t\tassertFalse( rs.next() );\r\n\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\t\r\n\tpublic void testOrderBy_varchar_DescAsc() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tString oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by v desc, i asc\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(oldValue != null && rs.next()){\r\n\t\t\tString newValue = rs.getString(\"v\");\r\n\t\t\tif(newValue != null){\r\n\t\t\t\tassertTrue( oldValue.compareTo( newValue ) > 0 );\r\n\t\t\t\tcount++;\r\n\t\t\t}\r\n\t\t\toldValue = newValue;\r\n\t\t}\r\n\t\tassertNull(oldValue);\r\n\t\tassertFalse( rs.next() );\r\n\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\t\r\n\tpublic void testOrderBy_varchar_GroupBy() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tString oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT first(v) cc FROM \" + table1 + \" Group By i ORDER  by first(V)\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = rs.getString(\"cc\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"cc\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tassertTrue( oldValue.compareTo( rs.getString(\"cc\") ) < 0 );\r\n\t\t\toldValue = rs.getString(\"cc\");\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void testOrderBy_varchar_Join() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tString oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" t1 Inner join \"+table2+\" t2 on t1.c=t2.c2  ORDER  by v\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tassertTrue( oldValue.compareTo( rs.getString(\"v\") ) < 0 );\r\n\t\t\toldValue = rs.getString(\"v\");\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void testOrderBy_nvarchar() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tString oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by nv\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = rs.getString(\"nv\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"nv\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tassertTrue( String.CASE_INSENSITIVE_ORDER.compare( oldValue, rs.getString(\"nv\") ) <= 0 );\r\n\t\t\toldValue = rs.getString(\"nv\");\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void testOrderBy_int() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tInteger oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by i\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = (Integer)rs.getObject(\"i\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = (Integer)rs.getObject(\"i\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tassertTrue( oldValue.compareTo( (Integer)rs.getObject(\"i\") ) < 0 );\r\n\t\t\toldValue = (Integer)rs.getObject(\"i\");\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void test_function() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tint oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by abs(i)\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\tassertNull(rs.getObject(\"i\"));\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = Math.abs( rs.getInt(\"i\") );\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tint newValue = Math.abs( rs.getInt(\"i\") );\r\n\t\t\tassertTrue( oldValue <= newValue );\r\n\t\t\toldValue = newValue;\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void test_functionAscDesc() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tint oldValue;\r\n\t\tint oldValue2;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by abs(i) Asc, i desc\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\tassertNull(rs.getObject(\"i\"));\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = Math.abs( rs.getInt(\"i\") );\r\n\t\toldValue2 = rs.getInt(\"i\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tint newValue2 = rs.getInt(\"i\");\r\n\t\t\tint newValue = Math.abs( newValue2 );\r\n\t\t\tassertTrue( oldValue <= newValue );\r\n\t\t\tif(oldValue == newValue){\r\n\t\t\t\tassertTrue( oldValue2 > newValue2 );\r\n\t\t\t}\r\n\t\t\toldValue = newValue;\r\n\t\t\toldValue2 = newValue2;\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void testOrderBy_int_asc() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tInteger oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by i Asc\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = (Integer)rs.getObject(\"i\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = (Integer)rs.getObject(\"i\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tassertTrue( oldValue.compareTo( (Integer)rs.getObject(\"i\") ) < 0 );\r\n\t\t\toldValue = (Integer)rs.getObject(\"i\");\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void testOrderBy_int_desc() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tInteger oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by i Desc\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = (Integer)rs.getObject(\"i\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(oldValue != null && rs.next()){\r\n\t\t\tInteger newValue = (Integer)rs.getObject(\"i\");\r\n\t\t\tif(newValue != null){\r\n\t\t\t\tassertTrue( oldValue.compareTo( newValue ) > 0 );\r\n\t\t\t\tcount++;\r\n\t\t\t}\r\n\t\t\toldValue = newValue;\r\n\t\t}\r\n\t\tassertNull(oldValue);\r\n\t\tassertFalse( rs.next() );\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void testOrderBy_double() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tDouble oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by d\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = (Double)rs.getObject(\"d\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = (Double)rs.getObject(\"d\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tassertTrue( oldValue.compareTo( (Double)rs.getObject(\"d\") ) < 0 );\r\n\t\t\toldValue = (Double)rs.getObject(\"d\");\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void testOrderBy_real() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tFloat oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by r\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = (Float)rs.getObject(\"r\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = (Float)rs.getObject(\"r\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tassertTrue( oldValue.compareTo( (Float)rs.getObject(\"r\") ) < 0 );\r\n\t\t\toldValue = (Float)rs.getObject(\"r\");\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void test_bigint() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tLong oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by bi\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = (Long)rs.getObject(\"bi\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = (Long)rs.getObject(\"bi\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tassertTrue( oldValue.compareTo( (Long)rs.getObject(\"bi\") ) < 0 );\r\n\t\t\toldValue = (Long)rs.getObject(\"bi\");\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void test_bigint_withDoublicateValues() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tLong oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT bi/2 bi_2 FROM \" + table1 + \" ORDER  by (bi/2)\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = (Long)rs.getObject(\"bi_2\");\r\n\t\tassertNull(oldValue);\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = (Long)rs.getObject(\"bi_2\");\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(rs.next()){\r\n\t\t\tLong newValue = (Long)rs.getObject(\"bi_2\");\r\n\t\t\tassertTrue( oldValue + \"<=\"+newValue, oldValue.compareTo( newValue ) <= 0 );\r\n\t\t\toldValue = newValue;\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void test_boolean() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tboolean oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by b\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\t\r\n\t\toldValue = rs.getBoolean(\"b\");\r\n\t\tassertFalse(oldValue);\r\n\t\tassertTrue(rs.wasNull());\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getBoolean(\"b\");\r\n\t\tassertFalse(oldValue);\t\t\r\n\t\tassertFalse(rs.wasNull());\r\n\t\t\r\n\t\tint count = 1;\r\n\t\twhile(!oldValue && rs.next()){\r\n\t\t\toldValue = rs.getBoolean(\"b\");\r\n\t\t\tassertFalse(rs.wasNull());\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\twhile(oldValue && rs.next()){\r\n\t\t\toldValue = rs.getBoolean(\"b\");\r\n\t\t\tassertFalse(rs.wasNull());\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertFalse(rs.next());\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\t\r\n\r\n\tpublic void testVarcharEmpty() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table3 + \" ORDER  by vc\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\t\t\r\n\t\tassertNull( rs.getObject(\"vc\") );\r\n\r\n\t\tassertTrue( rs.next() );\r\n\t\tassertEquals( \"\", rs.getObject(\"vc\") );\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\tassertEquals( table3, rs.getObject(\"vc\") );\r\n\t\t\r\n\t\tassertFalse( rs.next() );\r\n\t}\r\n\t\r\n\r\n\tpublic void testVarbinaryEmpty() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table3 + \" ORDER  by vb\");\r\n\t\t\r\n\t\tassertTrue( rs.next() );\t\t\r\n\t\tassertNull( rs.getObject(\"vb\") );\r\n\r\n\t\tassertTrue( rs.next() );\r\n\t\tassertEqualsObject( \"\", new byte[0], rs.getObject(\"vb\"), false );\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\tassertEqualsObject( \"\", table3.getBytes(), rs.getObject(\"vb\"), false );\r\n\t\t\r\n\t\tassertFalse( rs.next() );\r\n\t}\r\n\r\n\r\n\tpublic void test2Columns() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs = null;\r\n\t\tString oldValue;\r\n\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1+\",\"+table2+\" ORDER  by v, c2\");\r\n\r\n\t\tassertTrue( rs.next() );\r\n\t\tassertNull( rs.getObject(\"v\") );\r\n\t\tassertNull( rs.getObject(\"c2\") );\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"c2\");\r\n\r\n\t\tint count = 1;\r\n\t\twhile(rs.next() && rs.getString(\"v\") == null){\r\n\t\t\tString newValue = rs.getString(\"c2\");\r\n\t\t\tassertTrue( oldValue.compareTo( newValue ) < 0 );\r\n\t\t\toldValue = newValue;\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount+1, count );\r\n\t\t\r\n\t\tboolean isNext = true;\r\n\t\twhile(isNext){\r\n\t\t\tString vValue = rs.getString(\"v\");\r\n\t\t\tassertNull( rs.getObject(\"c2\") );\r\n\t\t\r\n\t\t\tassertTrue( rs.next() );\r\n\t\t\toldValue = rs.getString(\"c2\");\r\n\t\t\tassertEquals( vValue, rs.getString(\"v\") );\r\n\r\n\t\t\tisNext = rs.next();\r\n\t\t\tcount = 1;\r\n\t\t\twhile(isNext && vValue.equals(rs.getString(\"v\"))){\r\n\t\t\t\tString newValue = rs.getString(\"c2\");\r\n\t\t\t\tassertTrue( oldValue.compareTo( newValue ) < 0 );\r\n\t\t\t\toldValue = newValue;\r\n\t\t\t\tcount++;\r\n\t\t\t\tisNext = rs.next();\r\n\t\t\t}\r\n\t\t\tassertEquals( valueCount+1, count );\r\n\t\t}\r\n\t}\r\n\r\n\t\r\n\r\n\tpublic void testOrderBy_Scollable() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);\r\n\t\tResultSet rs;\r\n\t\tint count;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by v\");\r\n\t\t\r\n\t\t//jetzt irgendwo in die Mitte scrollen\r\n\t\trs.next();\r\n\t\trs.next();\r\n\t\trs.previous(); //dann soll der Zeiger nicht am Ende des bereits gefetchten stehen\r\n\t\t\r\n\t\trs.last();\r\n\t\tcount = 0;\r\n\t\twhile(rs.previous()) count++;\t\t\r\n\t\tassertEquals( valueCount, count );\r\n\r\n\t\trs.beforeFirst();\r\n\t\tcount = -1;\r\n\t\twhile(rs.next()) count++;\t\t\r\n\t\tassertEquals( valueCount, count );\r\n\r\n\t\trs.beforeFirst();\r\n\t\tcount = -1;\r\n\t\twhile(rs.next()) count++;\t\t\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\r\n\t\r\n\tpublic void testOrderBy_ScollableDesc() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);\r\n\t\tResultSet rs;\r\n\t\tint count;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by i desc, d\");\r\n\t\t\r\n\t\t//jetzt irgendwo in die Mitte scrollen\r\n\t\trs.next();\r\n\t\trs.next();\r\n\t\trs.previous(); //dann soll der Zeiger nicht am Ende des bereits gefetchten stehen\r\n\t\t\r\n\t\trs.last();\r\n\t\tcount = 0;\r\n\t\twhile(rs.previous()) count++;\t\t\r\n\t\tassertEquals( valueCount, count );\r\n\r\n\t\trs.beforeFirst();\r\n\t\tcount = -1;\r\n\t\twhile(rs.next()) count++;\t\t\r\n\t\tassertEquals( valueCount, count );\r\n\r\n\t\trs.beforeFirst();\r\n\t\tcount = -1;\r\n\t\twhile(rs.next()) count++;\t\t\r\n\t\tassertEquals( valueCount, count );\r\n\t}\r\n\r\n\t\r\n\tpublic void testOrderBy_Scollable2() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);\r\n\t\tResultSet rs = st.executeQuery(\"SELECT * FROM \" + table1 + \" ORDER  by v\");\r\n\r\n\t\t\r\n\t\tint colCount = rs.getMetaData().getColumnCount();\r\n\t\tArrayList result = new ArrayList();\r\n\t\twhile(rs.next()){\r\n\t\t\tObject[] row = new Object[colCount];\r\n\t\t\tfor(int i=0; i<colCount; i++){\r\n\t\t\t\trow[i] = rs.getObject(i+1);\r\n\t\t\t}\r\n\t\t\tresult.add(row);\r\n\t\t}\r\n\t\t\r\n\t\tint rowCount = result.size();\r\n\t\twhile(rs.previous()){\r\n\t\t\tObject[] row = (Object[])result.get(--rowCount);\r\n\t\t\tfor(int i=0; i<colCount; i++){\r\n\t\t\t\tassertEquals( \"Difference in row:\"+rowCount, row[i], rs.getObject(i+1));\r\n\t\t\t}\r\n\t\t}\r\n\t\tassertEquals( \"RowCount different between next and previous:\"+rowCount, 0, rowCount);\r\n\t}\r\n\r\n\t\r\n\tpublic void testUnion() throws Exception{\r\n\t\tinit();\r\n\t\tConnection con = AllTests.getConnection();\r\n\t\tStatement st = con.createStatement();\r\n\t\tResultSet rs;\r\n\t\tString oldValue;\r\n\t\t\r\n\t\trs = st.executeQuery(\"SELECT v, 5 as Const FROM \" + table1 + \" Union All Select vc, 6 From \" + table3 + \" ORDER by v\");\r\n\t\t\r\n\t\tassertRSMetaData(rs, new String[]{\"v\", \"Const\"}, new int[]{Types.VARCHAR, Types.INTEGER});\r\n\t\t\r\n\t\tassertTrue( rs.next() );\t\t\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\tassertNull(oldValue);\r\n\t\t\r\n\t\tassertTrue( rs.next() );\t\t\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\tassertNull(oldValue);\r\n\t\t\r\n\t\tassertTrue( rs.next() );\r\n\t\toldValue = rs.getString(\"v\");\r\n\t\t\r\n\t\tint count = 3;\r\n\t\twhile(rs.next()){\r\n\t\t\tString newValue = rs.getString(\"v\");\r\n\t\t\tassertTrue( oldValue.compareTo( newValue ) < 0 );\r\n\t\t\toldValue = newValue;\r\n\t\t\tcount++;\r\n\t\t}\r\n\t\tassertEquals( valueCount+4, count );\r\n\t}\r\n\r\n\r\n}\r\n"}]}